<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="222222"/><link rel="alternate" href="/atom.xml" title="K1rit0's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://tearsjin.github.io/page/4/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>K1rit0's Blog</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">K1rit0's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a><a href="/link/">
        <li class="mobile-menu-item">Link
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">K1rit0's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/link/">
            Link
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/31/The-learning-of-LWE/">The learning of LWE</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-31
        </span><span class="post-category">
            <a href="/categories/CryptoSummary/">CryptoSummary</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>做Ant&amp;d3的时候发现自己Lattice还不会, 所以就去学了一波Lattice, 顺便就了解了一下LWE, 发现这玩意居然有三次比赛用的都是同一个板子, 也每个都去做了分析了一下, 然后就集中在这里了.</p>
<blockquote>
<p>感谢一位大大大大大师傅详细的wp，我才能这么快的明白原理，指路 —&gt;  <a target="_blank" rel="noopener" href="https://blog.soreatu.com/">https://blog.soreatu.com/</a></p>
</blockquote>
<h1 id="X-NUCA-Diamond"><a href="#X-NUCA-Diamond" class="headerlink" title="X-NUCA Diamond"></a>X-NUCA Diamond</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> sage.crypto.lwe <span class="keyword">import</span> LWE</span><br><span class="line"><span class="keyword">from</span> sage.stats.distributions.discrete_gaussian_integer <span class="keyword">import</span> DiscreteGaussianDistributionIntegerSampler <span class="keyword">as</span> DGDIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> FLAG</span><br><span class="line"><span class="keyword">assert</span> FLAG.startswith(<span class="string">b&quot;X-NUCA&#123;&quot;</span>) <span class="keyword">and</span> FLAG.endswith(<span class="string">b&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">A = random_matrix(ZZ, <span class="number">320</span>, <span class="number">5</span>, x = <span class="number">10</span>, y = <span class="number">1000</span>)</span><br><span class="line">B = Matrix(A * vector([randint(<span class="number">1</span>, <span class="number">2</span>^<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">L = LWE(n = <span class="number">25</span>, q = <span class="number">1000</span>, D = DGDIS(<span class="number">3</span>))</span><br><span class="line">S = [L() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)]</span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="number">64</span>, <span class="number">25</span>, [<span class="built_in">int</span>(i).__xor__(<span class="built_in">int</span>(j)) <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(A.<span class="built_in">list</span>(), (Matrix([x <span class="keyword">for</span> x, _ <span class="keyword">in</span> S])).<span class="built_in">list</span>())])</span><br><span class="line">T = Matrix([randint(<span class="number">1</span>, <span class="number">2</span>^<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)])</span><br><span class="line">R = T.transpose().stack(T * vector([y <span class="keyword">for</span> _, y <span class="keyword">in</span> S]).change_ring(ZZ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	key = sha256(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, L._LWE__s))).encode()).digest()</span><br><span class="line">	iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">	cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">	ct = cipher.encrypt(FLAG)</span><br><span class="line"></span><br><span class="line">	f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">	f.write(<span class="built_in">str</span>(B.<span class="built_in">list</span>()).encode() + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">	f.write(<span class="built_in">str</span>(M.<span class="built_in">list</span>()).encode() + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">	f.write(<span class="built_in">str</span>(R.<span class="built_in">list</span>()).encode() + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">	f.write((iv + ct).<span class="built_in">hex</span>().encode())</span><br><span class="line">	f.close()</span><br></pre></td></tr></table></figure>



<h2 id="一些新见到的函数"><a href="#一些新见到的函数" class="headerlink" title="一些新见到的函数"></a>一些新见到的函数</h2><ol>
<li><p><code>random_matrix(ZZ, 5, 320, x = 10, y = 1000)</code>: 随机生成一个整数的$320 \cdot 5$矩阵, 其元素的取值范围是$[x,y)$也就是$[10,1000)$</p>
</li>
<li><p><code>LWE(n = 25, q = 1000, D = DGDIS(3))</code>: 生成一个25维 $mod \ 1000$的LWE对象</p>
<p><code>D</code> - an error distribution such as an instance of <code>DiscreteGaussianDistributionIntegerSampler</code></p>
</li>
<li><p><code>stack()</code>: 在末尾添加一行</p>
</li>
</ol>
<h2 id="题目中给出的一些条件"><a href="#题目中给出的一些条件" class="headerlink" title="题目中给出的一些条件"></a>题目中给出的一些条件</h2><ul>
<li>首先是一个<code>320*5</code>的矩阵$A$，乘上了一个随机变换矩阵<code>5*7</code>的矩阵$R$，得到了一个<code>320*7</code>的矩阵B</li>
<li>然后是一个LWE，生成了64组数据，$s⋅A_{lwe}+e=a$，没有直接给我们$A_{lwe}$和$a$。只给了$M=A{lwe}\bigoplus A$，以及用$s$作为AES的key，对flag进行了加密。</li>
<li>再就是一个knapsack problem，用长度为64的向量$a$与一个另外一个很大的长度为64的随机向量$T$相乘，得到一个很大的数$sum$。给了$T$以及$sum$。</li>
</ul>
<h2 id="knapsack-problem"><a href="#knapsack-problem" class="headerlink" title="knapsack problem"></a>knapsack problem</h2><p>这里有一个背包问题<br>$$<br>a_0T_0+a_1T_1+…+a_{63}T_{63} = sum<br>$$<br>其中已知$T_0,T_1,…,T_{63},sum$,而且$T_i$非常大, $a_i \le 1000$ , 可以由上述式子构造格子<br>$$<br>A=<br>\begin{pmatrix}<br>1&amp;0&amp;\cdots&amp;0&amp;T_0\\<br>0&amp;1&amp;\cdots&amp;0&amp;T_1\\<br>\vdots&amp;\vdots&amp;\ddots&amp;0&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;1&amp;T_{63}\\<br>0&amp;0&amp;\cdots&amp;0&amp;-sum<br>\end{pmatrix}<br>$$<br>则有<br>$$<br>\begin{pmatrix}<br>a_0,a_1,…,a_{63},{1}<br>\end{pmatrix}<br>\begin{pmatrix}<br>1&amp;0&amp;\cdots&amp;0&amp;T_0\\<br>0&amp;1&amp;\cdots&amp;0&amp;T_1\\<br>\vdots&amp;\vdots&amp;\ddots&amp;0&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;1&amp;T_{63}\\<br>0&amp;0&amp;\cdots&amp;0&amp;-sum<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>a_0,a_1,…,a_{63},{0}<br>\end{pmatrix}<br>$$<br>可以看到$\begin{pmatrix}a_0,a_1,…,a_{63},0\end{pmatrix}$是其中一个格点, 而且非常的小, 可以尝试用LLL将其规约出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">R = [...]</span><br><span class="line">Lattice = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>):</span><br><span class="line">        <span class="keyword">if</span> i==j <span class="keyword">and</span> i!= <span class="number">64</span>:</span><br><span class="line">            Lattice[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j== <span class="number">64</span>:</span><br><span class="line">            Lattice[i][j] = R[i]</span><br><span class="line">Lattice[<span class="number">64</span>][<span class="number">64</span>] = -Lattice[<span class="number">64</span>][<span class="number">64</span>]</span><br><span class="line">Lattice = Matrix(Lattice)</span><br><span class="line">a = Lattice.LLL()[<span class="number">0</span>][:-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># (868, 798, 863, 260, 206, 550, 326, 908, 49, 50, 273, 528, 584, 569, 975, 261, 885, 680, 116, 33, 677, 664, 922, 178, 999, 336, 60, 655, 102, 438, 269, 754, 988, 124, 10, 380, 589, 382, 668, 623, 335, 845, 104, 117, 961, 917, 114, 590, 255, 26, 81, 846, 925, 548, 446, 796, 543, 997, 492, 651, 485, 137, 701, 247)</span></span><br></pre></td></tr></table></figure>

<h2 id="恢复-A-lwe"><a href="#恢复-A-lwe" class="headerlink" title="恢复$A_{lwe}$"></a>恢复$A_{lwe}$</h2><p>这部分还有些不明白,先放着</p>
<h2 id="LWE"><a href="#LWE" class="headerlink" title="LWE"></a>LWE</h2><p>$$<br>s \cdot A + e = a<br>$$</p>
<p>可以将这个等式理解成$A$是一个格子, $s$是一个线性组合, 那么$b = s \cdot A$是一个格点, $e$是误差, $a = b+e$是一个非格点. LWE就是要找到这么离这个非格点最近的格点. 也就是CVP了</p>
<p>当$s$的长度不是很长的时候, 也就是说维度比较小的时候, 这个CVP还是可以解决的, 而这里$s$的长度是25, 观察一下LWE的式子.<br>$$<br>s_0A_{i,0}+s_1A_{i,1}+…+s_{24}A_{i,24} + e_i = a_i \ (mod \ p)<br>$$<br>熟悉的造格子前的套路, 将式子化为:<br>$$<br>s_0A_{i,0}+s_1A_{i,1}+…+s_{24}A_{i,24} + k_ip + e_i= a_i<br>$$<br>那么可以构造出等式:<br>$$<br>s \cdot L + e =<br>(s_0,s_1,…,s_{24},k_0,k_1,…,k_{39})<br>\begin{pmatrix}<br>A_{0,0}&amp;A_{1,0}&amp;\cdots&amp;A_{39,0}\\<br>A_{0,1}&amp;A_{1,1}&amp;\cdots&amp;A_{39,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>A_{0,24}&amp;A_{1,24}&amp;\cdots&amp;A_{39,24}\\<br>p&amp;0&amp;\cdots&amp;0\\<br>0&amp;p&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;p\\<br>\end{pmatrix}<br>+<br>(e_0,e_1,…,e_{39})<br>=<br>(c_0,c_1,…,c_{39})<br>$$<br>先对矩阵$L$进行规约, 得到一个good basis, 再用Babai’s algorithm求解CVP，即可得到离$a$最近的格点$b$。</p>
<p>最后解方程$A_{lwe} \cdot s = b^{T} (mod \ 1000)$</p>
<p>解出$s$这道题基本上就做完了</p>
<p>下面是Babai’s algorithm的板子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BabaisClosestPlaneAlgorithm</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Yet another method to solve apprCVP, using a given good basis.</span></span><br><span class="line"><span class="string">    INPUT:</span></span><br><span class="line"><span class="string">    * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice.</span></span><br><span class="line"><span class="string">    * &quot;w&quot; -- a target vector to approach to.</span></span><br><span class="line"><span class="string">    OUTPUT:</span></span><br><span class="line"><span class="string">    * &quot;v&quot; -- a approximate closest vector.</span></span><br><span class="line"><span class="string">    Quoted from &quot;An Introduction to Mathematical Cryptography&quot;:</span></span><br><span class="line"><span class="string">    In both theory and practice, Babai&#x27;s closest plane algorithm</span></span><br><span class="line"><span class="string">    seems to yield better results than Babai&#x27;s closest vertex algorithm.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    G, _ = L.gram_schmidt()</span><br><span class="line">    t = w</span><br><span class="line">    i = L.nrows() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        w -= <span class="built_in">round</span>( (w*G[i]) / G[i].norm()^<span class="number">2</span> ) * L[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t - w</span><br></pre></td></tr></table></figure>

<p>总的exp就没写了, 具体的可以参照着下面两题来写, 反正都是一个板子的</p>
<h1 id="2020祥云杯-Easy-Matrix"><a href="#2020祥云杯-Easy-Matrix" class="headerlink" title="2020祥云杯 Easy Matrix"></a>2020祥云杯 Easy Matrix</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_offset</span>(<span class="params">size</span>):</span></span><br><span class="line">    x = np.random.normal(<span class="number">0</span>, <span class="number">4.7873</span>, size)</span><br><span class="line">    <span class="keyword">return</span> np.rint(x)</span><br><span class="line"></span><br><span class="line">secret = np.array(<span class="built_in">list</span>(flag))</span><br><span class="line"></span><br><span class="line">column = <span class="built_in">len</span>(<span class="built_in">list</span>(secret))</span><br><span class="line">row = <span class="number">128</span></span><br><span class="line">prime = <span class="number">2129</span></span><br><span class="line"></span><br><span class="line">matrix = np.random.randint(<span class="number">512</span>, size=(row, column))</span><br><span class="line">product = matrix.dot(secret) % prime</span><br><span class="line">offset = random_offset(size=row).astype(np.int64)</span><br><span class="line">result = (product + offset) % prime</span><br><span class="line"></span><br><span class="line">np.save(<span class="string">&quot;matrix.npy&quot;</span>, matrix)</span><br><span class="line">np.save(<span class="string">&quot;result.npy&quot;</span>, result)</span><br></pre></td></tr></table></figure>

<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>读取了matrix后就可以知道column = 42</p>
<p>将<code>flag</code>转成一个<code>1*42</code>的矩阵$secret$</p>
<p>来看看过程, 先是生成一个<code>42*128 </code>的随机矩阵$matrix$, 元素都$\leq 512$</p>
<p>然后计算$product = matrix \cdot secret \ (mod \ prime)$, 结果应该是一个$1*128$的矩阵</p>
<p>继续生成一个<code>1*128</code>随机矩阵$offset$</p>
<p>最后计算$result = (product + offset) \ (mod \ prime)$</p>
<p>题目给了$result$和$matrix$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>来看一下加密的式子<br>$$<br>R = S \cdot M + e \ (mod \ p)<br>$$<br>显然是一个LWE, 现在已知的是$M$和$R$, 要求$S$, 将式子写具体<br>$$<br>R = (r_0,r_1,..,r_{127}) =<br>(s_0,s_1,…,s_{41})<br>\begin{pmatrix}<br>m_{0,0}&amp;m_{1,0}&amp;\cdots&amp;m_{127,0}\\<br>m_{0,1}&amp;m_{1,1}&amp;\cdots&amp;m_{127,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>m_{0,41}&amp;m_{1,42}&amp;\cdots&amp;m_{127,41}<br>\end{pmatrix}<br>+<br>(e_0,e_1,…,e_{41})<br>(mod \ p)<br>$$<br>也就是说<br>$$<br>r_i = s_0m_{i,0} + s_1m_{i,1}+…+s_{41}m_{i,41} + e_i (mod \ p)<br>$$</p>
<p>老套路, 改写成等式有<br>$$<br>s_0m_{i,0} + s_1m_{i,1}+…+s_{41}m_{i,41} + e_i + k_ip = r_i \<br>s \cdot A + e = r<br>$$</p>
<p>解决LWE可以构造格子, 然后用LLL和babai’s nearest plane来解决, 下面就根据等式构造格子<br>$$<br>A=<br>\begin{pmatrix}<br>m_{0,0}&amp;m_{1,0}&amp;\cdots&amp;m_{127,0}\\<br>m_{0,1}&amp;m_{1,1}&amp;\cdots&amp;m_{127,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>m_{0,41}&amp;m_{1,42}&amp;\cdots&amp;m_{127,41}\\<br>p&amp;0&amp;\cdots&amp;0\\<br>0&amp;p&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;p<br>\end{pmatrix}<br>\begin{pmatrix}<br>p&amp;0&amp;\cdots&amp;0\\<br>0&amp;p&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;p\\<br>m_{0,0}&amp;m_{1,0}&amp;\cdots&amp;m_{127,0}\\<br>m_{0,1}&amp;m_{1,1}&amp;\cdots&amp;m_{127,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>m_{0,41}&amp;m_{1,42}&amp;\cdots&amp;m_{127,41}\\<br>\end{pmatrix}\\<br>$$</p>
<p>实际上做的时候右边的格子才有用, 左边的不行, 具体原因我也搞不清楚, 问了老师也没问出什么结果</p>
<p>然后就可以用LLL格约出good basis 再用babai’s nearest plane解CVP了</p>
<p>解出CVP也就意味着找到了$s \cdot A = b$中的$b$ , $A$又是已知的, 解方程即可</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BabaisClosestPlaneAlgorithm</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Yet another method to solve apprCVP, using a given good basis.</span></span><br><span class="line"><span class="string">    INPUT:</span></span><br><span class="line"><span class="string">    * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice.</span></span><br><span class="line"><span class="string">    * &quot;w&quot; -- a target vector to approach to.</span></span><br><span class="line"><span class="string">    OUTPUT:</span></span><br><span class="line"><span class="string">    * &quot;v&quot; -- a approximate closest vector.</span></span><br><span class="line"><span class="string">    Quoted from &quot;An Introduction to Mathematical Cryptography&quot;:</span></span><br><span class="line"><span class="string">    In both theory and practice, Babai&#x27;s closest plane algorithm</span></span><br><span class="line"><span class="string">    seems to yield better results than Babai&#x27;s closest vertex algorithm.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    G, _ = L.gram_schmidt()</span><br><span class="line">    t = w</span><br><span class="line">    i = L.nrows() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        w -= <span class="built_in">round</span>( (w*G[i]) / G[i].norm()^<span class="number">2</span> ) * L[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t - w</span><br><span class="line">row = <span class="number">128</span></span><br><span class="line">col = <span class="number">42</span></span><br><span class="line">p = <span class="number">2129</span></span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="built_in">list</span>(np.load(<span class="string">&#x27;matrix.npy&#x27;</span>)))</span><br><span class="line">R = vector(<span class="built_in">list</span>(np.load(<span class="string">&#x27;result.npy&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">A = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> i==j:</span><br><span class="line">            A[i][j] = p</span><br><span class="line">A = Matrix(A)</span><br><span class="line">L = Matrix(A.stack(M.transpose()))</span><br><span class="line">lattice = IntegerLattice(L, lll_reduce=<span class="literal">True</span>)</span><br><span class="line">closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)</span><br><span class="line"></span><br><span class="line">FLAG = Matrix(Zmod(p), M)</span><br><span class="line">flag = FLAG.solve_right(closest_vector)</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join( <span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br></pre></td></tr></table></figure>

<h1 id="2020纵横杯-babyLWE"><a href="#2020纵横杯-babyLWE" class="headerlink" title="2020纵横杯 babyLWE"></a>2020纵横杯 babyLWE</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.crypto.lwe <span class="keyword">import</span> LWE</span><br><span class="line"><span class="keyword">from</span> sage.stats.distributions.discrete_gaussian_integer \</span><br><span class="line">    <span class="keyword">import</span> DiscreteGaussianDistributionIntegerSampler <span class="keyword">as</span> DGDIS</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()) + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">FLAG = FLAG.encode().replace(<span class="string">b&#x27;-&#x27;</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> FLAG.startswith(<span class="string">b&#x27;flag&#123;&#x27;</span>) <span class="keyword">and</span> FLAG.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line">s = <span class="built_in">list</span>(FLAG[<span class="number">5</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line">q = random_prime(<span class="number">1</span>&lt;&lt;<span class="number">512</span>, proof=<span class="literal">False</span>, lbound=<span class="number">1</span>&lt;&lt;<span class="number">511</span>)</span><br><span class="line"></span><br><span class="line">lwe = LWE(n=n, q=q, D=DGDIS(<span class="number">1</span>&lt;&lt;<span class="number">128</span>))</span><br><span class="line">lwe._LWE__s = vector(Zmod(q), s)</span><br><span class="line"></span><br><span class="line">L = [lwe() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;task.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    _ = f.write(<span class="string">f&quot;q = <span class="subst">&#123;q&#125;</span>\n&quot;</span>)</span><br><span class="line">    _ = f.write(<span class="string">f&quot;L = <span class="subst">&#123;L&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>太离谱了, 一个板子三个比赛用, 这题用的还是X-NUCA Diamond的LWE的板子…<br>但是为了充分理解(就是还没理解)LWE到底是怎么通过格子解出来的</p>
<p>先看看这题造的格子<br>加密的式子还是$s \cdot M + e = a \ (mod \ q)$, 这里的$s,M$长度32,一共64个式子<br>这里只知道$M$和$a$要求$s$, 思路都是记$s \cdot M = b $, $b$是格子$M$的一个格点, $a$是格外一个点, 通过对$M$规约找到$good \ basis$ 再利用最近平面算法解决一个CVP, 也就是找到离$a$最近的向量, 也就是$b$</p>
<p>把$s \cdot M = b \ (mod \ q)$再详细点就是<br>$$<br>s_0M_{i,0}+s_1M_{i,1}+…+s_{31}M_{i,31} = b_i + k_iq\\<br>s_0M_{i,0}+s_1M_{i,1}+…+s_{31}M_{i,31}+ k_iq = b_i<br>$$<br>那么造出来的格子应该是下面这个矩阵<br>$$<br>(s_0,s_1,\cdots,s_{31},k_0,k_1,\cdots,k_{63})<br>\begin{pmatrix}<br>M_{0,0}&amp;M_{1,0}&amp;\cdots&amp;M_{63,0}\\<br>M_{0,1}&amp;M_{1,1}&amp;\cdots&amp;M_{63,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>M_{0,31}&amp;M_{1,31}&amp;\cdots&amp;M_{63,31}\\<br>q&amp;0&amp;\cdots&amp;0\\<br>0&amp;q&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;0&amp;q<br>\end{pmatrix}<br>=<br>(b_0,b_1,\cdots,b_{63})<br>$$</p>
<p>实际上做题的时候矩阵是上面$p$下面$M$的, 然后还有关于为什么要用64组LWE的问题, 根据某个大佬的博客, 组数越多越好, 所以基本上题目给了多少组就用上多少组</p>
<p>通过对构造出来的格子进行规约得到good basis然后用最近平面算出$(b_0,b_1,…,b_{63})$<br>再解方程$s \cdot M = b \ (mod \ p)$即可得到$s$</p>
<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BabaisClosestPlaneAlgorithm</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Yet another method to solve apprCVP, using a given good basis.</span></span><br><span class="line"><span class="string">    INPUT:</span></span><br><span class="line"><span class="string">    * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice.</span></span><br><span class="line"><span class="string">    * &quot;w&quot; -- a target vector to approach to.</span></span><br><span class="line"><span class="string">    OUTPUT:</span></span><br><span class="line"><span class="string">    * &quot;v&quot; -- a approximate closest vector.</span></span><br><span class="line"><span class="string">    Quoted from &quot;An Introduction to Mathematical Cryptography&quot;:</span></span><br><span class="line"><span class="string">    In both theory and practice, Babai&#x27;s closest plane algorithm</span></span><br><span class="line"><span class="string">    seems to yield better results than Babai&#x27;s closest vertex algorithm.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    G, _ = L.gram_schmidt()</span><br><span class="line">    t = w</span><br><span class="line">    i = L.nrows() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        w -= <span class="built_in">round</span>( (w*G[i]) / G[i].norm()^<span class="number">2</span> ) * L[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t - w</span><br><span class="line"></span><br><span class="line">q = <span class="number">8934325385505568130914092337950620590424921674062792756625169144539462888362199042365894202712873706261308891694743761726859424971637596576879385466842113</span></span><br><span class="line">L = [...]</span><br><span class="line">n = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">Q = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line">R = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line">LL = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        LL[i][j] = L[i][<span class="number">0</span>][j] </span><br><span class="line">M = Matrix(LL).transpose()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            Q[i][j] = q</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">    R[i] = L[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">R = vector(R)</span><br><span class="line">L = Matrix(Q).stack(Matrix(M))</span><br><span class="line">lattice = IntegerLattice(L, lll_reduce=<span class="literal">True</span>)</span><br><span class="line">closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)</span><br><span class="line"></span><br><span class="line">FLAG = Matrix(Zmod(q), M.transpose())</span><br><span class="line">flag = FLAG.solve_right(closest_vector)</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join( <span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br></pre></td></tr></table></figure>

<h1 id="2021-3-31-update"><a href="#2021-3-31-update" class="headerlink" title="2021/3/31 update"></a>2021/3/31 update</h1><blockquote>
<p>因为最近在做大学生密码挑战赛的LWE, 所以学了挺多造格子的姿势<br>这边记录一个好用的格子, 80维的秘密向量都可以规约出来, 很牛逼</p>
</blockquote>
<p>在$As + e = b \mod q$中</p>
<p>我们可以把矩阵$A$和向量$b$看成$A=\begin{pmatrix}A_1 \\ A_2\end{pmatrix}$,$b=\begin{pmatrix}b_1 \\ b_2\end{pmatrix}=\begin{pmatrix}A_1 \\ A_2\end{pmatrix}s + \begin{pmatrix}e_1 \\ e_2\end{pmatrix} $</p>
<p>所以咱们就可以构造出这么一个格子<br>$$<br>\begin{pmatrix}<br>I_n&amp;0&amp;b_1 \\<br>A_2A_1^{-1}&amp;qI_{m-n}&amp;b_2 \\<br>0&amp;0&amp;1<br>\end{pmatrix}<br>\begin{pmatrix}<br>A_1s \\<br>k \\<br>-1<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>-e_1 \\<br>-e_2 \\<br>-1<br>\end{pmatrix}<br>$$<br>规约出来的就直接是噪音$e$了, 有了$e$就能解出$s$, 不过这边还是有几个点要去注意</p>
<ol>
<li>上面式子给出的格子并不是扔进<code>sage</code>里规约的格子, 真正扔进去规约的是它的转置, 也不知道是不是<code>sage</code>默认对行向量规约, 只能把它转置才能规约出结果, 结果也是行向量来的</li>
<li>格子中有一个$A_2A_1^{-1}$, 其中的逆矩阵$A_1^{-1}$是模$q$的逆, 有时候会出现模$q$不能求逆的情况, 这个时候可以适当的调换$A$中的行向量, 使得$A_1 \mod q$的逆存在, 但要记得向量$b$也要跟着调换, 而且最后求到的结果也是调换之后的, 需要还原回去</li>
</ol>
<blockquote>
<p>暂时就这两个点了</p>
</blockquote>
<p>为了写个板子供以后做题用, 我把祥云杯那道题的数据拿过来写了个<code>exp</code>, 贴在这边以后要用了可以过来拿.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">row = <span class="number">128</span></span><br><span class="line">col = <span class="number">42</span></span><br><span class="line">p = <span class="number">2129</span></span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="built_in">list</span>(np.load(<span class="string">&#x27;matrix.npy&#x27;</span>)))</span><br><span class="line">R = vector(<span class="built_in">list</span>(np.load(<span class="string">&#x27;result.npy&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">A1 = M[:col]</span><br><span class="line">A2 = M[col:]</span><br><span class="line">A12 = A2 * A1.inverse() % p</span><br><span class="line"></span><br><span class="line">L = Matrix([[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>)])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            L[i,j] = <span class="number">1</span>         </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row - col):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(row - col):</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            L[i+col,j+col] = p</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row-col):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">        L[i+col,j] = A12[i,j]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">    L[i,-<span class="number">1</span>] = R[i]</span><br><span class="line">L[-<span class="number">1</span>,-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reduced = L.transpose().LLL()</span><br><span class="line">error = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reduced[<span class="number">0</span>][:-<span class="number">1</span>]:</span><br><span class="line">    error.append(-i)</span><br><span class="line">e = vector(error)</span><br><span class="line">As = R - e</span><br><span class="line">A = Matrix(Zmod(p),M)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A.solve_right(As):</span><br><span class="line">    print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>


        </div></article>
      <nav class="pagination"><a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    <a class="next" href="/page/5/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/tearsjin" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">K1rit0</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
