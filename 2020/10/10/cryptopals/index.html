<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="k1rit0"><title>cryptopals · K1rit0's Blog</title><meta name="description" content="开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久…
目录
cryptopals 1.1 - Convert hex to base64
cryptopals 1.2 - Fixed XOR
cryptopals 1.3 - Single-byte XOR cipher
cryp"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="https://avatars.githubusercontent.com/u/56160386?s=96&amp;v=4"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="https://avatars.githubusercontent.com/u/56160386?s=400&amp;v=4" style="width:220px;" alt="favicon"><h3 title=""><a href="/">K1rit0's Blog</a></h3><div class="description"><p>just for fun</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/tearsjin"><i class="fa fa-github"></i></a></li><li><a href="mailto:k1rit0@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=3519728596"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> k1rit0</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>cryptopals</a></h3></div><div class="post-content"><p><blockquote>
<p>开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久…</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#1">cryptopals 1.1 - Convert hex to base64</a></li>
<li><a href="#2">cryptopals 1.2 - Fixed XOR</a></li>
<li><a href="#3">cryptopals 1.3 - Single-byte XOR cipher</a></li>
<li><a href="#4">cryptopals 1.4 - Detect single-character XOR</a></li>
<li><a href="#5">cryptopals 1.5 - Implement repeating-key XOR</a></li>
<li><a href="#6">cryptopals 1.6 - Break repeating-key XOR</a></li>
<li><a href="#7">cryptopals 1.7 - AES in ECB mode</a></li>
<li><a href="#7">cryptopals 1.8 - Detect AES in ECB mode</a></li>
</ul>
</blockquote>
<p><a name="1"></a></p>
<h1 id="cryptopals-1-1-Convert-hex-to-base64"><a href="#cryptopals-1-1-Convert-hex-to-base64" class="headerlink" title="cryptopals 1.1 - Convert hex to base64"></a>cryptopals 1.1 - Convert hex to base64</h1><h2 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h2><p> The string:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d</span><br></pre></td></tr></table></figure>
<p>Should produce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</span><br></pre></td></tr></table></figure>
<p>So go ahead and make that happen. You’ll need to use this code for the rest of the exercises. </p>
<p>大概就是手动写一个hex2base64的脚本吧</p>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>写之前先去了解一下hex转base64的原理(wiki真不错<br><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的表示方法。由于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="10.249ex" height="2.034ex" role="img" focusable="false" viewBox="0 -694 4530.1 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(783,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mn" transform="translate(1696.6,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(2974.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4030.1,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g></g></g></svg></mjx-container>，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。<br><img src="http://47.98.130.190:8090/upload/2020/10/%E5%9B%BE%E7%89%87-5317dc14984d42eda2d1023d847d30d7.png" alt="图片.png"></p>
<p>转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中的字符作为编码后的输出，直到全部输入数据转换完成。</p>
<p>若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。 </p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>知道原理就好写脚本了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(Hex) % <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> Hex + <span class="string">'0'</span> * (<span class="number">6</span> - <span class="built_in">len</span>(Hex) % <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> Hex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encodeb64</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    Hex = padding(Hex)</span><br><span class="line">    output = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(Hex), <span class="number">6</span>):</span><br><span class="line">        buff = <span class="built_in">bin</span>(<span class="built_in">int</span>(Hex[i:i + <span class="number">6</span>], <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">        buff = <span class="string">'0'</span> * (<span class="number">24</span> - <span class="built_in">len</span>(buff)) + buff</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(buff), <span class="number">6</span>):</span><br><span class="line">            value = <span class="built_in">int</span>(buff[j:j + <span class="number">6</span>], <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">'='</span></span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">26</span>:</span><br><span class="line">                output += <span class="built_in">chr</span>(value + <span class="number">65</span>)</span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">52</span>:</span><br><span class="line">                output += <span class="built_in">chr</span>(value + <span class="number">71</span>)</span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">62</span>:</span><br><span class="line">                output += <span class="built_in">str</span>(value - <span class="number">52</span>)</span><br><span class="line">            <span class="keyword">elif</span> value == <span class="number">62</span>:</span><br><span class="line">                output += <span class="string">'+'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Hex = <span class="string">'49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d'</span></span><br><span class="line">    print(encodeb64(Hex))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><a name="2"></a></p>
<h1 id="cryptopals-1-2-Fixed-XOR"><a href="#cryptopals-1-2-Fixed-XOR" class="headerlink" title="cryptopals 1.2 - Fixed XOR"></a>cryptopals 1.2 - Fixed XOR</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> Write a function that takes two equal-length buffers and produces their XOR combination.</p>
<p>If your function works properly, then when you feed it the string:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1c0111001f010100061a024b53535009181c</span><br></pre></td></tr></table></figure><br>… after hex decoding, and when XOR’d against:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">686974207468652062756c6c277320657965</span><br></pre></td></tr></table></figure><br>… should produce:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">746865206b696420646f6e277420706c6179</span><br></pre></td></tr></table></figure><br>相同长度的十六进制的xor, 一位一位的xor就行了吧</p>
<h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixex_xor</span>(<span class="params">Hex1, Hex2</span>):</span></span><br><span class="line">    res = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(Hex1, Hex2):</span><br><span class="line">        res += <span class="built_in">hex</span>(<span class="built_in">int</span>(i, <span class="number">16</span>) ^ <span class="built_in">int</span>(j, <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Hex1 = <span class="string">'1c0111001f010100061a024b53535009181c'</span></span><br><span class="line">    Hex2 = <span class="string">'686974207468652062756c6c277320657965'</span></span><br><span class="line">    print(fixex_xor(Hex1, Hex2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还是比较简单的,后面就不一定了Orz<br><a name="3"></a></p>
</blockquote>
<h1 id="cryptopals-1-3-Single-byte-XOR-cipher"><a href="#cryptopals-1-3-Single-byte-XOR-cipher" class="headerlink" title="cryptopals 1.3 - Single-byte XOR cipher"></a>cryptopals 1.3 - Single-byte XOR cipher</h1><blockquote>
<p>从这里开始难度突然就上升了</p>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p> The hex encoded string:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736</span><br></pre></td></tr></table></figure><br>… has been XOR’d against a single character. Find the key, decrypt the message.</p>
</blockquote>
<p>You can do this by hand. But don’t: write code to do it for you.</p>
<p>How? Devise some method for “scoring” a piece of English plaintext. Character frequency is a good metric. Evaluate each output and choose the one with the best score. </p>
<p>说是一段文字被单个字符(8bit)异或加密了, 要找出这个字符然后输出明文, 密钥空间为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.119ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 936.6 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g></g></g></svg></mjx-container>, 也不算多, 但是如何让程序找出唯一一个正确的字符?</p>
<p>提示上有提到可以利用解密后的字符串的”得分”. 查了一下, 在一个dalao的博客上找到的这个得分应该叫<strong>字符频率</strong>(dalao说wiki上有字符频率表, 但我没找到, 就连这个”得分”的相关内容都没找到), 但是还好他的博客里附带了一个字符频率的数组.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = { <span class="comment">#字符频率表, 出现一次某字母的得分</span></span><br><span class="line">    <span class="string">'a'</span>: <span class="number">0.0651738</span>, <span class="string">'b'</span>: <span class="number">0.0124248</span>, <span class="string">'c'</span>: <span class="number">0.0217339</span>, <span class="string">'d'</span>: <span class="number">0.0349835</span>, <span class="string">'e'</span>: <span class="number">0.1041442</span>, <span class="string">'f'</span>: <span class="number">0.0197881</span>, <span class="string">'g'</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">'h'</span>: <span class="number">0.0492888</span>, <span class="string">'i'</span>: <span class="number">0.0558094</span>, <span class="string">'j'</span>: <span class="number">0.0009033</span>, <span class="string">'k'</span>: <span class="number">0.0050529</span>, <span class="string">'l'</span>: <span class="number">0.0331490</span>, <span class="string">'m'</span>: <span class="number">0.0202124</span>, <span class="string">'n'</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">'o'</span>: <span class="number">0.0596302</span>, <span class="string">'p'</span>: <span class="number">0.0137645</span>, <span class="string">'q'</span>: <span class="number">0.0008606</span>, <span class="string">'r'</span>: <span class="number">0.0497563</span>, <span class="string">'s'</span>: <span class="number">0.0515760</span>, <span class="string">'t'</span>: <span class="number">0.0729357</span>, <span class="string">'u'</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">'v'</span>: <span class="number">0.0082903</span>, <span class="string">'w'</span>: <span class="number">0.0171272</span>, <span class="string">'x'</span>: <span class="number">0.0013692</span>, <span class="string">'y'</span>: <span class="number">0.0145984</span>, <span class="string">'z'</span>: <span class="number">0.0007836</span>, <span class="string">' '</span>: <span class="number">0.1918182</span>}</span><br></pre></td></tr></table></figure>
<p>通过这个字符频率表, 可以定量的分析每次解密结果的得分, 得分最高就代表最接近正常英文语句(或者说文章).</p>
<h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = {  <span class="comment"># 字符频率表, 出现一次某字母的得分</span></span><br><span class="line">    <span class="string">'a'</span>: <span class="number">0.0651738</span>, <span class="string">'b'</span>: <span class="number">0.0124248</span>, <span class="string">'c'</span>: <span class="number">0.0217339</span>, <span class="string">'d'</span>: <span class="number">0.0349835</span>, <span class="string">'e'</span>: <span class="number">0.1041442</span>, <span class="string">'f'</span>: <span class="number">0.0197881</span>, <span class="string">'g'</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">'h'</span>: <span class="number">0.0492888</span>, <span class="string">'i'</span>: <span class="number">0.0558094</span>, <span class="string">'j'</span>: <span class="number">0.0009033</span>, <span class="string">'k'</span>: <span class="number">0.0050529</span>, <span class="string">'l'</span>: <span class="number">0.0331490</span>, <span class="string">'m'</span>: <span class="number">0.0202124</span>, <span class="string">'n'</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">'o'</span>: <span class="number">0.0596302</span>, <span class="string">'p'</span>: <span class="number">0.0137645</span>, <span class="string">'q'</span>: <span class="number">0.0008606</span>, <span class="string">'r'</span>: <span class="number">0.0497563</span>, <span class="string">'s'</span>: <span class="number">0.0515760</span>, <span class="string">'t'</span>: <span class="number">0.0729357</span>, <span class="string">'u'</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">'v'</span>: <span class="number">0.0082903</span>, <span class="string">'w'</span>: <span class="number">0.0171272</span>, <span class="string">'x'</span>: <span class="number">0.0013692</span>, <span class="string">'y'</span>: <span class="number">0.0145984</span>, <span class="string">'z'</span>: <span class="number">0.0007836</span>, <span class="string">' '</span>: <span class="number">0.1918182</span>}</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Set1.Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex2text</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    h = Hex</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(h) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        t = <span class="string">'0'</span> + h</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(b, <span class="number">16</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> [h[i:i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(h), <span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span>(<span class="params">LEN</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>): <span class="keyword">yield</span> ((<span class="number">2</span> - <span class="built_in">len</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])) * <span class="string">'0'</span> + <span class="built_in">hex</span>(i)[<span class="number">2</span>:]) * (LEN // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getscore</span>(<span class="params">text</span>):</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text:</span><br><span class="line">        i = i.lower()</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> CHARACTER_FREQ:</span><br><span class="line">            score += CHARACTER_FREQ[i]</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cipher</span>):</span></span><br><span class="line">    generator = keygen(<span class="built_in">len</span>(cipher))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">        plain = hex2text(fixed_xor(cipher, i))</span><br><span class="line">        score = getscore(plain)</span><br><span class="line">        res.append([plain, score, i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">'1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'</span></span><br><span class="line">    <span class="built_in">max</span> = [<span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> attack(cipher):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>[<span class="number">1</span>] &lt; i[<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">max</span> = i</span><br><span class="line">    print(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>关于最后面的排序, 看了相关文章发现其实可以用<code>sorted()</code>函数</p>
<p>直接举例子, 简单易懂</p>
<ol>
<li>对键排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1={<span class="string">'a'</span>:<span class="number">2</span>,<span class="string">'e'</span>:<span class="number">3</span>,<span class="string">'f'</span>:<span class="number">8</span>,<span class="string">'d'</span>:<span class="number">4</span>}</span><br><span class="line">list1= <span class="built_in">sorted</span>(dict1.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
2.对值排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1={<span class="string">'a'</span>:<span class="number">2</span>,<span class="string">'e'</span>:<span class="number">3</span>,<span class="string">'f'</span>:<span class="number">8</span>,<span class="string">'d'</span>:<span class="number">4</span>}</span><br><span class="line">list1= <span class="built_in">sorted</span>(dict1.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
借用大佬的代码, 其实attack函数可以写成<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cipher</span>):</span> </span><br><span class="line">    generator = keygen(<span class="built_in">len</span>(cipher))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">        plain = hex2text(fixed_xor(cipher, i))</span><br><span class="line">        score = getscore(plain)</span><br><span class="line">        res.append({<span class="string">'key'</span>: key, <span class="string">'plaintext'</span>: plaintext, <span class="string">'score'</span>: score})</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(res, key = <span class="keyword">lambda</span> c:c[<span class="string">'score'</span>])</span><br></pre></td></tr></table></figure>
<a name="4"></a></li>
</ol>
<h1 id="cryptopals-1-4-Detect-single-character-XOR"><a href="#cryptopals-1-4-Detect-single-character-XOR" class="headerlink" title="cryptopals 1.4 - Detect single-character XOR"></a>cryptopals 1.4 - Detect single-character XOR</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p> One of the 60-character strings in <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/4.txt">this file</a> has been encrypted by single-character XOR.</p>
<p>Find it.</p>
<p>(Your code from #3 should help.) </p>
<p>意思是说, 在那个文件里面的60个字符串里面, 有一个是被xor加密过后的(一开始读题还以为是60个都是被加密的), 让我们找到他并且解密出来.</p>
<p>其实跟1.3没什么区别, 只是从1组里面选得分最高的密钥变成先根据密钥选出1组里面最高分的, 再选出60个字符串里面最高分的那组.</p>
<h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Single_byte_XOR_cipher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">''</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'4.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cipher = f.readline()[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> cipher == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res.append(attack(cipher)[-<span class="number">1</span>])</span><br><span class="line">    print(<span class="built_in">sorted</span>(res, key=<span class="keyword">lambda</span> x: x[<span class="string">'score'</span>])[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="5"></a></p>
<h1 id="cryptopals-1-5-Implement-repeating-key-XOR"><a href="#cryptopals-1-5-Implement-repeating-key-XOR" class="headerlink" title="cryptopals 1.5 - Implement repeating-key XOR"></a>cryptopals 1.5 - Implement repeating-key XOR</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p> Here is the opening stanza of an important work of the English language:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Burning 'em, if you ain't quick and nimble</span><br><span class="line">I go crazy when I hear a cymbal</span><br></pre></td></tr></table></figure><br>Encrypt it, under the key “ICE”, using repeating-key XOR.</p>
<p>In repeating-key XOR, you’ll sequentially apply each byte of the key; the first byte of plaintext will be XOR’d against I, the next C, the next E, then I again for the 4th byte, and so on.</p>
<p>It should come out to:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272</span><br><span class="line">a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f</span><br></pre></td></tr></table></figure><br>Encrypt a bunch of stuff using your repeating-key XOR function. Encrypt your mail. Encrypt your password file. Your .sig file. Get a feel for it. I promise, we aren’t wasting your time with this. </p>
<p>题目升级了!!!</p>
<h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>写完脚本才发现他是要我加密, 而不是解密, 所以只好再写一个加密的了</p>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"><span class="keyword">from</span> Single_byte_XOR_cipher <span class="keyword">import</span> hex2text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypadding</span>(<span class="params">ciplen, key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ciplen)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">'0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272\na282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f'</span></span><br><span class="line">    key = <span class="string">'ICE'</span></span><br><span class="line">    cipher = <span class="string">''</span>.join(cipher.split(<span class="string">'\n'</span>))</span><br><span class="line">    padkey = text2hex(keypadding(<span class="built_in">len</span>(cipher), key))</span><br><span class="line">    res = hex2text(fixed_xor(cipher, padkey))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypadding</span>(<span class="params">ciplen, key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join([key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ciplen)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    plain = <span class="string">"Burning 'em, if you ain't quick and nimble I go crazy when I hear a cymbal"</span></span><br><span class="line">    key = <span class="string">'ICE'</span></span><br><span class="line">    padkey = keypadding(<span class="built_in">len</span>(plain), key)</span><br><span class="line">    hexplain = text2hex(plain)</span><br><span class="line">    hexpadkey = text2hex(padkey)</span><br><span class="line">    print(fixed_xor(hexplain, hexpadkey))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="6"></a></p>
<h1 id="cryptopals-1-6-Break-repeating-key-XOR"><a href="#cryptopals-1-6-Break-repeating-key-XOR" class="headerlink" title="cryptopals 1.6 - Break repeating-key XOR"></a>cryptopals 1.6 - Break repeating-key XOR</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p> There’s a <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/6.txt">file here</a>. It’s been base64’d after being encrypted with repeating-key XOR.</p>
<p>Decrypt it.</p>
<p>Here’s how:</p>
<ol>
<li>Let KEYSIZE be the guessed length of the key; try values from 2 to (say) 40.</li>
<li>Write a function to compute the edit distance/Hamming distance between two strings. <em>The Hamming distance is just the number of differing bits.</em> The distance between:<br><code>this is a test</code> and  <code>wokka wokka!!!</code> is 37. Make sure your code agrees before you proceed.</li>
<li>For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes, and find the edit distance between them. Normalize this result by dividing by KEYSIZE.</li>
<li>The KEYSIZE with the smallest normalized edit distance is probably the key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or take 4 KEYSIZE blocks instead of 2 and average the distances.</li>
<li>Now that you probably know the KEYSIZE: break the ciphertext into blocks of KEYSIZE length.</li>
<li>Now transpose the blocks: make a block that is the first byte of every block, and a block that is the second byte of every block, and so on.</li>
<li>Solve each block as if it was single-character XOR. You already have code to do this.</li>
<li>For each block, the single-byte XOR key that produces the best looking histogram is the repeating-key XOR key byte for that block. Put them together and you have the key.</li>
</ol>
<p>This code is going to turn out to be surprisingly useful later on. Breaking repeating-key XOR (“Vigenere”) statistically is obviously an academic exercise, a “Crypto 101” thing. But more people “know how” to break it than can actually break it, and a similar technique breaks something much more important.<br><a name="7"></a></p>
<h1 id="cryptopals-1-7-AES-in-ECB-mode"><a href="#cryptopals-1-7-AES-in-ECB-mode" class="headerlink" title="cryptopals 1.7 - AES in ECB mode"></a>cryptopals 1.7 - AES in ECB mode</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p> The Base64-encoded content <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/7.txt">in this file</a> has been encrypted via AES-128 in ECB mode under the key</p>
<pre><code>"YELLOW SUBMARINE".
</code></pre><p>(case-sensitive, without the quotes; exactly 16 characters; I like “YELLOW SUBMARINE” because it’s exactly 16 bytes long, and now you do too).</p>
<p>Decrypt it. You know the key, after all.</p>
<p>Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher. </p>
<p>You can obviously decrypt this using the OpenSSL command-line tool, but we’re having you get ECB working in code for a reason. You’ll need it a lot later on, and not just for attacking ECB. </p>
<blockquote>
<p>未完待续…<br><a name="8"></a></p>
</blockquote>
<h1 id="cryptopals-1-8-Detect-AES-in-ECB-mode"><a href="#cryptopals-1-8-Detect-AES-in-ECB-mode" class="headerlink" title="cryptopals 1.8 - Detect AES in ECB mode"></a>cryptopals 1.8 - Detect AES in ECB mode</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>In <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/8.txt">this file</a> are a bunch of hex-encoded ciphertexts.</p>
<p>One of them has been encrypted with ECB.</p>
<p>Detect it.</p>
<p>Remember that the problem with ECB is that it is stateless and deterministic; the same 16 byte plaintext block will always produce the same 16 byte ciphertext.</p>
<blockquote>
<p>未完待续…</p>
</blockquote>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: k1rit0</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-10</span><a class="tag" href="/categories/CryptoSummary/" title="CryptoSummary">CryptoSummary </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Crypto/" title="Crypto">Crypto </a><i class="fa fa-tag"></i><a class="tag" href="/tags/cryptopals/" title="cryptopals">cryptopals </a><span class="leancloud_visitors"></span><span>About 2307 words, 7 min 41 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://tearsjin.github.io/2020/10/10/cryptopals/,K1rit0's Blog,cryptopals,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/10/22/web-md5%E5%BC%B1%E7%B1%BB%E5%9E%8B/" title="PHP Weak type about MD5">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/09/29/SQL%E6%B3%A8%E5%85%A5%E7%BB%8F%E9%AA%8C%E5%A4%A7%E6%9D%82%E7%83%A9/" title="Experience summary of SQL injection">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>