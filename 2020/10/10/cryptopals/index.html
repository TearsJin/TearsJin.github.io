<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="k1rit0"><title>cryptopals · K1rit0's Blog</title><meta name="description" content="开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久…

目录
cryptopals 1.1 - Convert hex to base64
cryptopals 1.2 - Fixed XOR
cryptopals 1.3 - Single-byte XOR cipher
cry"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/tags">Tags</a></li><li> <a href="/about">About</a></li><li> <a href="/links">Links</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="https://avatars.githubusercontent.com/u/56160386?s=96&amp;v=4"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:220px;" alt="favicon"><h3 title=""><a href="/">K1rit0's Blog</a></h3><div class="description"><p>just for fun</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/tearsjin"><i class="fa fa-github"></i></a></li><li><a href="mailto:k1rit0@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=3519728596"><i class="fa fa-qq"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> k1rit0</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>cryptopals</a></h3></div><div class="post-content"><p><blockquote>
<p>开始学习cryptopals啦, 一题一题的做完它吧(也不知道能做多久…</p>
</blockquote>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><a href="#1">cryptopals 1.1 - Convert hex to base64</a></li>
<li><a href="#2">cryptopals 1.2 - Fixed XOR</a></li>
<li><a href="#3">cryptopals 1.3 - Single-byte XOR cipher</a></li>
<li><a href="#4">cryptopals 1.4 - Detect single-character XOR</a></li>
<li><a href="#5">cryptopals 1.5 - Implement repeating-key XOR</a></li>
<li><a href="#6">cryptopals 1.6 - Break repeating-key XOR</a></li>
<li><a href="#7">cryptopals 1.7 - AES in ECB mode</a></li>
<li><a href="#7">cryptopals 1.8 - Detect AES in ECB mode</a></li>
</ul>
<p><a name='1'></a></p>
<h1 id="cryptopals-1-1-Convert-hex-to-base64"><a href="#cryptopals-1-1-Convert-hex-to-base64" class="headerlink" title="cryptopals 1.1 - Convert hex to base64"></a>cryptopals 1.1 - Convert hex to base64</h1><h2 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h2><p> The string:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d</span><br></pre></td></tr></table></figure>

<p>Should produce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</span><br></pre></td></tr></table></figure>

<p>So go ahead and make that happen. You’ll need to use this code for the rest of the exercises. </p>
<p>大概就是手动写一个hex2base64的脚本吧</p>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>写之前先去了解一下hex转base64的原理(wiki真不错<br><strong>Base64</strong>是一种基于64个可打印字符来表示二进制数据的表示方法。由于 $log _2 64=6$，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。<br><img src="http://47.98.130.190:8090/upload/2020/10/%E5%9B%BE%E7%89%87-5317dc14984d42eda2d1023d847d30d7.png" alt="图片.png"></p>
<p>转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>中的字符作为编码后的输出，直到全部输入数据转换完成。</p>
<p>若原数据长度不是3的倍数时且剩下1个输入数据，则在编码结果后加2个=；若剩下2个输入数据，则在编码结果后加1个=。 </p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>知道原理就好写脚本了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(Hex) % <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> Hex + <span class="string">&#x27;0&#x27;</span> * (<span class="number">6</span> - <span class="built_in">len</span>(Hex) % <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> Hex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encodeb64</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    Hex = padding(Hex)</span><br><span class="line">    output = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(Hex), <span class="number">6</span>):</span><br><span class="line">        buff = <span class="built_in">bin</span>(<span class="built_in">int</span>(Hex[i:i + <span class="number">6</span>], <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">        buff = <span class="string">&#x27;0&#x27;</span> * (<span class="number">24</span> - <span class="built_in">len</span>(buff)) + buff</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(buff), <span class="number">6</span>):</span><br><span class="line">            value = <span class="built_in">int</span>(buff[j:j + <span class="number">6</span>], <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">26</span>:</span><br><span class="line">                output += <span class="built_in">chr</span>(value + <span class="number">65</span>)</span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">52</span>:</span><br><span class="line">                output += <span class="built_in">chr</span>(value + <span class="number">71</span>)</span><br><span class="line">            <span class="keyword">elif</span> value &lt; <span class="number">62</span>:</span><br><span class="line">                output += <span class="built_in">str</span>(value - <span class="number">52</span>)</span><br><span class="line">            <span class="keyword">elif</span> value == <span class="number">62</span>:</span><br><span class="line">                output += <span class="string">&#x27;+&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Hex = <span class="string">&#x27;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&#x27;</span></span><br><span class="line">    print(encodeb64(Hex))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name='2'></a></p>
<h1 id="cryptopals-1-2-Fixed-XOR"><a href="#cryptopals-1-2-Fixed-XOR" class="headerlink" title="cryptopals 1.2 - Fixed XOR"></a>cryptopals 1.2 - Fixed XOR</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p> Write a function that takes two equal-length buffers and produces their XOR combination.</p>
<p>If your function works properly, then when you feed it the string:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1c0111001f010100061a024b53535009181c</span><br></pre></td></tr></table></figure>
<p>… after hex decoding, and when XOR’d against:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">686974207468652062756c6c277320657965</span><br></pre></td></tr></table></figure>
<p>… should produce:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">746865206b696420646f6e277420706c6179</span><br></pre></td></tr></table></figure>
<p>相同长度的十六进制的xor, 一位一位的xor就行了吧</p>
<h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fixex_xor</span>(<span class="params">Hex1, Hex2</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(Hex1, Hex2):</span><br><span class="line">        res += <span class="built_in">hex</span>(<span class="built_in">int</span>(i, <span class="number">16</span>) ^ <span class="built_in">int</span>(j, <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Hex1 = <span class="string">&#x27;1c0111001f010100061a024b53535009181c&#x27;</span></span><br><span class="line">    Hex2 = <span class="string">&#x27;686974207468652062756c6c277320657965&#x27;</span></span><br><span class="line">    print(fixex_xor(Hex1, Hex2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还是比较简单的,后面就不一定了Orz<br><a name='3'></a></p>
</blockquote>
<h1 id="cryptopals-1-3-Single-byte-XOR-cipher"><a href="#cryptopals-1-3-Single-byte-XOR-cipher" class="headerlink" title="cryptopals 1.3 - Single-byte XOR cipher"></a>cryptopals 1.3 - Single-byte XOR cipher</h1><blockquote>
<p>从这里开始难度突然就上升了</p>
</blockquote>
<h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p> The hex encoded string:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736</span><br></pre></td></tr></table></figure>
<p>… has been XOR’d against a single character. Find the key, decrypt the message.</p>
<p>You can do this by hand. But don’t: write code to do it for you.</p>
<p>How? Devise some method for “scoring” a piece of English plaintext. Character frequency is a good metric. Evaluate each output and choose the one with the best score. </p>
<p>说是一段文字被单个字符(8bit)异或加密了, 要找出这个字符然后输出明文, 密钥空间为$2^8$, 也不算多, 但是如何让程序找出唯一一个正确的字符?</p>
<p>提示上有提到可以利用解密后的字符串的”得分”. 查了一下, 在一个dalao的博客上找到的这个得分应该叫<strong>字符频率</strong>(dalao说wiki上有字符频率表, 但我没找到, 就连这个”得分”的相关内容都没找到), 但是还好他的博客里附带了一个字符频率的数组.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = &#123; <span class="comment">#字符频率表, 出现一次某字母的得分</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">0.0651738</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0.0124248</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">0.0217339</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">0.0349835</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">0.1041442</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">0.0197881</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>: <span class="number">0.0492888</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">0.0558094</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">0.0009033</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">0.0050529</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">0.0331490</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">0.0202124</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>: <span class="number">0.0596302</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">0.0137645</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">0.0008606</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">0.0497563</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">0.0515760</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">0.0729357</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">&#x27;v&#x27;</span>: <span class="number">0.0082903</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">0.0171272</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">0.0013692</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0.0145984</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">0.0007836</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">0.1918182</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个字符频率表, 可以定量的分析每次解密结果的得分, 得分最高就代表最接近正常英文语句(或者说文章).</p>
<h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = &#123;  <span class="comment"># 字符频率表, 出现一次某字母的得分</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="number">0.0651738</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">0.0124248</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">0.0217339</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">0.0349835</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">0.1041442</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">0.0197881</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span>: <span class="number">0.0492888</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">0.0558094</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">0.0009033</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">0.0050529</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">0.0331490</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">0.0202124</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span>: <span class="number">0.0596302</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">0.0137645</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">0.0008606</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">0.0497563</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">0.0515760</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">0.0729357</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">&#x27;v&#x27;</span>: <span class="number">0.0082903</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">0.0171272</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">0.0013692</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0.0145984</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">0.0007836</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">0.1918182</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Set1.Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex2text</span>(<span class="params">Hex</span>):</span></span><br><span class="line">    h = Hex</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(h) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        t = <span class="string">&#x27;0&#x27;</span> + h</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(b, <span class="number">16</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> [h[i:i + <span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(h), <span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span>(<span class="params">LEN</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>): <span class="keyword">yield</span> ((<span class="number">2</span> - <span class="built_in">len</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])) * <span class="string">&#x27;0&#x27;</span> + <span class="built_in">hex</span>(i)[<span class="number">2</span>:]) * (LEN // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getscore</span>(<span class="params">text</span>):</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> text:</span><br><span class="line">        i = i.lower()</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> CHARACTER_FREQ:</span><br><span class="line">            score += CHARACTER_FREQ[i]</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cipher</span>):</span></span><br><span class="line">    generator = keygen(<span class="built_in">len</span>(cipher))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">        plain = hex2text(fixed_xor(cipher, i))</span><br><span class="line">        score = getscore(plain)</span><br><span class="line">        res.append([plain, score, i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">&#x27;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&#x27;</span></span><br><span class="line">    <span class="built_in">max</span> = [<span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> attack(cipher):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span>[<span class="number">1</span>] &lt; i[<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">max</span> = i</span><br><span class="line">    print(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>关于最后面的排序, 看了相关文章发现其实可以用<code>sorted()</code>函数</p>
<p>直接举例子, 简单易懂</p>
<ol>
<li>对键排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;f&#x27;</span>:<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">list1= <span class="built_in">sorted</span>(dict1.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure></li>
<li>对值排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;e&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;f&#x27;</span>:<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line">list1= <span class="built_in">sorted</span>(dict1.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
借用大佬的代码, 其实attack函数可以写成<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>(<span class="params">cipher</span>):</span> </span><br><span class="line">    generator = keygen(<span class="built_in">len</span>(cipher))</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> generator:</span><br><span class="line">        plain = hex2text(fixed_xor(cipher, i))</span><br><span class="line">        score = getscore(plain)</span><br><span class="line">        res.append(&#123;<span class="string">&#x27;key&#x27;</span>: key, <span class="string">&#x27;plaintext&#x27;</span>: plaintext, <span class="string">&#x27;score&#x27;</span>: score&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(res, key = <span class="keyword">lambda</span> c:c[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure>
<a name='4'></a></li>
</ol>
<h1 id="cryptopals-1-4-Detect-single-character-XOR"><a href="#cryptopals-1-4-Detect-single-character-XOR" class="headerlink" title="cryptopals 1.4 - Detect single-character XOR"></a>cryptopals 1.4 - Detect single-character XOR</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p> One of the 60-character strings in <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/4.txt">this file</a> has been encrypted by single-character XOR.</p>
<p>Find it.</p>
<p>(Your code from #3 should help.) </p>
<p>意思是说, 在那个文件里面的60个字符串里面, 有一个是被xor加密过后的(一开始读题还以为是60个都是被加密的), 让我们找到他并且解密出来.</p>
<p>其实跟1.3没什么区别, 只是从1组里面选得分最高的密钥变成先根据密钥选出1组里面最高分的, 再选出60个字符串里面最高分的那组.</p>
<h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Single_byte_XOR_cipher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;4.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cipher = f.readline()[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> cipher == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res.append(attack(cipher)[-<span class="number">1</span>])</span><br><span class="line">    print(<span class="built_in">sorted</span>(res, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>])[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name='5'></a></p>
<h1 id="cryptopals-1-5-Implement-repeating-key-XOR"><a href="#cryptopals-1-5-Implement-repeating-key-XOR" class="headerlink" title="cryptopals 1.5 - Implement repeating-key XOR"></a>cryptopals 1.5 - Implement repeating-key XOR</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p> Here is the opening stanza of an important work of the English language:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Burning &#39;em, if you ain&#39;t quick and nimble</span><br><span class="line">I go crazy when I hear a cymbal</span><br></pre></td></tr></table></figure>
<p>Encrypt it, under the key “ICE”, using repeating-key XOR.</p>
<p>In repeating-key XOR, you’ll sequentially apply each byte of the key; the first byte of plaintext will be XOR’d against I, the next C, the next E, then I again for the 4th byte, and so on.</p>
<p>It should come out to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272</span><br><span class="line">a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f</span><br></pre></td></tr></table></figure>
<p>Encrypt a bunch of stuff using your repeating-key XOR function. Encrypt your mail. Encrypt your password file. Your .sig file. Get a feel for it. I promise, we aren’t wasting your time with this. </p>
<p>题目升级了!!!</p>
<h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>写完脚本才发现他是要我加密, 而不是解密, 所以只好再写一个加密的了</p>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"><span class="keyword">from</span> Single_byte_XOR_cipher <span class="keyword">import</span> hex2text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypadding</span>(<span class="params">ciplen, key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ciplen)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    cipher = <span class="string">&#x27;0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272\na282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f&#x27;</span></span><br><span class="line">    key = <span class="string">&#x27;ICE&#x27;</span></span><br><span class="line">    cipher = <span class="string">&#x27;&#x27;</span>.join(cipher.split(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    padkey = text2hex(keypadding(<span class="built_in">len</span>(cipher), key))</span><br><span class="line">    res = hex2text(fixed_xor(cipher, padkey))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Fixed_XOR <span class="keyword">import</span> fixed_xor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keypadding</span>(<span class="params">ciplen, key</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([key[i % <span class="built_in">len</span>(key)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ciplen)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    plain = <span class="string">&quot;Burning &#x27;em, if you ain&#x27;t quick and nimble I go crazy when I hear a cymbal&quot;</span></span><br><span class="line">    key = <span class="string">&#x27;ICE&#x27;</span></span><br><span class="line">    padkey = keypadding(<span class="built_in">len</span>(plain), key)</span><br><span class="line">    hexplain = text2hex(plain)</span><br><span class="line">    hexpadkey = text2hex(padkey)</span><br><span class="line">    print(fixed_xor(hexplain, hexpadkey))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name='6'></a></p>
<h1 id="cryptopals-1-6-Break-repeating-key-XOR"><a href="#cryptopals-1-6-Break-repeating-key-XOR" class="headerlink" title="cryptopals 1.6 - Break repeating-key XOR"></a>cryptopals 1.6 - Break repeating-key XOR</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p> There’s a <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/6.txt">file here</a>. It’s been base64’d after being encrypted with repeating-key XOR.</p>
<p>Decrypt it.</p>
<p>Here’s how:</p>
<ol>
<li>Let KEYSIZE be the guessed length of the key; try values from 2 to (say) 40.</li>
<li>Write a function to compute the edit distance/Hamming distance between two strings. <em>The Hamming distance is just the number of differing bits.</em> The distance between:<br><code>this is a test</code> and  <code>wokka wokka!!!</code> is 37. Make sure your code agrees before you proceed.</li>
<li>For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes, and find the edit distance between them. Normalize this result by dividing by KEYSIZE.</li>
<li>The KEYSIZE with the smallest normalized edit distance is probably the key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or take 4 KEYSIZE blocks instead of 2 and average the distances.</li>
<li>Now that you probably know the KEYSIZE: break the ciphertext into blocks of KEYSIZE length.</li>
<li>Now transpose the blocks: make a block that is the first byte of every block, and a block that is the second byte of every block, and so on.</li>
<li>Solve each block as if it was single-character XOR. You already have code to do this.</li>
<li>For each block, the single-byte XOR key that produces the best looking histogram is the repeating-key XOR key byte for that block. Put them together and you have the key.</li>
</ol>
<p>This code is going to turn out to be surprisingly useful later on. Breaking repeating-key XOR (“Vigenere”) statistically is obviously an academic exercise, a “Crypto 101” thing. But more people “know how” to break it than can actually break it, and a similar technique breaks something much more important.<br><a name='7'></a></p>
<h1 id="cryptopals-1-7-AES-in-ECB-mode"><a href="#cryptopals-1-7-AES-in-ECB-mode" class="headerlink" title="cryptopals 1.7 - AES in ECB mode"></a>cryptopals 1.7 - AES in ECB mode</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p> The Base64-encoded content <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/7.txt">in this file</a> has been encrypted via AES-128 in ECB mode under the key</p>
<pre><code>&quot;YELLOW SUBMARINE&quot;.
</code></pre>
<p>(case-sensitive, without the quotes; exactly 16 characters; I like “YELLOW SUBMARINE” because it’s exactly 16 bytes long, and now you do too).</p>
<p>Decrypt it. You know the key, after all.</p>
<p>Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher. </p>
<p>You can obviously decrypt this using the OpenSSL command-line tool, but we’re having you get ECB working in code for a reason. You’ll need it a lot later on, and not just for attacking ECB. </p>
<blockquote>
<p>未完待续…<br><a name='8'></a></p>
</blockquote>
<h1 id="cryptopals-1-8-Detect-AES-in-ECB-mode"><a href="#cryptopals-1-8-Detect-AES-in-ECB-mode" class="headerlink" title="cryptopals 1.8 - Detect AES in ECB mode"></a>cryptopals 1.8 - Detect AES in ECB mode</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>In <a target="_blank" rel="noopener" href="https://cryptopals.com/static/challenge-data/8.txt">this file</a> are a bunch of hex-encoded ciphertexts.</p>
<p>One of them has been encrypted with ECB.</p>
<p>Detect it.</p>
<p>Remember that the problem with ECB is that it is stateless and deterministic; the same 16 byte plaintext block will always produce the same 16 byte ciphertext.</p>
<blockquote>
<p>未完待续…</p>
</blockquote>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: k1rit0</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-10</span><a class="tag" href="/categories/CryptoSummary/" title="CryptoSummary">CryptoSummary </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Crypto/" title="Crypto">Crypto </a><i class="fa fa-tag"></i><a class="tag" href="/tags/cryptopals/" title="cryptopals">cryptopals </a><span class="leancloud_visitors"></span><span>About 2518 words, 8 min 23 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://tearsjin.github.io/2020/10/10/cryptopals/,K1rit0's Blog,cryptopals,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/10/22/web-md5%E5%BC%B1%E7%B1%BB%E5%9E%8B/" title="PHP Weak type about MD5">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/09/29/SQL%E6%B3%A8%E5%85%A5%E7%BB%8F%E9%AA%8C%E5%A4%A7%E6%9D%82%E7%83%A9/" title="Experience summary of SQL injection">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>